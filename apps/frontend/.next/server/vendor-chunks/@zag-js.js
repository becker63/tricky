"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@zag-js";
exports.ids = ["vendor-chunks/@zag-js"];
exports.modules = {

/***/ "(ssr)/./node_modules/@zag-js/anatomy/dist/index.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/@zag-js/anatomy/dist/index.mjs ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createAnatomy: () => (/* binding */ createAnatomy)\n/* harmony export */ });\n// src/create-anatomy.ts\nvar createAnatomy = (name, parts = []) => ({\n  parts: (...values) => {\n    if (isEmpty(parts)) {\n      return createAnatomy(name, values);\n    }\n    throw new Error(\"createAnatomy().parts(...) should only be called once. Did you mean to use .extendWith(...) ?\");\n  },\n  extendWith: (...values) => createAnatomy(name, [...parts, ...values]),\n  rename: (newName) => createAnatomy(newName, parts),\n  keys: () => parts,\n  build: () => [...new Set(parts)].reduce(\n    (prev, part) => Object.assign(prev, {\n      [part]: {\n        selector: [\n          `&[data-scope=\"${toKebabCase(name)}\"][data-part=\"${toKebabCase(part)}\"]`,\n          `& [data-scope=\"${toKebabCase(name)}\"][data-part=\"${toKebabCase(part)}\"]`\n        ].join(\", \"),\n        attrs: { \"data-scope\": toKebabCase(name), \"data-part\": toKebabCase(part) }\n      }\n    }),\n    {}\n  )\n});\nvar toKebabCase = (value) => value.replace(/([A-Z])([A-Z])/g, \"$1-$2\").replace(/([a-z])([A-Z])/g, \"$1-$2\").replace(/[\\s_]+/g, \"-\").toLowerCase();\nvar isEmpty = (v) => v.length === 0;\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHphZy1qcy9hbmF0b215L2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixrQkFBa0IsZ0JBQWdCLGtCQUFrQjtBQUMvRSw0QkFBNEIsa0JBQWtCLGdCQUFnQixrQkFBa0I7QUFDaEY7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBR0U7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3NpdGVzLy4vbm9kZV9tb2R1bGVzL0B6YWctanMvYW5hdG9teS9kaXN0L2luZGV4Lm1qcz82OTJlIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9jcmVhdGUtYW5hdG9teS50c1xudmFyIGNyZWF0ZUFuYXRvbXkgPSAobmFtZSwgcGFydHMgPSBbXSkgPT4gKHtcbiAgcGFydHM6ICguLi52YWx1ZXMpID0+IHtcbiAgICBpZiAoaXNFbXB0eShwYXJ0cykpIHtcbiAgICAgIHJldHVybiBjcmVhdGVBbmF0b215KG5hbWUsIHZhbHVlcyk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcImNyZWF0ZUFuYXRvbXkoKS5wYXJ0cyguLi4pIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbmNlLiBEaWQgeW91IG1lYW4gdG8gdXNlIC5leHRlbmRXaXRoKC4uLikgP1wiKTtcbiAgfSxcbiAgZXh0ZW5kV2l0aDogKC4uLnZhbHVlcykgPT4gY3JlYXRlQW5hdG9teShuYW1lLCBbLi4ucGFydHMsIC4uLnZhbHVlc10pLFxuICByZW5hbWU6IChuZXdOYW1lKSA9PiBjcmVhdGVBbmF0b215KG5ld05hbWUsIHBhcnRzKSxcbiAga2V5czogKCkgPT4gcGFydHMsXG4gIGJ1aWxkOiAoKSA9PiBbLi4ubmV3IFNldChwYXJ0cyldLnJlZHVjZShcbiAgICAocHJldiwgcGFydCkgPT4gT2JqZWN0LmFzc2lnbihwcmV2LCB7XG4gICAgICBbcGFydF06IHtcbiAgICAgICAgc2VsZWN0b3I6IFtcbiAgICAgICAgICBgJltkYXRhLXNjb3BlPVwiJHt0b0tlYmFiQ2FzZShuYW1lKX1cIl1bZGF0YS1wYXJ0PVwiJHt0b0tlYmFiQ2FzZShwYXJ0KX1cIl1gLFxuICAgICAgICAgIGAmIFtkYXRhLXNjb3BlPVwiJHt0b0tlYmFiQ2FzZShuYW1lKX1cIl1bZGF0YS1wYXJ0PVwiJHt0b0tlYmFiQ2FzZShwYXJ0KX1cIl1gXG4gICAgICAgIF0uam9pbihcIiwgXCIpLFxuICAgICAgICBhdHRyczogeyBcImRhdGEtc2NvcGVcIjogdG9LZWJhYkNhc2UobmFtZSksIFwiZGF0YS1wYXJ0XCI6IHRvS2ViYWJDYXNlKHBhcnQpIH1cbiAgICAgIH1cbiAgICB9KSxcbiAgICB7fVxuICApXG59KTtcbnZhciB0b0tlYmFiQ2FzZSA9ICh2YWx1ZSkgPT4gdmFsdWUucmVwbGFjZSgvKFtBLVpdKShbQS1aXSkvZywgXCIkMS0kMlwiKS5yZXBsYWNlKC8oW2Etel0pKFtBLVpdKS9nLCBcIiQxLSQyXCIpLnJlcGxhY2UoL1tcXHNfXSsvZywgXCItXCIpLnRvTG93ZXJDYXNlKCk7XG52YXIgaXNFbXB0eSA9ICh2KSA9PiB2Lmxlbmd0aCA9PT0gMDtcbmV4cG9ydCB7XG4gIGNyZWF0ZUFuYXRvbXlcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@zag-js/anatomy/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@zag-js/collapsible/dist/index.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/@zag-js/collapsible/dist/index.mjs ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   anatomy: () => (/* binding */ anatomy),\n/* harmony export */   connect: () => (/* binding */ connect),\n/* harmony export */   machine: () => (/* binding */ machine),\n/* harmony export */   props: () => (/* binding */ props),\n/* harmony export */   splitProps: () => (/* binding */ splitProps)\n/* harmony export */ });\n/* harmony import */ var _zag_js_anatomy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @zag-js/anatomy */ \"(ssr)/./node_modules/@zag-js/anatomy/dist/index.mjs\");\n/* harmony import */ var _zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @zag-js/dom-query */ \"(ssr)/./node_modules/@zag-js/dom-query/dist/index.mjs\");\n/* harmony import */ var _zag_js_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @zag-js/core */ \"(ssr)/./node_modules/@zag-js/core/dist/index.mjs\");\n/* harmony import */ var _zag_js_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @zag-js/core */ \"(ssr)/./node_modules/@zag-js/store/dist/index.mjs\");\n/* harmony import */ var _zag_js_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @zag-js/utils */ \"(ssr)/./node_modules/@zag-js/utils/dist/index.mjs\");\n/* harmony import */ var _zag_js_types__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @zag-js/types */ \"(ssr)/./node_modules/@zag-js/types/dist/index.mjs\");\n// src/collapsible.anatomy.ts\n\nvar anatomy = (0,_zag_js_anatomy__WEBPACK_IMPORTED_MODULE_0__.createAnatomy)(\"collapsible\").parts(\"root\", \"trigger\", \"content\");\nvar parts = anatomy.build();\n\n// src/collapsible.connect.ts\n\n\n// src/collapsible.dom.ts\n\nvar dom = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.createScope)({\n  getRootId: (ctx) => ctx.ids?.root ?? `collapsible:${ctx.id}`,\n  getContentId: (ctx) => ctx.ids?.content ?? `collapsible:${ctx.id}:content`,\n  getTriggerId: (ctx) => ctx.ids?.trigger ?? `collapsible:${ctx.id}:trigger`,\n  getRootEl: (ctx) => dom.getById(ctx, dom.getRootId(ctx)),\n  getContentEl: (ctx) => dom.getById(ctx, dom.getContentId(ctx)),\n  getTriggerEl: (ctx) => dom.getById(ctx, dom.getTriggerId(ctx))\n});\n\n// src/collapsible.connect.ts\nfunction connect(state, send, normalize) {\n  const visible = state.matches(\"open\", \"closing\");\n  const open = state.matches(\"open\");\n  const height = state.context.height;\n  const width = state.context.width;\n  const disabled = !!state.context.disabled;\n  const skip = !state.context.initial && open;\n  return {\n    disabled,\n    visible,\n    open,\n    setOpen(nextOpen) {\n      if (nextOpen === open) return;\n      send(nextOpen ? \"OPEN\" : \"CLOSE\");\n    },\n    getRootProps() {\n      return normalize.element({\n        ...parts.root.attrs,\n        \"data-state\": open ? \"open\" : \"closed\",\n        dir: state.context.dir,\n        id: dom.getRootId(state.context)\n      });\n    },\n    getContentProps() {\n      return normalize.element({\n        ...parts.content.attrs,\n        \"data-state\": skip ? void 0 : open ? \"open\" : \"closed\",\n        id: dom.getContentId(state.context),\n        \"data-disabled\": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(disabled),\n        hidden: !visible,\n        style: {\n          \"--height\": height != null ? `${height}px` : void 0,\n          \"--width\": width != null ? `${width}px` : void 0\n        }\n      });\n    },\n    getTriggerProps() {\n      return normalize.element({\n        ...parts.trigger.attrs,\n        id: dom.getTriggerId(state.context),\n        dir: state.context.dir,\n        type: \"button\",\n        \"data-state\": open ? \"open\" : \"closed\",\n        \"data-disabled\": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(disabled),\n        \"aria-controls\": dom.getContentId(state.context),\n        \"aria-expanded\": visible || false,\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          if (disabled) return;\n          send({ type: open ? \"CLOSE\" : \"OPEN\", src: \"trigger.click\" });\n        }\n      });\n    }\n  };\n}\n\n// src/collapsible.machine.ts\n\n\n\nfunction machine(userContext) {\n  const ctx = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.compact)(userContext);\n  return (0,_zag_js_core__WEBPACK_IMPORTED_MODULE_3__.createMachine)(\n    {\n      id: \"collapsible\",\n      initial: ctx.open ? \"open\" : \"closed\",\n      context: {\n        ...ctx,\n        height: 0,\n        width: 0,\n        initial: false,\n        stylesRef: null,\n        unmountAnimationName: null\n      },\n      watch: {\n        open: [\"setInitial\", \"computeSize\", \"toggleVisibility\"]\n      },\n      exit: [\"clearInitial\"],\n      states: {\n        closed: {\n          tags: [\"closed\"],\n          on: {\n            \"CONTROLLED.OPEN\": \"open\",\n            OPEN: [\n              {\n                guard: \"isOpenControlled\",\n                actions: [\"invokeOnOpen\"]\n              },\n              {\n                target: \"open\",\n                actions: [\"setInitial\", \"computeSize\", \"invokeOnOpen\"]\n              }\n            ]\n          }\n        },\n        closing: {\n          tags: [\"open\"],\n          activities: [\"trackAnimationEvents\"],\n          on: {\n            \"CONTROLLED.CLOSE\": \"closed\",\n            \"CONTROLLED.OPEN\": \"open\",\n            OPEN: [\n              {\n                guard: \"isOpenControlled\",\n                actions: [\"invokeOnOpen\"]\n              },\n              {\n                target: \"open\",\n                actions: [\"setInitial\", \"invokeOnOpen\"]\n              }\n            ],\n            CLOSE: [\n              {\n                guard: \"isOpenControlled\",\n                actions: [\"invokeOnExitComplete\"]\n              },\n              {\n                target: \"closed\",\n                actions: [\"setInitial\", \"computeSize\", \"invokeOnExitComplete\"]\n              }\n            ],\n            \"ANIMATION.END\": {\n              target: \"closed\",\n              actions: [\"invokeOnExitComplete\"]\n            }\n          }\n        },\n        open: {\n          tags: [\"open\"],\n          on: {\n            \"CONTROLLED.CLOSE\": \"closing\",\n            CLOSE: [\n              {\n                guard: \"isOpenControlled\",\n                actions: [\"invokeOnClose\"]\n              },\n              {\n                target: \"closing\",\n                actions: [\"setInitial\", \"computeSize\", \"invokeOnClose\"]\n              }\n            ]\n          }\n        }\n      }\n    },\n    {\n      guards: {\n        isOpenControlled: (ctx2) => !!ctx2[\"open.controlled\"]\n      },\n      activities: {\n        trackAnimationEvents(ctx2, _evt, { send }) {\n          let cleanup;\n          const rafCleanup = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.raf)(() => {\n            const contentEl = dom.getContentEl(ctx2);\n            if (!contentEl) return;\n            const animationName = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(contentEl).animationName;\n            const hasNoAnimation = !animationName || animationName === \"none\";\n            if (hasNoAnimation) {\n              send({ type: \"ANIMATION.END\" });\n              return;\n            }\n            const onEnd = (event) => {\n              const win = contentEl.ownerDocument.defaultView || window;\n              const animationName2 = win.getComputedStyle(contentEl).animationName;\n              if (event.target === contentEl && animationName2 === ctx2.unmountAnimationName) {\n                send({ type: \"ANIMATION.END\" });\n              }\n            };\n            contentEl.addEventListener(\"animationend\", onEnd);\n            cleanup = () => {\n              contentEl.removeEventListener(\"animationend\", onEnd);\n            };\n          });\n          return () => {\n            rafCleanup();\n            cleanup?.();\n          };\n        }\n      },\n      actions: {\n        setInitial(ctx2) {\n          ctx2.initial = true;\n        },\n        clearInitial(ctx2) {\n          ctx2.initial = false;\n        },\n        computeSize(ctx2, evt) {\n          ctx2._rafCleanup?.();\n          ctx2._rafCleanup = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.raf)(() => {\n            const contentEl = dom.getContentEl(ctx2);\n            if (!contentEl) return;\n            ctx2.stylesRef || (ctx2.stylesRef = (0,_zag_js_core__WEBPACK_IMPORTED_MODULE_4__.ref)({\n              animationName: contentEl.style.animationName,\n              animationDuration: contentEl.style.animationDuration\n            }));\n            if (evt.type === \"CLOSE\" || !ctx2.open) {\n              const win = contentEl.ownerDocument.defaultView || window;\n              ctx2.unmountAnimationName = win.getComputedStyle(contentEl).animationName;\n            }\n            const hidden = contentEl.hidden;\n            contentEl.style.animationName = \"none\";\n            contentEl.style.animationDuration = \"0s\";\n            contentEl.hidden = false;\n            const rect = contentEl.getBoundingClientRect();\n            ctx2.height = rect.height;\n            ctx2.width = rect.width;\n            if (ctx2.initial) {\n              contentEl.style.animationName = ctx2.stylesRef.animationName;\n              contentEl.style.animationDuration = ctx2.stylesRef.animationDuration;\n            }\n            contentEl.hidden = hidden;\n          });\n        },\n        invokeOnOpen: (ctx2) => {\n          ctx2.onOpenChange?.({ open: true });\n        },\n        invokeOnClose: (ctx2) => {\n          ctx2.onOpenChange?.({ open: false });\n        },\n        invokeOnExitComplete(ctx2) {\n          ctx2.onExitComplete?.();\n        },\n        toggleVisibility: (ctx2, _evt, { send }) => {\n          send({ type: ctx2.open ? \"CONTROLLED.OPEN\" : \"CONTROLLED.CLOSE\" });\n        }\n      }\n    }\n  );\n}\n\n// src/collapsible.props.ts\n\n\nvar props = (0,_zag_js_types__WEBPACK_IMPORTED_MODULE_5__.createProps)()([\n  \"dir\",\n  \"disabled\",\n  \"getRootNode\",\n  \"id\",\n  \"ids\",\n  \"onExitComplete\",\n  \"onOpenChange\",\n  \"open.controlled\",\n  \"open\"\n]);\nvar splitProps = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_2__.createSplitProps)(props);\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHphZy1qcy9jb2xsYXBzaWJsZS9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ2dEO0FBQ2hELGNBQWMsOERBQWE7QUFDM0I7O0FBRUE7QUFDNkM7O0FBRTdDO0FBQ2dEO0FBQ2hELFVBQVUsOERBQVc7QUFDckIsc0RBQXNELE9BQU87QUFDN0QsNERBQTRELE9BQU87QUFDbkUsNERBQTRELE9BQU87QUFDbkU7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDJEQUFRO0FBQ2pDO0FBQ0E7QUFDQSwwQ0FBMEMsT0FBTztBQUNqRCx3Q0FBd0MsTUFBTTtBQUM5QztBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsMkRBQVE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixxREFBcUQ7QUFDdEU7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ2tEO0FBQ1E7QUFDbEI7QUFDeEM7QUFDQSxjQUFjLHNEQUFPO0FBQ3JCLFNBQVMsMkRBQWE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSwyQ0FBMkMsTUFBTTtBQUNqRDtBQUNBLDZCQUE2QixzREFBRztBQUNoQztBQUNBO0FBQ0Esa0NBQWtDLG1FQUFnQjtBQUNsRDtBQUNBO0FBQ0EscUJBQXFCLHVCQUF1QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSw2QkFBNkIsc0RBQUc7QUFDaEM7QUFDQTtBQUNBLGdEQUFnRCxpREFBRztBQUNuRDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBLGdDQUFnQyxZQUFZO0FBQzVDLFNBQVM7QUFDVDtBQUNBLGdDQUFnQyxhQUFhO0FBQzdDLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNULHlDQUF5QyxNQUFNO0FBQy9DLGlCQUFpQiwwREFBMEQ7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUM0QztBQUNLO0FBQ2pELFlBQVksMERBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsK0RBQWdCO0FBTy9CO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zaXRlcy8uL25vZGVfbW9kdWxlcy9AemFnLWpzL2NvbGxhcHNpYmxlL2Rpc3QvaW5kZXgubWpzPzc2N2UiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2NvbGxhcHNpYmxlLmFuYXRvbXkudHNcbmltcG9ydCB7IGNyZWF0ZUFuYXRvbXkgfSBmcm9tIFwiQHphZy1qcy9hbmF0b215XCI7XG52YXIgYW5hdG9teSA9IGNyZWF0ZUFuYXRvbXkoXCJjb2xsYXBzaWJsZVwiKS5wYXJ0cyhcInJvb3RcIiwgXCJ0cmlnZ2VyXCIsIFwiY29udGVudFwiKTtcbnZhciBwYXJ0cyA9IGFuYXRvbXkuYnVpbGQoKTtcblxuLy8gc3JjL2NvbGxhcHNpYmxlLmNvbm5lY3QudHNcbmltcG9ydCB7IGRhdGFBdHRyIH0gZnJvbSBcIkB6YWctanMvZG9tLXF1ZXJ5XCI7XG5cbi8vIHNyYy9jb2xsYXBzaWJsZS5kb20udHNcbmltcG9ydCB7IGNyZWF0ZVNjb3BlIH0gZnJvbSBcIkB6YWctanMvZG9tLXF1ZXJ5XCI7XG52YXIgZG9tID0gY3JlYXRlU2NvcGUoe1xuICBnZXRSb290SWQ6IChjdHgpID0+IGN0eC5pZHM/LnJvb3QgPz8gYGNvbGxhcHNpYmxlOiR7Y3R4LmlkfWAsXG4gIGdldENvbnRlbnRJZDogKGN0eCkgPT4gY3R4Lmlkcz8uY29udGVudCA/PyBgY29sbGFwc2libGU6JHtjdHguaWR9OmNvbnRlbnRgLFxuICBnZXRUcmlnZ2VySWQ6IChjdHgpID0+IGN0eC5pZHM/LnRyaWdnZXIgPz8gYGNvbGxhcHNpYmxlOiR7Y3R4LmlkfTp0cmlnZ2VyYCxcbiAgZ2V0Um9vdEVsOiAoY3R4KSA9PiBkb20uZ2V0QnlJZChjdHgsIGRvbS5nZXRSb290SWQoY3R4KSksXG4gIGdldENvbnRlbnRFbDogKGN0eCkgPT4gZG9tLmdldEJ5SWQoY3R4LCBkb20uZ2V0Q29udGVudElkKGN0eCkpLFxuICBnZXRUcmlnZ2VyRWw6IChjdHgpID0+IGRvbS5nZXRCeUlkKGN0eCwgZG9tLmdldFRyaWdnZXJJZChjdHgpKVxufSk7XG5cbi8vIHNyYy9jb2xsYXBzaWJsZS5jb25uZWN0LnRzXG5mdW5jdGlvbiBjb25uZWN0KHN0YXRlLCBzZW5kLCBub3JtYWxpemUpIHtcbiAgY29uc3QgdmlzaWJsZSA9IHN0YXRlLm1hdGNoZXMoXCJvcGVuXCIsIFwiY2xvc2luZ1wiKTtcbiAgY29uc3Qgb3BlbiA9IHN0YXRlLm1hdGNoZXMoXCJvcGVuXCIpO1xuICBjb25zdCBoZWlnaHQgPSBzdGF0ZS5jb250ZXh0LmhlaWdodDtcbiAgY29uc3Qgd2lkdGggPSBzdGF0ZS5jb250ZXh0LndpZHRoO1xuICBjb25zdCBkaXNhYmxlZCA9ICEhc3RhdGUuY29udGV4dC5kaXNhYmxlZDtcbiAgY29uc3Qgc2tpcCA9ICFzdGF0ZS5jb250ZXh0LmluaXRpYWwgJiYgb3BlbjtcbiAgcmV0dXJuIHtcbiAgICBkaXNhYmxlZCxcbiAgICB2aXNpYmxlLFxuICAgIG9wZW4sXG4gICAgc2V0T3BlbihuZXh0T3Blbikge1xuICAgICAgaWYgKG5leHRPcGVuID09PSBvcGVuKSByZXR1cm47XG4gICAgICBzZW5kKG5leHRPcGVuID8gXCJPUEVOXCIgOiBcIkNMT1NFXCIpO1xuICAgIH0sXG4gICAgZ2V0Um9vdFByb3BzKCkge1xuICAgICAgcmV0dXJuIG5vcm1hbGl6ZS5lbGVtZW50KHtcbiAgICAgICAgLi4ucGFydHMucm9vdC5hdHRycyxcbiAgICAgICAgXCJkYXRhLXN0YXRlXCI6IG9wZW4gPyBcIm9wZW5cIiA6IFwiY2xvc2VkXCIsXG4gICAgICAgIGRpcjogc3RhdGUuY29udGV4dC5kaXIsXG4gICAgICAgIGlkOiBkb20uZ2V0Um9vdElkKHN0YXRlLmNvbnRleHQpXG4gICAgICB9KTtcbiAgICB9LFxuICAgIGdldENvbnRlbnRQcm9wcygpIHtcbiAgICAgIHJldHVybiBub3JtYWxpemUuZWxlbWVudCh7XG4gICAgICAgIC4uLnBhcnRzLmNvbnRlbnQuYXR0cnMsXG4gICAgICAgIFwiZGF0YS1zdGF0ZVwiOiBza2lwID8gdm9pZCAwIDogb3BlbiA/IFwib3BlblwiIDogXCJjbG9zZWRcIixcbiAgICAgICAgaWQ6IGRvbS5nZXRDb250ZW50SWQoc3RhdGUuY29udGV4dCksXG4gICAgICAgIFwiZGF0YS1kaXNhYmxlZFwiOiBkYXRhQXR0cihkaXNhYmxlZCksXG4gICAgICAgIGhpZGRlbjogIXZpc2libGUsXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgXCItLWhlaWdodFwiOiBoZWlnaHQgIT0gbnVsbCA/IGAke2hlaWdodH1weGAgOiB2b2lkIDAsXG4gICAgICAgICAgXCItLXdpZHRoXCI6IHdpZHRoICE9IG51bGwgPyBgJHt3aWR0aH1weGAgOiB2b2lkIDBcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBnZXRUcmlnZ2VyUHJvcHMoKSB7XG4gICAgICByZXR1cm4gbm9ybWFsaXplLmVsZW1lbnQoe1xuICAgICAgICAuLi5wYXJ0cy50cmlnZ2VyLmF0dHJzLFxuICAgICAgICBpZDogZG9tLmdldFRyaWdnZXJJZChzdGF0ZS5jb250ZXh0KSxcbiAgICAgICAgZGlyOiBzdGF0ZS5jb250ZXh0LmRpcixcbiAgICAgICAgdHlwZTogXCJidXR0b25cIixcbiAgICAgICAgXCJkYXRhLXN0YXRlXCI6IG9wZW4gPyBcIm9wZW5cIiA6IFwiY2xvc2VkXCIsXG4gICAgICAgIFwiZGF0YS1kaXNhYmxlZFwiOiBkYXRhQXR0cihkaXNhYmxlZCksXG4gICAgICAgIFwiYXJpYS1jb250cm9sc1wiOiBkb20uZ2V0Q29udGVudElkKHN0YXRlLmNvbnRleHQpLFxuICAgICAgICBcImFyaWEtZXhwYW5kZWRcIjogdmlzaWJsZSB8fCBmYWxzZSxcbiAgICAgICAgb25DbGljayhldmVudCkge1xuICAgICAgICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKSByZXR1cm47XG4gICAgICAgICAgaWYgKGRpc2FibGVkKSByZXR1cm47XG4gICAgICAgICAgc2VuZCh7IHR5cGU6IG9wZW4gPyBcIkNMT1NFXCIgOiBcIk9QRU5cIiwgc3JjOiBcInRyaWdnZXIuY2xpY2tcIiB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvY29sbGFwc2libGUubWFjaGluZS50c1xuaW1wb3J0IHsgY3JlYXRlTWFjaGluZSwgcmVmIH0gZnJvbSBcIkB6YWctanMvY29yZVwiO1xuaW1wb3J0IHsgZ2V0Q29tcHV0ZWRTdHlsZSwgcmFmIH0gZnJvbSBcIkB6YWctanMvZG9tLXF1ZXJ5XCI7XG5pbXBvcnQgeyBjb21wYWN0IH0gZnJvbSBcIkB6YWctanMvdXRpbHNcIjtcbmZ1bmN0aW9uIG1hY2hpbmUodXNlckNvbnRleHQpIHtcbiAgY29uc3QgY3R4ID0gY29tcGFjdCh1c2VyQ29udGV4dCk7XG4gIHJldHVybiBjcmVhdGVNYWNoaW5lKFxuICAgIHtcbiAgICAgIGlkOiBcImNvbGxhcHNpYmxlXCIsXG4gICAgICBpbml0aWFsOiBjdHgub3BlbiA/IFwib3BlblwiIDogXCJjbG9zZWRcIixcbiAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgLi4uY3R4LFxuICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBpbml0aWFsOiBmYWxzZSxcbiAgICAgICAgc3R5bGVzUmVmOiBudWxsLFxuICAgICAgICB1bm1vdW50QW5pbWF0aW9uTmFtZTogbnVsbFxuICAgICAgfSxcbiAgICAgIHdhdGNoOiB7XG4gICAgICAgIG9wZW46IFtcInNldEluaXRpYWxcIiwgXCJjb21wdXRlU2l6ZVwiLCBcInRvZ2dsZVZpc2liaWxpdHlcIl1cbiAgICAgIH0sXG4gICAgICBleGl0OiBbXCJjbGVhckluaXRpYWxcIl0sXG4gICAgICBzdGF0ZXM6IHtcbiAgICAgICAgY2xvc2VkOiB7XG4gICAgICAgICAgdGFnczogW1wiY2xvc2VkXCJdLFxuICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICBcIkNPTlRST0xMRUQuT1BFTlwiOiBcIm9wZW5cIixcbiAgICAgICAgICAgIE9QRU46IFtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGd1YXJkOiBcImlzT3BlbkNvbnRyb2xsZWRcIixcbiAgICAgICAgICAgICAgICBhY3Rpb25zOiBbXCJpbnZva2VPbk9wZW5cIl1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRhcmdldDogXCJvcGVuXCIsXG4gICAgICAgICAgICAgICAgYWN0aW9uczogW1wic2V0SW5pdGlhbFwiLCBcImNvbXB1dGVTaXplXCIsIFwiaW52b2tlT25PcGVuXCJdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNsb3Npbmc6IHtcbiAgICAgICAgICB0YWdzOiBbXCJvcGVuXCJdLFxuICAgICAgICAgIGFjdGl2aXRpZXM6IFtcInRyYWNrQW5pbWF0aW9uRXZlbnRzXCJdLFxuICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICBcIkNPTlRST0xMRUQuQ0xPU0VcIjogXCJjbG9zZWRcIixcbiAgICAgICAgICAgIFwiQ09OVFJPTExFRC5PUEVOXCI6IFwib3BlblwiLFxuICAgICAgICAgICAgT1BFTjogW1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZ3VhcmQ6IFwiaXNPcGVuQ29udHJvbGxlZFwiLFxuICAgICAgICAgICAgICAgIGFjdGlvbnM6IFtcImludm9rZU9uT3BlblwiXVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBcIm9wZW5cIixcbiAgICAgICAgICAgICAgICBhY3Rpb25zOiBbXCJzZXRJbml0aWFsXCIsIFwiaW52b2tlT25PcGVuXCJdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBDTE9TRTogW1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZ3VhcmQ6IFwiaXNPcGVuQ29udHJvbGxlZFwiLFxuICAgICAgICAgICAgICAgIGFjdGlvbnM6IFtcImludm9rZU9uRXhpdENvbXBsZXRlXCJdXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IFwiY2xvc2VkXCIsXG4gICAgICAgICAgICAgICAgYWN0aW9uczogW1wic2V0SW5pdGlhbFwiLCBcImNvbXB1dGVTaXplXCIsIFwiaW52b2tlT25FeGl0Q29tcGxldGVcIl1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiQU5JTUFUSU9OLkVORFwiOiB7XG4gICAgICAgICAgICAgIHRhcmdldDogXCJjbG9zZWRcIixcbiAgICAgICAgICAgICAgYWN0aW9uczogW1wiaW52b2tlT25FeGl0Q29tcGxldGVcIl1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9wZW46IHtcbiAgICAgICAgICB0YWdzOiBbXCJvcGVuXCJdLFxuICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICBcIkNPTlRST0xMRUQuQ0xPU0VcIjogXCJjbG9zaW5nXCIsXG4gICAgICAgICAgICBDTE9TRTogW1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZ3VhcmQ6IFwiaXNPcGVuQ29udHJvbGxlZFwiLFxuICAgICAgICAgICAgICAgIGFjdGlvbnM6IFtcImludm9rZU9uQ2xvc2VcIl1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRhcmdldDogXCJjbG9zaW5nXCIsXG4gICAgICAgICAgICAgICAgYWN0aW9uczogW1wic2V0SW5pdGlhbFwiLCBcImNvbXB1dGVTaXplXCIsIFwiaW52b2tlT25DbG9zZVwiXVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBndWFyZHM6IHtcbiAgICAgICAgaXNPcGVuQ29udHJvbGxlZDogKGN0eDIpID0+ICEhY3R4MltcIm9wZW4uY29udHJvbGxlZFwiXVxuICAgICAgfSxcbiAgICAgIGFjdGl2aXRpZXM6IHtcbiAgICAgICAgdHJhY2tBbmltYXRpb25FdmVudHMoY3R4MiwgX2V2dCwgeyBzZW5kIH0pIHtcbiAgICAgICAgICBsZXQgY2xlYW51cDtcbiAgICAgICAgICBjb25zdCByYWZDbGVhbnVwID0gcmFmKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRFbCA9IGRvbS5nZXRDb250ZW50RWwoY3R4Mik7XG4gICAgICAgICAgICBpZiAoIWNvbnRlbnRFbCkgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgYW5pbWF0aW9uTmFtZSA9IGdldENvbXB1dGVkU3R5bGUoY29udGVudEVsKS5hbmltYXRpb25OYW1lO1xuICAgICAgICAgICAgY29uc3QgaGFzTm9BbmltYXRpb24gPSAhYW5pbWF0aW9uTmFtZSB8fCBhbmltYXRpb25OYW1lID09PSBcIm5vbmVcIjtcbiAgICAgICAgICAgIGlmIChoYXNOb0FuaW1hdGlvbikge1xuICAgICAgICAgICAgICBzZW5kKHsgdHlwZTogXCJBTklNQVRJT04uRU5EXCIgfSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG9uRW5kID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHdpbiA9IGNvbnRlbnRFbC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IHx8IHdpbmRvdztcbiAgICAgICAgICAgICAgY29uc3QgYW5pbWF0aW9uTmFtZTIgPSB3aW4uZ2V0Q29tcHV0ZWRTdHlsZShjb250ZW50RWwpLmFuaW1hdGlvbk5hbWU7XG4gICAgICAgICAgICAgIGlmIChldmVudC50YXJnZXQgPT09IGNvbnRlbnRFbCAmJiBhbmltYXRpb25OYW1lMiA9PT0gY3R4Mi51bm1vdW50QW5pbWF0aW9uTmFtZSkge1xuICAgICAgICAgICAgICAgIHNlbmQoeyB0eXBlOiBcIkFOSU1BVElPTi5FTkRcIiB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnRlbnRFbC5hZGRFdmVudExpc3RlbmVyKFwiYW5pbWF0aW9uZW5kXCIsIG9uRW5kKTtcbiAgICAgICAgICAgIGNsZWFudXAgPSAoKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnRlbnRFbC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYW5pbWF0aW9uZW5kXCIsIG9uRW5kKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHJhZkNsZWFudXAoKTtcbiAgICAgICAgICAgIGNsZWFudXA/LigpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBhY3Rpb25zOiB7XG4gICAgICAgIHNldEluaXRpYWwoY3R4Mikge1xuICAgICAgICAgIGN0eDIuaW5pdGlhbCA9IHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIGNsZWFySW5pdGlhbChjdHgyKSB7XG4gICAgICAgICAgY3R4Mi5pbml0aWFsID0gZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbXB1dGVTaXplKGN0eDIsIGV2dCkge1xuICAgICAgICAgIGN0eDIuX3JhZkNsZWFudXA/LigpO1xuICAgICAgICAgIGN0eDIuX3JhZkNsZWFudXAgPSByYWYoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29udGVudEVsID0gZG9tLmdldENvbnRlbnRFbChjdHgyKTtcbiAgICAgICAgICAgIGlmICghY29udGVudEVsKSByZXR1cm47XG4gICAgICAgICAgICBjdHgyLnN0eWxlc1JlZiB8fCAoY3R4Mi5zdHlsZXNSZWYgPSByZWYoe1xuICAgICAgICAgICAgICBhbmltYXRpb25OYW1lOiBjb250ZW50RWwuc3R5bGUuYW5pbWF0aW9uTmFtZSxcbiAgICAgICAgICAgICAgYW5pbWF0aW9uRHVyYXRpb246IGNvbnRlbnRFbC5zdHlsZS5hbmltYXRpb25EdXJhdGlvblxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgaWYgKGV2dC50eXBlID09PSBcIkNMT1NFXCIgfHwgIWN0eDIub3Blbikge1xuICAgICAgICAgICAgICBjb25zdCB3aW4gPSBjb250ZW50RWwub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyB8fCB3aW5kb3c7XG4gICAgICAgICAgICAgIGN0eDIudW5tb3VudEFuaW1hdGlvbk5hbWUgPSB3aW4uZ2V0Q29tcHV0ZWRTdHlsZShjb250ZW50RWwpLmFuaW1hdGlvbk5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoaWRkZW4gPSBjb250ZW50RWwuaGlkZGVuO1xuICAgICAgICAgICAgY29udGVudEVsLnN0eWxlLmFuaW1hdGlvbk5hbWUgPSBcIm5vbmVcIjtcbiAgICAgICAgICAgIGNvbnRlbnRFbC5zdHlsZS5hbmltYXRpb25EdXJhdGlvbiA9IFwiMHNcIjtcbiAgICAgICAgICAgIGNvbnRlbnRFbC5oaWRkZW4gPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IHJlY3QgPSBjb250ZW50RWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICBjdHgyLmhlaWdodCA9IHJlY3QuaGVpZ2h0O1xuICAgICAgICAgICAgY3R4Mi53aWR0aCA9IHJlY3Qud2lkdGg7XG4gICAgICAgICAgICBpZiAoY3R4Mi5pbml0aWFsKSB7XG4gICAgICAgICAgICAgIGNvbnRlbnRFbC5zdHlsZS5hbmltYXRpb25OYW1lID0gY3R4Mi5zdHlsZXNSZWYuYW5pbWF0aW9uTmFtZTtcbiAgICAgICAgICAgICAgY29udGVudEVsLnN0eWxlLmFuaW1hdGlvbkR1cmF0aW9uID0gY3R4Mi5zdHlsZXNSZWYuYW5pbWF0aW9uRHVyYXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250ZW50RWwuaGlkZGVuID0gaGlkZGVuO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBpbnZva2VPbk9wZW46IChjdHgyKSA9PiB7XG4gICAgICAgICAgY3R4Mi5vbk9wZW5DaGFuZ2U/Lih7IG9wZW46IHRydWUgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGludm9rZU9uQ2xvc2U6IChjdHgyKSA9PiB7XG4gICAgICAgICAgY3R4Mi5vbk9wZW5DaGFuZ2U/Lih7IG9wZW46IGZhbHNlIH0pO1xuICAgICAgICB9LFxuICAgICAgICBpbnZva2VPbkV4aXRDb21wbGV0ZShjdHgyKSB7XG4gICAgICAgICAgY3R4Mi5vbkV4aXRDb21wbGV0ZT8uKCk7XG4gICAgICAgIH0sXG4gICAgICAgIHRvZ2dsZVZpc2liaWxpdHk6IChjdHgyLCBfZXZ0LCB7IHNlbmQgfSkgPT4ge1xuICAgICAgICAgIHNlbmQoeyB0eXBlOiBjdHgyLm9wZW4gPyBcIkNPTlRST0xMRUQuT1BFTlwiIDogXCJDT05UUk9MTEVELkNMT1NFXCIgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICk7XG59XG5cbi8vIHNyYy9jb2xsYXBzaWJsZS5wcm9wcy50c1xuaW1wb3J0IHsgY3JlYXRlUHJvcHMgfSBmcm9tIFwiQHphZy1qcy90eXBlc1wiO1xuaW1wb3J0IHsgY3JlYXRlU3BsaXRQcm9wcyB9IGZyb20gXCJAemFnLWpzL3V0aWxzXCI7XG52YXIgcHJvcHMgPSBjcmVhdGVQcm9wcygpKFtcbiAgXCJkaXJcIixcbiAgXCJkaXNhYmxlZFwiLFxuICBcImdldFJvb3ROb2RlXCIsXG4gIFwiaWRcIixcbiAgXCJpZHNcIixcbiAgXCJvbkV4aXRDb21wbGV0ZVwiLFxuICBcIm9uT3BlbkNoYW5nZVwiLFxuICBcIm9wZW4uY29udHJvbGxlZFwiLFxuICBcIm9wZW5cIlxuXSk7XG52YXIgc3BsaXRQcm9wcyA9IGNyZWF0ZVNwbGl0UHJvcHMocHJvcHMpO1xuZXhwb3J0IHtcbiAgYW5hdG9teSxcbiAgY29ubmVjdCxcbiAgbWFjaGluZSxcbiAgcHJvcHMsXG4gIHNwbGl0UHJvcHNcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@zag-js/collapsible/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@zag-js/core/dist/index.mjs":
/*!**************************************************!*\
  !*** ./node_modules/@zag-js/core/dist/index.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Machine: () => (/* binding */ Machine),\n/* harmony export */   choose: () => (/* binding */ choose),\n/* harmony export */   createMachine: () => (/* binding */ createMachine),\n/* harmony export */   deepMerge: () => (/* binding */ deepMerge),\n/* harmony export */   guards: () => (/* binding */ guards),\n/* harmony export */   isMachine: () => (/* binding */ isMachine),\n/* harmony export */   mergeProps: () => (/* binding */ mergeProps),\n/* harmony export */   proxy: () => (/* reexport safe */ _zag_js_store__WEBPACK_IMPORTED_MODULE_1__.proxy),\n/* harmony export */   ref: () => (/* reexport safe */ _zag_js_store__WEBPACK_IMPORTED_MODULE_1__.ref),\n/* harmony export */   snapshot: () => (/* reexport safe */ _zag_js_store__WEBPACK_IMPORTED_MODULE_1__.snapshot),\n/* harmony export */   subscribe: () => (/* reexport safe */ _zag_js_store__WEBPACK_IMPORTED_MODULE_1__.subscribe)\n/* harmony export */ });\n/* harmony import */ var _zag_js_store__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @zag-js/store */ \"(ssr)/./node_modules/@zag-js/store/dist/index.mjs\");\n/* harmony import */ var klona_full__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! klona/full */ \"(ssr)/./node_modules/klona/full/index.mjs\");\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n\n// src/index.ts\n\n\n// ../utilities/core/src/array.ts\nfunction clear(v) {\n  while (v.length > 0) v.pop();\n  return v;\n}\n\n// ../utilities/core/src/functions.ts\nvar runIfFn = (v, ...a) => {\n  const res = typeof v === \"function\" ? v(...a) : v;\n  return res ?? void 0;\n};\nvar cast = (v) => v;\nvar noop = () => {\n};\nvar callAll = (...fns) => (...a) => {\n  fns.forEach(function(fn) {\n    fn?.(...a);\n  });\n};\nvar uuid = /* @__PURE__ */ (() => {\n  let id = 0;\n  return () => {\n    id++;\n    return id.toString(36);\n  };\n})();\n\n// ../utilities/core/src/guard.ts\nvar isDev = () => \"development\" !== \"production\";\nvar isArray = (v) => Array.isArray(v);\nvar isObject = (v) => !(v == null || typeof v !== \"object\" || isArray(v));\nvar isNumber = (v) => typeof v === \"number\" && !Number.isNaN(v);\nvar isString = (v) => typeof v === \"string\";\nvar isFunction = (v) => typeof v === \"function\";\nvar hasProp = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\n\n// ../utilities/core/src/object.ts\nfunction compact(obj) {\n  if (!isPlainObject(obj) || obj === void 0) {\n    return obj;\n  }\n  const keys = Reflect.ownKeys(obj).filter((key) => typeof key === \"string\");\n  const filtered = {};\n  for (const key of keys) {\n    const value = obj[key];\n    if (value !== void 0) {\n      filtered[key] = compact(value);\n    }\n  }\n  return filtered;\n}\nvar isPlainObject = (value) => {\n  return value && typeof value === \"object\" && value.constructor === Object;\n};\n\n// ../utilities/core/src/warning.ts\nfunction warn(...a) {\n  const m = a.length === 1 ? a[0] : a[1];\n  const c = a.length === 2 ? a[0] : true;\n  if (c && \"development\" !== \"production\") {\n    console.warn(m);\n  }\n}\nfunction invariant(...a) {\n  const m = a.length === 1 ? a[0] : a[1];\n  const c = a.length === 2 ? a[0] : true;\n  if (c && \"development\" !== \"production\") {\n    throw new Error(m);\n  }\n}\n\n// src/deep-merge.ts\nfunction deepMerge(source, ...objects) {\n  for (const obj of objects) {\n    const target = compact(obj);\n    for (const key in target) {\n      if (isObject(obj[key])) {\n        if (!source[key]) {\n          source[key] = {};\n        }\n        deepMerge(source[key], obj[key]);\n      } else {\n        source[key] = obj[key];\n      }\n    }\n  }\n  return source;\n}\n\n// src/utils.ts\n\nfunction structuredClone(v) {\n  return (0,klona_full__WEBPACK_IMPORTED_MODULE_0__.klona)(v);\n}\nfunction toEvent(event) {\n  const obj = isString(event) ? { type: event } : event;\n  return obj;\n}\nfunction toArray(value) {\n  if (!value) return [];\n  return isArray(value) ? value.slice() : [value];\n}\nfunction isGuardHelper(value) {\n  return isObject(value) && value.predicate != null;\n}\n\n// src/guard-utils.ts\nvar Truthy = () => true;\nfunction exec(guardMap, ctx, event, meta) {\n  return (guard) => {\n    if (isString(guard)) {\n      return !!guardMap[guard]?.(ctx, event, meta);\n    }\n    if (isFunction(guard)) {\n      return guard(ctx, event, meta);\n    }\n    return guard.predicate(guardMap)(ctx, event, meta);\n  };\n}\nfunction or(...conditions) {\n  return {\n    predicate: (guardMap) => (ctx, event, meta) => conditions.map(exec(guardMap, ctx, event, meta)).some(Boolean)\n  };\n}\nfunction and(...conditions) {\n  return {\n    predicate: (guardMap) => (ctx, event, meta) => conditions.map(exec(guardMap, ctx, event, meta)).every(Boolean)\n  };\n}\nfunction not(condition) {\n  return {\n    predicate: (guardMap) => (ctx, event, meta) => {\n      return !exec(guardMap, ctx, event, meta)(condition);\n    }\n  };\n}\nfunction stateIn(...values) {\n  return (_ctx, _evt, meta) => meta.state.matches(...values);\n}\nvar guards = { or, and, not, stateIn };\nfunction choose(actions) {\n  return {\n    predicate: (guardMap) => (ctx, event, meta) => actions.find((def) => {\n      const guard = def.guard ?? Truthy;\n      return exec(guardMap, ctx, event, meta)(guard);\n    })?.actions\n  };\n}\nfunction determineGuardFn(guard, guardMap) {\n  guard = guard ?? Truthy;\n  return (context, event, meta) => {\n    if (isString(guard)) {\n      const value = guardMap[guard];\n      return isFunction(value) ? value(context, event, meta) : value;\n    }\n    if (isGuardHelper(guard)) {\n      return guard.predicate(guardMap)(context, event, meta);\n    }\n    return guard?.(context, event, meta);\n  };\n}\nfunction determineActionsFn(values, guardMap) {\n  return (context, event, meta) => {\n    if (isGuardHelper(values)) {\n      return values.predicate(guardMap)(context, event, meta);\n    }\n    return values;\n  };\n}\n\n// src/machine.ts\n\n\n// src/create-proxy.ts\n\nfunction createProxy(config) {\n  const computedContext = config.computed ?? cast({});\n  const initialContext = config.context ?? cast({});\n  const initialTags = config.initial ? config.states?.[config.initial]?.tags : [];\n  const state = (0,_zag_js_store__WEBPACK_IMPORTED_MODULE_1__.proxy)({\n    value: config.initial ?? \"\",\n    previousValue: \"\",\n    event: cast({}),\n    previousEvent: cast({}),\n    context: (0,_zag_js_store__WEBPACK_IMPORTED_MODULE_1__.proxyWithComputed)(initialContext, computedContext),\n    done: false,\n    tags: initialTags ?? [],\n    hasTag(tag) {\n      return this.tags.includes(tag);\n    },\n    matches(...value) {\n      return value.includes(this.value);\n    },\n    can(event) {\n      return cast(this).nextEvents.includes(event);\n    },\n    get nextEvents() {\n      const stateEvents = config.states?.[this.value]?.[\"on\"] ?? {};\n      const globalEvents = config?.on ?? {};\n      return Object.keys({ ...stateEvents, ...globalEvents });\n    },\n    get changed() {\n      if (this.event.value === \"machine.init\" /* Init */ || !this.previousValue) return false;\n      return this.value !== this.previousValue;\n    }\n  });\n  return cast(state);\n}\n\n// src/delay-utils.ts\nfunction determineDelayFn(delay, delaysMap) {\n  return (context, event) => {\n    if (isNumber(delay)) return delay;\n    if (isFunction(delay)) {\n      return delay(context, event);\n    }\n    if (isString(delay)) {\n      const value = Number.parseFloat(delay);\n      if (!Number.isNaN(value)) {\n        return value;\n      }\n      if (delaysMap) {\n        const valueOrFn = delaysMap?.[delay];\n        invariant(\n          valueOrFn == null,\n          `[@zag-js/core > determine-delay] Cannot determine delay for \\`${delay}\\`. It doesn't exist in \\`options.delays\\``\n        );\n        return isFunction(valueOrFn) ? valueOrFn(context, event) : valueOrFn;\n      }\n    }\n  };\n}\n\n// src/transition-utils.ts\nfunction toTarget(target) {\n  return isString(target) ? { target } : target;\n}\nfunction determineTransitionFn(transitions, guardMap) {\n  return (context, event, meta) => {\n    return toArray(transitions).map(toTarget).find((transition) => {\n      const determineGuard = determineGuardFn(transition.guard, guardMap);\n      const guard = determineGuard(context, event, meta);\n      return guard ?? transition.target ?? transition.actions;\n    });\n  };\n}\n\n// src/machine.ts\nvar Machine = class {\n  // Let's get started!\n  constructor(config, options) {\n    __publicField(this, \"status\", \"Not Started\" /* NotStarted */);\n    __publicField(this, \"state\");\n    __publicField(this, \"initialState\");\n    __publicField(this, \"initialContext\");\n    __publicField(this, \"id\");\n    __publicField(this, \"type\", \"machine\" /* Machine */);\n    // Cleanup function map (per state)\n    __publicField(this, \"activityEvents\", /* @__PURE__ */ new Map());\n    __publicField(this, \"delayedEvents\", /* @__PURE__ */ new Map());\n    // state update listeners the user can opt-in for\n    __publicField(this, \"stateListeners\", /* @__PURE__ */ new Set());\n    __publicField(this, \"doneListeners\", /* @__PURE__ */ new Set());\n    __publicField(this, \"contextWatchers\", /* @__PURE__ */ new Set());\n    // Cleanup functions (for `subscribe`)\n    __publicField(this, \"removeStateListener\", noop);\n    // For Parent <==> Spawned Actor relationship\n    __publicField(this, \"parent\");\n    __publicField(this, \"children\", /* @__PURE__ */ new Map());\n    // A map of guard, action, delay implementations\n    __publicField(this, \"guardMap\");\n    __publicField(this, \"actionMap\");\n    __publicField(this, \"delayMap\");\n    __publicField(this, \"activityMap\");\n    __publicField(this, \"sync\");\n    __publicField(this, \"options\");\n    __publicField(this, \"config\");\n    __publicField(this, \"_created\", () => {\n      const event = toEvent(\"machine.created\" /* Created */);\n      this.executeActions(this.config?.created, event);\n    });\n    // Starts the interpreted machine.\n    __publicField(this, \"start\", (init) => {\n      this.state.value = \"\";\n      this.state.tags = [];\n      if (this.status === \"Running\" /* Running */) {\n        return this;\n      }\n      this.status = \"Running\" /* Running */;\n      this.removeStateListener = (0,_zag_js_store__WEBPACK_IMPORTED_MODULE_1__.subscribe)(\n        this.state,\n        () => {\n          this.stateListeners.forEach((listener) => {\n            listener(this.stateSnapshot);\n          });\n        },\n        this.sync\n      );\n      this.setupContextWatchers();\n      this.executeActivities(toEvent(\"machine.start\" /* Start */), toArray(this.config.activities), \"machine.start\" /* Start */);\n      this.executeActions(this.config.entry, toEvent(\"machine.start\" /* Start */));\n      const event = toEvent(\"machine.init\" /* Init */);\n      const target = isObject(init) ? init.value : init;\n      const context = isObject(init) ? init.context : void 0;\n      if (context) {\n        this.setContext(context);\n      }\n      const transition = {\n        target: target ?? this.config.initial\n      };\n      const next = this.getNextStateInfo(transition, event);\n      this.initialState = next;\n      this.performStateChangeEffects(this.state.value, next, event);\n      return this;\n    });\n    __publicField(this, \"setupContextWatchers\", () => {\n      const { watch } = this.config;\n      if (!watch) return;\n      let prev = (0,_zag_js_store__WEBPACK_IMPORTED_MODULE_1__.snapshot)(this.state.context);\n      const cleanup = (0,_zag_js_store__WEBPACK_IMPORTED_MODULE_1__.subscribe)(this.state.context, () => {\n        const next = (0,_zag_js_store__WEBPACK_IMPORTED_MODULE_1__.snapshot)(this.state.context);\n        for (const [key, fn] of Object.entries(watch)) {\n          const isEqual = this.options.compareFns?.[key] ?? Object.is;\n          if (isEqual(prev[key], next[key])) continue;\n          this.executeActions(fn, this.state.event);\n        }\n        prev = next;\n      });\n      this.contextWatchers.add(cleanup);\n    });\n    // Stops the interpreted machine\n    __publicField(this, \"stop\", () => {\n      if (this.status === \"Stopped\" /* Stopped */) return;\n      this.performExitEffects(this.state.value, toEvent(\"machine.stop\" /* Stop */));\n      this.executeActions(this.config.exit, toEvent(\"machine.stop\" /* Stop */));\n      this.setState(\"\");\n      this.setEvent(\"machine.stop\" /* Stop */);\n      this.stopStateListeners();\n      this.stopChildren();\n      this.stopActivities();\n      this.stopDelayedEvents();\n      this.stopContextWatchers();\n      this.status = \"Stopped\" /* Stopped */;\n      return this;\n    });\n    __publicField(this, \"stopStateListeners\", () => {\n      this.removeStateListener();\n      this.stateListeners.clear();\n    });\n    __publicField(this, \"stopContextWatchers\", () => {\n      this.contextWatchers.forEach((fn) => fn());\n      this.contextWatchers.clear();\n    });\n    __publicField(this, \"stopDelayedEvents\", () => {\n      this.delayedEvents.forEach((state) => {\n        state.forEach((stop) => stop());\n      });\n      this.delayedEvents.clear();\n    });\n    // Cleanup running activities (e.g `setInterval`, invoked callbacks, promises)\n    __publicField(this, \"stopActivities\", (state) => {\n      if (state) {\n        this.activityEvents.get(state)?.forEach((stop) => stop());\n        this.activityEvents.get(state)?.clear();\n        this.activityEvents.delete(state);\n      } else {\n        this.activityEvents.forEach((state2) => {\n          state2.forEach((stop) => stop());\n          state2.clear();\n        });\n        this.activityEvents.clear();\n      }\n    });\n    /**\n     * Function to send event to spawned child machine or actor\n     */\n    __publicField(this, \"sendChild\", (evt, to) => {\n      const event = toEvent(evt);\n      const id = runIfFn(to, this.contextSnapshot);\n      const child = this.children.get(id);\n      if (!child) {\n        invariant(`[@zag-js/core] Cannot send '${event.type}' event to unknown child`);\n      }\n      child.send(event);\n    });\n    /**\n     * Function to stop a running child machine or actor\n     */\n    __publicField(this, \"stopChild\", (id) => {\n      if (!this.children.has(id)) {\n        invariant(`[@zag-js/core > stop-child] Cannot stop unknown child ${id}`);\n      }\n      this.children.get(id).stop();\n      this.children.delete(id);\n    });\n    __publicField(this, \"removeChild\", (id) => {\n      this.children.delete(id);\n    });\n    // Stop and delete spawned actors\n    __publicField(this, \"stopChildren\", () => {\n      this.children.forEach((child) => child.stop());\n      this.children.clear();\n    });\n    __publicField(this, \"setParent\", (parent) => {\n      this.parent = parent;\n    });\n    __publicField(this, \"spawn\", (src, id) => {\n      const actor = runIfFn(src);\n      if (id) actor.id = id;\n      actor.type = \"machine.actor\" /* Actor */;\n      actor.setParent(this);\n      this.children.set(actor.id, cast(actor));\n      actor.onDone(() => {\n        this.removeChild(actor.id);\n      }).start();\n      return cast((0,_zag_js_store__WEBPACK_IMPORTED_MODULE_1__.ref)(actor));\n    });\n    __publicField(this, \"stopActivity\", (key) => {\n      if (!this.state.value) return;\n      const cleanups = this.activityEvents.get(this.state.value);\n      cleanups?.get(key)?.();\n      cleanups?.delete(key);\n    });\n    __publicField(this, \"addActivityCleanup\", (state, key, cleanup) => {\n      if (!state) return;\n      if (!this.activityEvents.has(state)) {\n        this.activityEvents.set(state, /* @__PURE__ */ new Map([[key, cleanup]]));\n      } else {\n        this.activityEvents.get(state)?.set(key, cleanup);\n      }\n    });\n    __publicField(this, \"setState\", (target) => {\n      this.state.previousValue = this.state.value;\n      this.state.value = target;\n      const stateNode = this.getStateNode(target);\n      if (target == null) {\n        clear(this.state.tags);\n      } else {\n        this.state.tags = toArray(stateNode?.tags);\n      }\n    });\n    /**\n     * To used within side effects for React or Vue to update context\n     */\n    __publicField(this, \"setContext\", (context) => {\n      if (!context) return;\n      deepMerge(this.state.context, compact(context));\n    });\n    __publicField(this, \"setOptions\", (options) => {\n      const opts = compact(options);\n      this.actionMap = { ...this.actionMap, ...opts.actions };\n      this.delayMap = { ...this.delayMap, ...opts.delays };\n      this.activityMap = { ...this.activityMap, ...opts.activities };\n      this.guardMap = { ...this.guardMap, ...opts.guards };\n    });\n    __publicField(this, \"getStateNode\", (state) => {\n      if (!state) return;\n      return this.config.states?.[state];\n    });\n    __publicField(this, \"getNextStateInfo\", (transitions, event) => {\n      const transition = this.determineTransition(transitions, event);\n      const isTargetless = !transition?.target;\n      const target = transition?.target ?? this.state.value;\n      const changed = this.state.value !== target;\n      const stateNode = this.getStateNode(target);\n      const reenter = !isTargetless && !changed && !transition?.internal;\n      const info = {\n        reenter,\n        transition,\n        stateNode,\n        target,\n        changed\n      };\n      this.log(\"NextState:\", `[${event.type}]`, this.state.value, \"---->\", info.target);\n      return info;\n    });\n    __publicField(this, \"getAfterActions\", (transition, delay) => {\n      let id;\n      return {\n        entry: () => {\n          id = globalThis.setTimeout(() => {\n            const next = this.getNextStateInfo(transition, this.state.event);\n            this.performStateChangeEffects(this.state.value, next, this.state.event);\n          }, delay);\n        },\n        exit: () => {\n          globalThis.clearTimeout(id);\n        }\n      };\n    });\n    /**\n     * All `after` events leverage `setTimeout` and `clearTimeout`,\n     * we invoke the `clearTimeout` on exit and `setTimeout` on entry.\n     *\n     * To achieve this, we split the `after` defintion into `entry` and `exit`\n     *  functions and append them to the state's `entry` and `exit` actions\n     */\n    __publicField(this, \"getDelayedEventActions\", (state) => {\n      const stateNode = this.getStateNode(state);\n      const event = this.state.event;\n      if (!stateNode || !stateNode.after) return;\n      const entries = [];\n      const exits = [];\n      if (isArray(stateNode.after)) {\n        const transition = this.determineTransition(stateNode.after, event);\n        if (!transition) return;\n        if (!hasProp(transition, \"delay\")) {\n          throw new Error(`[@zag-js/core > after] Delay is required for after transition: ${JSON.stringify(transition)}`);\n        }\n        const determineDelay = determineDelayFn(transition.delay, this.delayMap);\n        const __delay = determineDelay(this.contextSnapshot, event);\n        const actions = this.getAfterActions(transition, __delay);\n        entries.push(actions.entry);\n        exits.push(actions.exit);\n        return { entries, exits };\n      }\n      if (isObject(stateNode.after)) {\n        for (const delay in stateNode.after) {\n          const transition = stateNode.after[delay];\n          const determineDelay = determineDelayFn(delay, this.delayMap);\n          const __delay = determineDelay(this.contextSnapshot, event);\n          const actions = this.getAfterActions(transition, __delay);\n          entries.push(actions.entry);\n          exits.push(actions.exit);\n        }\n      }\n      return { entries, exits };\n    });\n    /**\n     * Function to executes defined actions. It can accept actions as string\n     * (referencing `options.actions`) or actual functions.\n     */\n    __publicField(this, \"executeActions\", (actions, event) => {\n      const pickedActions = determineActionsFn(actions, this.guardMap)(this.contextSnapshot, event, this.guardMeta);\n      for (const action of toArray(pickedActions)) {\n        const fn = isString(action) ? this.actionMap?.[action] : action;\n        warn(\n          isString(action) && !fn,\n          `[@zag-js/core > execute-actions] No implementation found for action: \\`${action}\\``\n        );\n        fn?.(this.state.context, event, this.meta);\n      }\n    });\n    /**\n     * Function to execute running activities and registers\n     * their cleanup function internally (to be called later on when we exit the state)\n     */\n    __publicField(this, \"executeActivities\", (event, activities, state) => {\n      for (const activity of activities) {\n        const fn = isString(activity) ? this.activityMap?.[activity] : activity;\n        if (!fn) {\n          warn(`[@zag-js/core > execute-activity] No implementation found for activity: \\`${activity}\\``);\n          continue;\n        }\n        const cleanup = fn(this.state.context, event, this.meta);\n        if (cleanup) {\n          const key = isString(activity) ? activity : activity.name || uuid();\n          this.addActivityCleanup(state ?? this.state.value, key, cleanup);\n        }\n      }\n    });\n    /**\n     * Normalizes the `every` definition to transition. `every` can be:\n     * - An array of possible actions to run (we need to pick the first match based on guard)\n     * - An object of intervals and actions\n     */\n    __publicField(this, \"createEveryActivities\", (every, callbackfn) => {\n      if (!every) return;\n      if (isArray(every)) {\n        const picked = toArray(every).find((transition) => {\n          const delayOrFn = transition.delay;\n          const determineDelay2 = determineDelayFn(delayOrFn, this.delayMap);\n          const delay2 = determineDelay2(this.contextSnapshot, this.state.event);\n          const determineGuard = determineGuardFn(transition.guard, this.guardMap);\n          const guard = determineGuard(this.contextSnapshot, this.state.event, this.guardMeta);\n          return guard ?? delay2 != null;\n        });\n        if (!picked) return;\n        const determineDelay = determineDelayFn(picked.delay, this.delayMap);\n        const delay = determineDelay(this.contextSnapshot, this.state.event);\n        const activity = () => {\n          const id = globalThis.setInterval(() => {\n            this.executeActions(picked.actions, this.state.event);\n          }, delay);\n          return () => {\n            globalThis.clearInterval(id);\n          };\n        };\n        callbackfn(activity);\n      } else {\n        for (const interval in every) {\n          const actions = every?.[interval];\n          const determineDelay = determineDelayFn(interval, this.delayMap);\n          const delay = determineDelay(this.contextSnapshot, this.state.event);\n          const activity = () => {\n            const id = globalThis.setInterval(() => {\n              this.executeActions(actions, this.state.event);\n            }, delay);\n            return () => {\n              globalThis.clearInterval(id);\n            };\n          };\n          callbackfn(activity);\n        }\n      }\n    });\n    __publicField(this, \"setEvent\", (event) => {\n      this.state.previousEvent = this.state.event;\n      this.state.event = (0,_zag_js_store__WEBPACK_IMPORTED_MODULE_1__.ref)(toEvent(event));\n    });\n    __publicField(this, \"performExitEffects\", (current, event) => {\n      const currentState = this.state.value;\n      if (currentState === \"\") return;\n      const stateNode = current ? this.getStateNode(current) : void 0;\n      this.stopActivities(currentState);\n      const _exit = determineActionsFn(stateNode?.exit, this.guardMap)(this.contextSnapshot, event, this.guardMeta);\n      const exitActions = toArray(_exit);\n      const afterExitActions = this.delayedEvents.get(currentState);\n      if (afterExitActions) {\n        exitActions.push(...afterExitActions);\n      }\n      this.executeActions(exitActions, event);\n    });\n    __publicField(this, \"performEntryEffects\", (next, event) => {\n      const stateNode = this.getStateNode(next);\n      const activities = toArray(stateNode?.activities);\n      this.createEveryActivities(stateNode?.every, (activity) => {\n        activities.unshift(activity);\n      });\n      if (activities.length > 0) {\n        this.executeActivities(event, activities);\n      }\n      const pickedActions = determineActionsFn(stateNode?.entry, this.guardMap)(\n        this.contextSnapshot,\n        event,\n        this.guardMeta\n      );\n      const entryActions = toArray(pickedActions);\n      const afterActions = this.getDelayedEventActions(next);\n      if (stateNode?.after && afterActions) {\n        this.delayedEvents.set(next, afterActions?.exits);\n        entryActions.push(...afterActions.entries);\n      }\n      this.executeActions(entryActions, event);\n      if (stateNode?.type === \"final\") {\n        this.state.done = true;\n        this.doneListeners.forEach((listener) => {\n          listener(this.stateSnapshot);\n        });\n        this.stop();\n      }\n    });\n    __publicField(this, \"performTransitionEffects\", (transitions, event) => {\n      const transition = this.determineTransition(transitions, event);\n      this.executeActions(transition?.actions, event);\n    });\n    /**\n     * Performs all the requires side-effects or reactions when\n     * we move from state A => state B.\n     *\n     * The Effect order:\n     * Exit actions (current state) => Transition actions  => Go to state => Entry actions (next state)\n     */\n    __publicField(this, \"performStateChangeEffects\", (current, next, event) => {\n      this.setEvent(event);\n      const changed = next.changed || next.reenter;\n      if (changed) {\n        this.performExitEffects(current, event);\n      }\n      this.performTransitionEffects(next.transition, event);\n      this.setState(next.target);\n      if (changed) {\n        this.performEntryEffects(next.target, event);\n      }\n    });\n    __publicField(this, \"determineTransition\", (transition, event) => {\n      const fn = determineTransitionFn(transition, this.guardMap);\n      return fn?.(this.contextSnapshot, event, this.guardMeta);\n    });\n    /**\n     * Function to send event to parent machine from spawned child\n     */\n    __publicField(this, \"sendParent\", (evt) => {\n      if (!this.parent) {\n        invariant(\"[@zag-js/core > send-parent] Cannot send event to an unknown parent\");\n      }\n      const event = toEvent(evt);\n      this.parent?.send(event);\n    });\n    __publicField(this, \"log\", (...args) => {\n      if (isDev() && this.options.debug) {\n        console.log(...args);\n      }\n    });\n    /**\n     * Function to send an event to current machine\n     */\n    __publicField(this, \"send\", (evt) => {\n      const event = toEvent(evt);\n      this.transition(this.state.value, event);\n    });\n    __publicField(this, \"transition\", (state, evt) => {\n      const stateNode = isString(state) ? this.getStateNode(state) : state?.stateNode;\n      const event = toEvent(evt);\n      if (!stateNode && !this.config.on) {\n        const msg = this.status === \"Stopped\" /* Stopped */ ? \"[@zag-js/core > transition] Cannot transition a stopped machine\" : `[@zag-js/core > transition] State does not have a definition for \\`state\\`: ${state}, \\`event\\`: ${event.type}`;\n        warn(msg);\n        return;\n      }\n      const transitions = (\n        // @ts-expect-error - Fix this\n        stateNode?.on?.[event.type] ?? this.config.on?.[event.type]\n      );\n      const next = this.getNextStateInfo(transitions, event);\n      this.performStateChangeEffects(this.state.value, next, event);\n      return next.stateNode;\n    });\n    __publicField(this, \"subscribe\", (listener) => {\n      this.stateListeners.add(listener);\n      if (this.status === \"Running\" /* Running */) {\n        listener(this.stateSnapshot);\n      }\n      return () => {\n        this.stateListeners.delete(listener);\n      };\n    });\n    __publicField(this, \"onDone\", (listener) => {\n      this.doneListeners.add(listener);\n      return this;\n    });\n    __publicField(this, \"onTransition\", (listener) => {\n      this.stateListeners.add(listener);\n      if (this.status === \"Running\" /* Running */) {\n        listener(this.stateSnapshot);\n      }\n      return this;\n    });\n    this.config = structuredClone(config);\n    this.options = structuredClone(options ?? {});\n    this.id = this.config.id ?? `machine-${uuid()}`;\n    this.guardMap = this.options?.guards ?? {};\n    this.actionMap = this.options?.actions ?? {};\n    this.delayMap = this.options?.delays ?? {};\n    this.activityMap = this.options?.activities ?? {};\n    this.sync = this.options?.sync ?? false;\n    this.state = createProxy(this.config);\n    this.initialContext = (0,_zag_js_store__WEBPACK_IMPORTED_MODULE_1__.snapshot)(this.state.context);\n  }\n  // immutable state value\n  get stateSnapshot() {\n    return cast((0,_zag_js_store__WEBPACK_IMPORTED_MODULE_1__.snapshot)(this.state));\n  }\n  getState() {\n    return this.stateSnapshot;\n  }\n  // immutable context value\n  get contextSnapshot() {\n    return this.stateSnapshot.context;\n  }\n  /**\n   * A reference to the instance methods of the machine.\n   * Useful when spawning child machines and managing the communication between them.\n   */\n  get self() {\n    const self = this;\n    return {\n      id: this.id,\n      send: this.send.bind(this),\n      sendParent: this.sendParent.bind(this),\n      sendChild: this.sendChild.bind(this),\n      stop: this.stop.bind(this),\n      stopChild: this.stopChild.bind(this),\n      spawn: this.spawn.bind(this),\n      stopActivity: this.stopActivity.bind(this),\n      get state() {\n        return self.stateSnapshot;\n      },\n      get initialContext() {\n        return self.initialContext;\n      },\n      get initialState() {\n        return self.initialState?.target ?? \"\";\n      }\n    };\n  }\n  get meta() {\n    return {\n      state: this.stateSnapshot,\n      guards: this.guardMap,\n      send: this.send.bind(this),\n      self: this.self,\n      initialContext: this.initialContext,\n      initialState: this.initialState?.target ?? \"\",\n      getState: () => this.stateSnapshot,\n      getAction: (key) => this.actionMap[key],\n      getGuard: (key) => this.guardMap[key]\n    };\n  }\n  get guardMeta() {\n    return {\n      state: this.stateSnapshot\n    };\n  }\n  get [Symbol.toStringTag]() {\n    return \"Machine\";\n  }\n  getHydrationState() {\n    const state = this.getState();\n    return {\n      value: state.value,\n      tags: state.tags\n    };\n  }\n};\nvar createMachine = (config, options) => new Machine(config, options);\nvar isMachine = (value) => {\n  return value instanceof Machine || value?.type === \"machine\" /* Machine */;\n};\n\n// src/merge-props.ts\nvar clsx = (...args) => args.map((str) => str?.trim?.()).filter(Boolean).join(\" \");\nvar CSS_REGEX = /((?:--)?(?:\\w+-?)+)\\s*:\\s*([^;]*)/g;\nvar serialize = (style) => {\n  const res = {};\n  let match;\n  while (match = CSS_REGEX.exec(style)) {\n    res[match[1]] = match[2];\n  }\n  return res;\n};\nvar css = (a, b) => {\n  if (isString(a)) {\n    if (isString(b)) return `${a};${b}`;\n    a = serialize(a);\n  } else if (isString(b)) {\n    b = serialize(b);\n  }\n  return Object.assign({}, a ?? {}, b ?? {});\n};\nfunction mergeProps(...args) {\n  let result = {};\n  for (let props of args) {\n    for (let key in result) {\n      if (key.startsWith(\"on\") && typeof result[key] === \"function\" && typeof props[key] === \"function\") {\n        result[key] = callAll(props[key], result[key]);\n        continue;\n      }\n      if (key === \"className\" || key === \"class\") {\n        result[key] = clsx(result[key], props[key]);\n        continue;\n      }\n      if (key === \"style\") {\n        result[key] = css(result[key], props[key]);\n        continue;\n      }\n      result[key] = props[key] !== void 0 ? props[key] : result[key];\n    }\n    for (let key in props) {\n      if (result[key] === void 0) {\n        result[key] = props[key];\n      }\n    }\n  }\n  return result;\n}\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHphZy1qcy9jb3JlL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBLDhFQUE4RSw2REFBNkQ7QUFDM0k7O0FBRUE7QUFDNkc7O0FBRTdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSxrQkFBa0IsYUFBb0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBb0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFvQjtBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ21DO0FBQ25DO0FBQ0EsU0FBUyxpREFBSztBQUNkO0FBQ0E7QUFDQSxrQ0FBa0MsY0FBYztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0RBQWdEO0FBQ2hELDJDQUEyQyxPQUFPO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix1REFBUTtBQUNsQztBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdURBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsR0FBRyxFQUFFLEVBQUU7QUFDdEM7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLHlCQUF5QixTQUFTLFNBQVM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBYUU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3NpdGVzLy4vbm9kZV9tb2R1bGVzL0B6YWctanMvY29yZS9kaXN0L2luZGV4Lm1qcz9jZGI0Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19wdWJsaWNGaWVsZCA9IChvYmosIGtleSwgdmFsdWUpID0+IF9fZGVmTm9ybWFsUHJvcChvYmosIHR5cGVvZiBrZXkgIT09IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG5cbi8vIHNyYy9pbmRleC50c1xuaW1wb3J0IHsgcHJveHkgYXMgcHJveHkyLCByZWYgYXMgcmVmMiwgc25hcHNob3QgYXMgc25hcHNob3QyLCBzdWJzY3JpYmUgYXMgc3Vic2NyaWJlMiB9IGZyb20gXCJAemFnLWpzL3N0b3JlXCI7XG5cbi8vIC4uL3V0aWxpdGllcy9jb3JlL3NyYy9hcnJheS50c1xuZnVuY3Rpb24gY2xlYXIodikge1xuICB3aGlsZSAodi5sZW5ndGggPiAwKSB2LnBvcCgpO1xuICByZXR1cm4gdjtcbn1cblxuLy8gLi4vdXRpbGl0aWVzL2NvcmUvc3JjL2Z1bmN0aW9ucy50c1xudmFyIHJ1bklmRm4gPSAodiwgLi4uYSkgPT4ge1xuICBjb25zdCByZXMgPSB0eXBlb2YgdiA9PT0gXCJmdW5jdGlvblwiID8gdiguLi5hKSA6IHY7XG4gIHJldHVybiByZXMgPz8gdm9pZCAwO1xufTtcbnZhciBjYXN0ID0gKHYpID0+IHY7XG52YXIgbm9vcCA9ICgpID0+IHtcbn07XG52YXIgY2FsbEFsbCA9ICguLi5mbnMpID0+ICguLi5hKSA9PiB7XG4gIGZucy5mb3JFYWNoKGZ1bmN0aW9uKGZuKSB7XG4gICAgZm4/LiguLi5hKTtcbiAgfSk7XG59O1xudmFyIHV1aWQgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IHtcbiAgbGV0IGlkID0gMDtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBpZCsrO1xuICAgIHJldHVybiBpZC50b1N0cmluZygzNik7XG4gIH07XG59KSgpO1xuXG4vLyAuLi91dGlsaXRpZXMvY29yZS9zcmMvZ3VhcmQudHNcbnZhciBpc0RldiA9ICgpID0+IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIjtcbnZhciBpc0FycmF5ID0gKHYpID0+IEFycmF5LmlzQXJyYXkodik7XG52YXIgaXNPYmplY3QgPSAodikgPT4gISh2ID09IG51bGwgfHwgdHlwZW9mIHYgIT09IFwib2JqZWN0XCIgfHwgaXNBcnJheSh2KSk7XG52YXIgaXNOdW1iZXIgPSAodikgPT4gdHlwZW9mIHYgPT09IFwibnVtYmVyXCIgJiYgIU51bWJlci5pc05hTih2KTtcbnZhciBpc1N0cmluZyA9ICh2KSA9PiB0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIjtcbnZhciBpc0Z1bmN0aW9uID0gKHYpID0+IHR5cGVvZiB2ID09PSBcImZ1bmN0aW9uXCI7XG52YXIgaGFzUHJvcCA9IChvYmosIHByb3ApID0+IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xuXG4vLyAuLi91dGlsaXRpZXMvY29yZS9zcmMvb2JqZWN0LnRzXG5mdW5jdGlvbiBjb21wYWN0KG9iaikge1xuICBpZiAoIWlzUGxhaW5PYmplY3Qob2JqKSB8fCBvYmogPT09IHZvaWQgMCkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cbiAgY29uc3Qga2V5cyA9IFJlZmxlY3Qub3duS2V5cyhvYmopLmZpbHRlcigoa2V5KSA9PiB0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiKTtcbiAgY29uc3QgZmlsdGVyZWQgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgIGNvbnN0IHZhbHVlID0gb2JqW2tleV07XG4gICAgaWYgKHZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgIGZpbHRlcmVkW2tleV0gPSBjb21wYWN0KHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZpbHRlcmVkO1xufVxudmFyIGlzUGxhaW5PYmplY3QgPSAodmFsdWUpID0+IHtcbiAgcmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0O1xufTtcblxuLy8gLi4vdXRpbGl0aWVzL2NvcmUvc3JjL3dhcm5pbmcudHNcbmZ1bmN0aW9uIHdhcm4oLi4uYSkge1xuICBjb25zdCBtID0gYS5sZW5ndGggPT09IDEgPyBhWzBdIDogYVsxXTtcbiAgY29uc3QgYyA9IGEubGVuZ3RoID09PSAyID8gYVswXSA6IHRydWU7XG4gIGlmIChjICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGNvbnNvbGUud2FybihtKTtcbiAgfVxufVxuZnVuY3Rpb24gaW52YXJpYW50KC4uLmEpIHtcbiAgY29uc3QgbSA9IGEubGVuZ3RoID09PSAxID8gYVswXSA6IGFbMV07XG4gIGNvbnN0IGMgPSBhLmxlbmd0aCA9PT0gMiA/IGFbMF0gOiB0cnVlO1xuICBpZiAoYyAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobSk7XG4gIH1cbn1cblxuLy8gc3JjL2RlZXAtbWVyZ2UudHNcbmZ1bmN0aW9uIGRlZXBNZXJnZShzb3VyY2UsIC4uLm9iamVjdHMpIHtcbiAgZm9yIChjb25zdCBvYmogb2Ygb2JqZWN0cykge1xuICAgIGNvbnN0IHRhcmdldCA9IGNvbXBhY3Qob2JqKTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiB0YXJnZXQpIHtcbiAgICAgIGlmIChpc09iamVjdChvYmpba2V5XSkpIHtcbiAgICAgICAgaWYgKCFzb3VyY2Vba2V5XSkge1xuICAgICAgICAgIHNvdXJjZVtrZXldID0ge307XG4gICAgICAgIH1cbiAgICAgICAgZGVlcE1lcmdlKHNvdXJjZVtrZXldLCBvYmpba2V5XSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzb3VyY2Vba2V5XSA9IG9ialtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gc291cmNlO1xufVxuXG4vLyBzcmMvdXRpbHMudHNcbmltcG9ydCB7IGtsb25hIH0gZnJvbSBcImtsb25hL2Z1bGxcIjtcbmZ1bmN0aW9uIHN0cnVjdHVyZWRDbG9uZSh2KSB7XG4gIHJldHVybiBrbG9uYSh2KTtcbn1cbmZ1bmN0aW9uIHRvRXZlbnQoZXZlbnQpIHtcbiAgY29uc3Qgb2JqID0gaXNTdHJpbmcoZXZlbnQpID8geyB0eXBlOiBldmVudCB9IDogZXZlbnQ7XG4gIHJldHVybiBvYmo7XG59XG5mdW5jdGlvbiB0b0FycmF5KHZhbHVlKSB7XG4gIGlmICghdmFsdWUpIHJldHVybiBbXTtcbiAgcmV0dXJuIGlzQXJyYXkodmFsdWUpID8gdmFsdWUuc2xpY2UoKSA6IFt2YWx1ZV07XG59XG5mdW5jdGlvbiBpc0d1YXJkSGVscGVyKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdCh2YWx1ZSkgJiYgdmFsdWUucHJlZGljYXRlICE9IG51bGw7XG59XG5cbi8vIHNyYy9ndWFyZC11dGlscy50c1xudmFyIFRydXRoeSA9ICgpID0+IHRydWU7XG5mdW5jdGlvbiBleGVjKGd1YXJkTWFwLCBjdHgsIGV2ZW50LCBtZXRhKSB7XG4gIHJldHVybiAoZ3VhcmQpID0+IHtcbiAgICBpZiAoaXNTdHJpbmcoZ3VhcmQpKSB7XG4gICAgICByZXR1cm4gISFndWFyZE1hcFtndWFyZF0/LihjdHgsIGV2ZW50LCBtZXRhKTtcbiAgICB9XG4gICAgaWYgKGlzRnVuY3Rpb24oZ3VhcmQpKSB7XG4gICAgICByZXR1cm4gZ3VhcmQoY3R4LCBldmVudCwgbWV0YSk7XG4gICAgfVxuICAgIHJldHVybiBndWFyZC5wcmVkaWNhdGUoZ3VhcmRNYXApKGN0eCwgZXZlbnQsIG1ldGEpO1xuICB9O1xufVxuZnVuY3Rpb24gb3IoLi4uY29uZGl0aW9ucykge1xuICByZXR1cm4ge1xuICAgIHByZWRpY2F0ZTogKGd1YXJkTWFwKSA9PiAoY3R4LCBldmVudCwgbWV0YSkgPT4gY29uZGl0aW9ucy5tYXAoZXhlYyhndWFyZE1hcCwgY3R4LCBldmVudCwgbWV0YSkpLnNvbWUoQm9vbGVhbilcbiAgfTtcbn1cbmZ1bmN0aW9uIGFuZCguLi5jb25kaXRpb25zKSB7XG4gIHJldHVybiB7XG4gICAgcHJlZGljYXRlOiAoZ3VhcmRNYXApID0+IChjdHgsIGV2ZW50LCBtZXRhKSA9PiBjb25kaXRpb25zLm1hcChleGVjKGd1YXJkTWFwLCBjdHgsIGV2ZW50LCBtZXRhKSkuZXZlcnkoQm9vbGVhbilcbiAgfTtcbn1cbmZ1bmN0aW9uIG5vdChjb25kaXRpb24pIHtcbiAgcmV0dXJuIHtcbiAgICBwcmVkaWNhdGU6IChndWFyZE1hcCkgPT4gKGN0eCwgZXZlbnQsIG1ldGEpID0+IHtcbiAgICAgIHJldHVybiAhZXhlYyhndWFyZE1hcCwgY3R4LCBldmVudCwgbWV0YSkoY29uZGl0aW9uKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBzdGF0ZUluKC4uLnZhbHVlcykge1xuICByZXR1cm4gKF9jdHgsIF9ldnQsIG1ldGEpID0+IG1ldGEuc3RhdGUubWF0Y2hlcyguLi52YWx1ZXMpO1xufVxudmFyIGd1YXJkcyA9IHsgb3IsIGFuZCwgbm90LCBzdGF0ZUluIH07XG5mdW5jdGlvbiBjaG9vc2UoYWN0aW9ucykge1xuICByZXR1cm4ge1xuICAgIHByZWRpY2F0ZTogKGd1YXJkTWFwKSA9PiAoY3R4LCBldmVudCwgbWV0YSkgPT4gYWN0aW9ucy5maW5kKChkZWYpID0+IHtcbiAgICAgIGNvbnN0IGd1YXJkID0gZGVmLmd1YXJkID8/IFRydXRoeTtcbiAgICAgIHJldHVybiBleGVjKGd1YXJkTWFwLCBjdHgsIGV2ZW50LCBtZXRhKShndWFyZCk7XG4gICAgfSk/LmFjdGlvbnNcbiAgfTtcbn1cbmZ1bmN0aW9uIGRldGVybWluZUd1YXJkRm4oZ3VhcmQsIGd1YXJkTWFwKSB7XG4gIGd1YXJkID0gZ3VhcmQgPz8gVHJ1dGh5O1xuICByZXR1cm4gKGNvbnRleHQsIGV2ZW50LCBtZXRhKSA9PiB7XG4gICAgaWYgKGlzU3RyaW5nKGd1YXJkKSkge1xuICAgICAgY29uc3QgdmFsdWUgPSBndWFyZE1hcFtndWFyZF07XG4gICAgICByZXR1cm4gaXNGdW5jdGlvbih2YWx1ZSkgPyB2YWx1ZShjb250ZXh0LCBldmVudCwgbWV0YSkgOiB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKGlzR3VhcmRIZWxwZXIoZ3VhcmQpKSB7XG4gICAgICByZXR1cm4gZ3VhcmQucHJlZGljYXRlKGd1YXJkTWFwKShjb250ZXh0LCBldmVudCwgbWV0YSk7XG4gICAgfVxuICAgIHJldHVybiBndWFyZD8uKGNvbnRleHQsIGV2ZW50LCBtZXRhKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGRldGVybWluZUFjdGlvbnNGbih2YWx1ZXMsIGd1YXJkTWFwKSB7XG4gIHJldHVybiAoY29udGV4dCwgZXZlbnQsIG1ldGEpID0+IHtcbiAgICBpZiAoaXNHdWFyZEhlbHBlcih2YWx1ZXMpKSB7XG4gICAgICByZXR1cm4gdmFsdWVzLnByZWRpY2F0ZShndWFyZE1hcCkoY29udGV4dCwgZXZlbnQsIG1ldGEpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9O1xufVxuXG4vLyBzcmMvbWFjaGluZS50c1xuaW1wb3J0IHsgcmVmLCBzbmFwc2hvdCwgc3Vic2NyaWJlIH0gZnJvbSBcIkB6YWctanMvc3RvcmVcIjtcblxuLy8gc3JjL2NyZWF0ZS1wcm94eS50c1xuaW1wb3J0IHsgcHJveHksIHByb3h5V2l0aENvbXB1dGVkIH0gZnJvbSBcIkB6YWctanMvc3RvcmVcIjtcbmZ1bmN0aW9uIGNyZWF0ZVByb3h5KGNvbmZpZykge1xuICBjb25zdCBjb21wdXRlZENvbnRleHQgPSBjb25maWcuY29tcHV0ZWQgPz8gY2FzdCh7fSk7XG4gIGNvbnN0IGluaXRpYWxDb250ZXh0ID0gY29uZmlnLmNvbnRleHQgPz8gY2FzdCh7fSk7XG4gIGNvbnN0IGluaXRpYWxUYWdzID0gY29uZmlnLmluaXRpYWwgPyBjb25maWcuc3RhdGVzPy5bY29uZmlnLmluaXRpYWxdPy50YWdzIDogW107XG4gIGNvbnN0IHN0YXRlID0gcHJveHkoe1xuICAgIHZhbHVlOiBjb25maWcuaW5pdGlhbCA/PyBcIlwiLFxuICAgIHByZXZpb3VzVmFsdWU6IFwiXCIsXG4gICAgZXZlbnQ6IGNhc3Qoe30pLFxuICAgIHByZXZpb3VzRXZlbnQ6IGNhc3Qoe30pLFxuICAgIGNvbnRleHQ6IHByb3h5V2l0aENvbXB1dGVkKGluaXRpYWxDb250ZXh0LCBjb21wdXRlZENvbnRleHQpLFxuICAgIGRvbmU6IGZhbHNlLFxuICAgIHRhZ3M6IGluaXRpYWxUYWdzID8/IFtdLFxuICAgIGhhc1RhZyh0YWcpIHtcbiAgICAgIHJldHVybiB0aGlzLnRhZ3MuaW5jbHVkZXModGFnKTtcbiAgICB9LFxuICAgIG1hdGNoZXMoLi4udmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZS5pbmNsdWRlcyh0aGlzLnZhbHVlKTtcbiAgICB9LFxuICAgIGNhbihldmVudCkge1xuICAgICAgcmV0dXJuIGNhc3QodGhpcykubmV4dEV2ZW50cy5pbmNsdWRlcyhldmVudCk7XG4gICAgfSxcbiAgICBnZXQgbmV4dEV2ZW50cygpIHtcbiAgICAgIGNvbnN0IHN0YXRlRXZlbnRzID0gY29uZmlnLnN0YXRlcz8uW3RoaXMudmFsdWVdPy5bXCJvblwiXSA/PyB7fTtcbiAgICAgIGNvbnN0IGdsb2JhbEV2ZW50cyA9IGNvbmZpZz8ub24gPz8ge307XG4gICAgICByZXR1cm4gT2JqZWN0LmtleXMoeyAuLi5zdGF0ZUV2ZW50cywgLi4uZ2xvYmFsRXZlbnRzIH0pO1xuICAgIH0sXG4gICAgZ2V0IGNoYW5nZWQoKSB7XG4gICAgICBpZiAodGhpcy5ldmVudC52YWx1ZSA9PT0gXCJtYWNoaW5lLmluaXRcIiAvKiBJbml0ICovIHx8ICF0aGlzLnByZXZpb3VzVmFsdWUpIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlICE9PSB0aGlzLnByZXZpb3VzVmFsdWU7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGNhc3Qoc3RhdGUpO1xufVxuXG4vLyBzcmMvZGVsYXktdXRpbHMudHNcbmZ1bmN0aW9uIGRldGVybWluZURlbGF5Rm4oZGVsYXksIGRlbGF5c01hcCkge1xuICByZXR1cm4gKGNvbnRleHQsIGV2ZW50KSA9PiB7XG4gICAgaWYgKGlzTnVtYmVyKGRlbGF5KSkgcmV0dXJuIGRlbGF5O1xuICAgIGlmIChpc0Z1bmN0aW9uKGRlbGF5KSkge1xuICAgICAgcmV0dXJuIGRlbGF5KGNvbnRleHQsIGV2ZW50KTtcbiAgICB9XG4gICAgaWYgKGlzU3RyaW5nKGRlbGF5KSkge1xuICAgICAgY29uc3QgdmFsdWUgPSBOdW1iZXIucGFyc2VGbG9hdChkZWxheSk7XG4gICAgICBpZiAoIU51bWJlci5pc05hTih2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKGRlbGF5c01hcCkge1xuICAgICAgICBjb25zdCB2YWx1ZU9yRm4gPSBkZWxheXNNYXA/LltkZWxheV07XG4gICAgICAgIGludmFyaWFudChcbiAgICAgICAgICB2YWx1ZU9yRm4gPT0gbnVsbCxcbiAgICAgICAgICBgW0B6YWctanMvY29yZSA+IGRldGVybWluZS1kZWxheV0gQ2Fubm90IGRldGVybWluZSBkZWxheSBmb3IgXFxgJHtkZWxheX1cXGAuIEl0IGRvZXNuJ3QgZXhpc3QgaW4gXFxgb3B0aW9ucy5kZWxheXNcXGBgXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBpc0Z1bmN0aW9uKHZhbHVlT3JGbikgPyB2YWx1ZU9yRm4oY29udGV4dCwgZXZlbnQpIDogdmFsdWVPckZuO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3RyYW5zaXRpb24tdXRpbHMudHNcbmZ1bmN0aW9uIHRvVGFyZ2V0KHRhcmdldCkge1xuICByZXR1cm4gaXNTdHJpbmcodGFyZ2V0KSA/IHsgdGFyZ2V0IH0gOiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBkZXRlcm1pbmVUcmFuc2l0aW9uRm4odHJhbnNpdGlvbnMsIGd1YXJkTWFwKSB7XG4gIHJldHVybiAoY29udGV4dCwgZXZlbnQsIG1ldGEpID0+IHtcbiAgICByZXR1cm4gdG9BcnJheSh0cmFuc2l0aW9ucykubWFwKHRvVGFyZ2V0KS5maW5kKCh0cmFuc2l0aW9uKSA9PiB7XG4gICAgICBjb25zdCBkZXRlcm1pbmVHdWFyZCA9IGRldGVybWluZUd1YXJkRm4odHJhbnNpdGlvbi5ndWFyZCwgZ3VhcmRNYXApO1xuICAgICAgY29uc3QgZ3VhcmQgPSBkZXRlcm1pbmVHdWFyZChjb250ZXh0LCBldmVudCwgbWV0YSk7XG4gICAgICByZXR1cm4gZ3VhcmQgPz8gdHJhbnNpdGlvbi50YXJnZXQgPz8gdHJhbnNpdGlvbi5hY3Rpb25zO1xuICAgIH0pO1xuICB9O1xufVxuXG4vLyBzcmMvbWFjaGluZS50c1xudmFyIE1hY2hpbmUgPSBjbGFzcyB7XG4gIC8vIExldCdzIGdldCBzdGFydGVkIVxuICBjb25zdHJ1Y3Rvcihjb25maWcsIG9wdGlvbnMpIHtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwic3RhdHVzXCIsIFwiTm90IFN0YXJ0ZWRcIiAvKiBOb3RTdGFydGVkICovKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwic3RhdGVcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImluaXRpYWxTdGF0ZVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiaW5pdGlhbENvbnRleHRcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImlkXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ0eXBlXCIsIFwibWFjaGluZVwiIC8qIE1hY2hpbmUgKi8pO1xuICAgIC8vIENsZWFudXAgZnVuY3Rpb24gbWFwIChwZXIgc3RhdGUpXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImFjdGl2aXR5RXZlbnRzXCIsIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJkZWxheWVkRXZlbnRzXCIsIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICAgIC8vIHN0YXRlIHVwZGF0ZSBsaXN0ZW5lcnMgdGhlIHVzZXIgY2FuIG9wdC1pbiBmb3JcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwic3RhdGVMaXN0ZW5lcnNcIiwgLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImRvbmVMaXN0ZW5lcnNcIiwgLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImNvbnRleHRXYXRjaGVyc1wiLCAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKTtcbiAgICAvLyBDbGVhbnVwIGZ1bmN0aW9ucyAoZm9yIGBzdWJzY3JpYmVgKVxuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJyZW1vdmVTdGF0ZUxpc3RlbmVyXCIsIG5vb3ApO1xuICAgIC8vIEZvciBQYXJlbnQgPD09PiBTcGF3bmVkIEFjdG9yIHJlbGF0aW9uc2hpcFxuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJwYXJlbnRcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImNoaWxkcmVuXCIsIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICAgIC8vIEEgbWFwIG9mIGd1YXJkLCBhY3Rpb24sIGRlbGF5IGltcGxlbWVudGF0aW9uc1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJndWFyZE1hcFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiYWN0aW9uTWFwXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJkZWxheU1hcFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiYWN0aXZpdHlNYXBcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInN5bmNcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm9wdGlvbnNcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImNvbmZpZ1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX2NyZWF0ZWRcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgZXZlbnQgPSB0b0V2ZW50KFwibWFjaGluZS5jcmVhdGVkXCIgLyogQ3JlYXRlZCAqLyk7XG4gICAgICB0aGlzLmV4ZWN1dGVBY3Rpb25zKHRoaXMuY29uZmlnPy5jcmVhdGVkLCBldmVudCk7XG4gICAgfSk7XG4gICAgLy8gU3RhcnRzIHRoZSBpbnRlcnByZXRlZCBtYWNoaW5lLlxuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJzdGFydFwiLCAoaW5pdCkgPT4ge1xuICAgICAgdGhpcy5zdGF0ZS52YWx1ZSA9IFwiXCI7XG4gICAgICB0aGlzLnN0YXRlLnRhZ3MgPSBbXTtcbiAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gXCJSdW5uaW5nXCIgLyogUnVubmluZyAqLykge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHRoaXMuc3RhdHVzID0gXCJSdW5uaW5nXCIgLyogUnVubmluZyAqLztcbiAgICAgIHRoaXMucmVtb3ZlU3RhdGVMaXN0ZW5lciA9IHN1YnNjcmliZShcbiAgICAgICAgdGhpcy5zdGF0ZSxcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIHRoaXMuc3RhdGVMaXN0ZW5lcnMuZm9yRWFjaCgobGlzdGVuZXIpID0+IHtcbiAgICAgICAgICAgIGxpc3RlbmVyKHRoaXMuc3RhdGVTbmFwc2hvdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHRoaXMuc3luY1xuICAgICAgKTtcbiAgICAgIHRoaXMuc2V0dXBDb250ZXh0V2F0Y2hlcnMoKTtcbiAgICAgIHRoaXMuZXhlY3V0ZUFjdGl2aXRpZXModG9FdmVudChcIm1hY2hpbmUuc3RhcnRcIiAvKiBTdGFydCAqLyksIHRvQXJyYXkodGhpcy5jb25maWcuYWN0aXZpdGllcyksIFwibWFjaGluZS5zdGFydFwiIC8qIFN0YXJ0ICovKTtcbiAgICAgIHRoaXMuZXhlY3V0ZUFjdGlvbnModGhpcy5jb25maWcuZW50cnksIHRvRXZlbnQoXCJtYWNoaW5lLnN0YXJ0XCIgLyogU3RhcnQgKi8pKTtcbiAgICAgIGNvbnN0IGV2ZW50ID0gdG9FdmVudChcIm1hY2hpbmUuaW5pdFwiIC8qIEluaXQgKi8pO1xuICAgICAgY29uc3QgdGFyZ2V0ID0gaXNPYmplY3QoaW5pdCkgPyBpbml0LnZhbHVlIDogaW5pdDtcbiAgICAgIGNvbnN0IGNvbnRleHQgPSBpc09iamVjdChpbml0KSA/IGluaXQuY29udGV4dCA6IHZvaWQgMDtcbiAgICAgIGlmIChjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuc2V0Q29udGV4dChjb250ZXh0KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRyYW5zaXRpb24gPSB7XG4gICAgICAgIHRhcmdldDogdGFyZ2V0ID8/IHRoaXMuY29uZmlnLmluaXRpYWxcbiAgICAgIH07XG4gICAgICBjb25zdCBuZXh0ID0gdGhpcy5nZXROZXh0U3RhdGVJbmZvKHRyYW5zaXRpb24sIGV2ZW50KTtcbiAgICAgIHRoaXMuaW5pdGlhbFN0YXRlID0gbmV4dDtcbiAgICAgIHRoaXMucGVyZm9ybVN0YXRlQ2hhbmdlRWZmZWN0cyh0aGlzLnN0YXRlLnZhbHVlLCBuZXh0LCBldmVudCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwic2V0dXBDb250ZXh0V2F0Y2hlcnNcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgeyB3YXRjaCB9ID0gdGhpcy5jb25maWc7XG4gICAgICBpZiAoIXdhdGNoKSByZXR1cm47XG4gICAgICBsZXQgcHJldiA9IHNuYXBzaG90KHRoaXMuc3RhdGUuY29udGV4dCk7XG4gICAgICBjb25zdCBjbGVhbnVwID0gc3Vic2NyaWJlKHRoaXMuc3RhdGUuY29udGV4dCwgKCkgPT4ge1xuICAgICAgICBjb25zdCBuZXh0ID0gc25hcHNob3QodGhpcy5zdGF0ZS5jb250ZXh0KTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCBmbl0gb2YgT2JqZWN0LmVudHJpZXMod2F0Y2gpKSB7XG4gICAgICAgICAgY29uc3QgaXNFcXVhbCA9IHRoaXMub3B0aW9ucy5jb21wYXJlRm5zPy5ba2V5XSA/PyBPYmplY3QuaXM7XG4gICAgICAgICAgaWYgKGlzRXF1YWwocHJldltrZXldLCBuZXh0W2tleV0pKSBjb250aW51ZTtcbiAgICAgICAgICB0aGlzLmV4ZWN1dGVBY3Rpb25zKGZuLCB0aGlzLnN0YXRlLmV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBwcmV2ID0gbmV4dDtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5jb250ZXh0V2F0Y2hlcnMuYWRkKGNsZWFudXApO1xuICAgIH0pO1xuICAgIC8vIFN0b3BzIHRoZSBpbnRlcnByZXRlZCBtYWNoaW5lXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInN0b3BcIiwgKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSBcIlN0b3BwZWRcIiAvKiBTdG9wcGVkICovKSByZXR1cm47XG4gICAgICB0aGlzLnBlcmZvcm1FeGl0RWZmZWN0cyh0aGlzLnN0YXRlLnZhbHVlLCB0b0V2ZW50KFwibWFjaGluZS5zdG9wXCIgLyogU3RvcCAqLykpO1xuICAgICAgdGhpcy5leGVjdXRlQWN0aW9ucyh0aGlzLmNvbmZpZy5leGl0LCB0b0V2ZW50KFwibWFjaGluZS5zdG9wXCIgLyogU3RvcCAqLykpO1xuICAgICAgdGhpcy5zZXRTdGF0ZShcIlwiKTtcbiAgICAgIHRoaXMuc2V0RXZlbnQoXCJtYWNoaW5lLnN0b3BcIiAvKiBTdG9wICovKTtcbiAgICAgIHRoaXMuc3RvcFN0YXRlTGlzdGVuZXJzKCk7XG4gICAgICB0aGlzLnN0b3BDaGlsZHJlbigpO1xuICAgICAgdGhpcy5zdG9wQWN0aXZpdGllcygpO1xuICAgICAgdGhpcy5zdG9wRGVsYXllZEV2ZW50cygpO1xuICAgICAgdGhpcy5zdG9wQ29udGV4dFdhdGNoZXJzKCk7XG4gICAgICB0aGlzLnN0YXR1cyA9IFwiU3RvcHBlZFwiIC8qIFN0b3BwZWQgKi87XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwic3RvcFN0YXRlTGlzdGVuZXJzXCIsICgpID0+IHtcbiAgICAgIHRoaXMucmVtb3ZlU3RhdGVMaXN0ZW5lcigpO1xuICAgICAgdGhpcy5zdGF0ZUxpc3RlbmVycy5jbGVhcigpO1xuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJzdG9wQ29udGV4dFdhdGNoZXJzXCIsICgpID0+IHtcbiAgICAgIHRoaXMuY29udGV4dFdhdGNoZXJzLmZvckVhY2goKGZuKSA9PiBmbigpKTtcbiAgICAgIHRoaXMuY29udGV4dFdhdGNoZXJzLmNsZWFyKCk7XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInN0b3BEZWxheWVkRXZlbnRzXCIsICgpID0+IHtcbiAgICAgIHRoaXMuZGVsYXllZEV2ZW50cy5mb3JFYWNoKChzdGF0ZSkgPT4ge1xuICAgICAgICBzdGF0ZS5mb3JFYWNoKChzdG9wKSA9PiBzdG9wKCkpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmRlbGF5ZWRFdmVudHMuY2xlYXIoKTtcbiAgICB9KTtcbiAgICAvLyBDbGVhbnVwIHJ1bm5pbmcgYWN0aXZpdGllcyAoZS5nIGBzZXRJbnRlcnZhbGAsIGludm9rZWQgY2FsbGJhY2tzLCBwcm9taXNlcylcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwic3RvcEFjdGl2aXRpZXNcIiwgKHN0YXRlKSA9PiB7XG4gICAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgdGhpcy5hY3Rpdml0eUV2ZW50cy5nZXQoc3RhdGUpPy5mb3JFYWNoKChzdG9wKSA9PiBzdG9wKCkpO1xuICAgICAgICB0aGlzLmFjdGl2aXR5RXZlbnRzLmdldChzdGF0ZSk/LmNsZWFyKCk7XG4gICAgICAgIHRoaXMuYWN0aXZpdHlFdmVudHMuZGVsZXRlKHN0YXRlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYWN0aXZpdHlFdmVudHMuZm9yRWFjaCgoc3RhdGUyKSA9PiB7XG4gICAgICAgICAgc3RhdGUyLmZvckVhY2goKHN0b3ApID0+IHN0b3AoKSk7XG4gICAgICAgICAgc3RhdGUyLmNsZWFyKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmFjdGl2aXR5RXZlbnRzLmNsZWFyKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdG8gc2VuZCBldmVudCB0byBzcGF3bmVkIGNoaWxkIG1hY2hpbmUgb3IgYWN0b3JcbiAgICAgKi9cbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwic2VuZENoaWxkXCIsIChldnQsIHRvKSA9PiB7XG4gICAgICBjb25zdCBldmVudCA9IHRvRXZlbnQoZXZ0KTtcbiAgICAgIGNvbnN0IGlkID0gcnVuSWZGbih0bywgdGhpcy5jb250ZXh0U25hcHNob3QpO1xuICAgICAgY29uc3QgY2hpbGQgPSB0aGlzLmNoaWxkcmVuLmdldChpZCk7XG4gICAgICBpZiAoIWNoaWxkKSB7XG4gICAgICAgIGludmFyaWFudChgW0B6YWctanMvY29yZV0gQ2Fubm90IHNlbmQgJyR7ZXZlbnQudHlwZX0nIGV2ZW50IHRvIHVua25vd24gY2hpbGRgKTtcbiAgICAgIH1cbiAgICAgIGNoaWxkLnNlbmQoZXZlbnQpO1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHRvIHN0b3AgYSBydW5uaW5nIGNoaWxkIG1hY2hpbmUgb3IgYWN0b3JcbiAgICAgKi9cbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwic3RvcENoaWxkXCIsIChpZCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLmNoaWxkcmVuLmhhcyhpZCkpIHtcbiAgICAgICAgaW52YXJpYW50KGBbQHphZy1qcy9jb3JlID4gc3RvcC1jaGlsZF0gQ2Fubm90IHN0b3AgdW5rbm93biBjaGlsZCAke2lkfWApO1xuICAgICAgfVxuICAgICAgdGhpcy5jaGlsZHJlbi5nZXQoaWQpLnN0b3AoKTtcbiAgICAgIHRoaXMuY2hpbGRyZW4uZGVsZXRlKGlkKTtcbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicmVtb3ZlQ2hpbGRcIiwgKGlkKSA9PiB7XG4gICAgICB0aGlzLmNoaWxkcmVuLmRlbGV0ZShpZCk7XG4gICAgfSk7XG4gICAgLy8gU3RvcCBhbmQgZGVsZXRlIHNwYXduZWQgYWN0b3JzXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInN0b3BDaGlsZHJlblwiLCAoKSA9PiB7XG4gICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goKGNoaWxkKSA9PiBjaGlsZC5zdG9wKCkpO1xuICAgICAgdGhpcy5jaGlsZHJlbi5jbGVhcigpO1xuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJzZXRQYXJlbnRcIiwgKHBhcmVudCkgPT4ge1xuICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInNwYXduXCIsIChzcmMsIGlkKSA9PiB7XG4gICAgICBjb25zdCBhY3RvciA9IHJ1bklmRm4oc3JjKTtcbiAgICAgIGlmIChpZCkgYWN0b3IuaWQgPSBpZDtcbiAgICAgIGFjdG9yLnR5cGUgPSBcIm1hY2hpbmUuYWN0b3JcIiAvKiBBY3RvciAqLztcbiAgICAgIGFjdG9yLnNldFBhcmVudCh0aGlzKTtcbiAgICAgIHRoaXMuY2hpbGRyZW4uc2V0KGFjdG9yLmlkLCBjYXN0KGFjdG9yKSk7XG4gICAgICBhY3Rvci5vbkRvbmUoKCkgPT4ge1xuICAgICAgICB0aGlzLnJlbW92ZUNoaWxkKGFjdG9yLmlkKTtcbiAgICAgIH0pLnN0YXJ0KCk7XG4gICAgICByZXR1cm4gY2FzdChyZWYoYWN0b3IpKTtcbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwic3RvcEFjdGl2aXR5XCIsIChrZXkpID0+IHtcbiAgICAgIGlmICghdGhpcy5zdGF0ZS52YWx1ZSkgcmV0dXJuO1xuICAgICAgY29uc3QgY2xlYW51cHMgPSB0aGlzLmFjdGl2aXR5RXZlbnRzLmdldCh0aGlzLnN0YXRlLnZhbHVlKTtcbiAgICAgIGNsZWFudXBzPy5nZXQoa2V5KT8uKCk7XG4gICAgICBjbGVhbnVwcz8uZGVsZXRlKGtleSk7XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImFkZEFjdGl2aXR5Q2xlYW51cFwiLCAoc3RhdGUsIGtleSwgY2xlYW51cCkgPT4ge1xuICAgICAgaWYgKCFzdGF0ZSkgcmV0dXJuO1xuICAgICAgaWYgKCF0aGlzLmFjdGl2aXR5RXZlbnRzLmhhcyhzdGF0ZSkpIHtcbiAgICAgICAgdGhpcy5hY3Rpdml0eUV2ZW50cy5zZXQoc3RhdGUsIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtba2V5LCBjbGVhbnVwXV0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYWN0aXZpdHlFdmVudHMuZ2V0KHN0YXRlKT8uc2V0KGtleSwgY2xlYW51cCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInNldFN0YXRlXCIsICh0YXJnZXQpID0+IHtcbiAgICAgIHRoaXMuc3RhdGUucHJldmlvdXNWYWx1ZSA9IHRoaXMuc3RhdGUudmFsdWU7XG4gICAgICB0aGlzLnN0YXRlLnZhbHVlID0gdGFyZ2V0O1xuICAgICAgY29uc3Qgc3RhdGVOb2RlID0gdGhpcy5nZXRTdGF0ZU5vZGUodGFyZ2V0KTtcbiAgICAgIGlmICh0YXJnZXQgPT0gbnVsbCkge1xuICAgICAgICBjbGVhcih0aGlzLnN0YXRlLnRhZ3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zdGF0ZS50YWdzID0gdG9BcnJheShzdGF0ZU5vZGU/LnRhZ3MpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFRvIHVzZWQgd2l0aGluIHNpZGUgZWZmZWN0cyBmb3IgUmVhY3Qgb3IgVnVlIHRvIHVwZGF0ZSBjb250ZXh0XG4gICAgICovXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInNldENvbnRleHRcIiwgKGNvbnRleHQpID0+IHtcbiAgICAgIGlmICghY29udGV4dCkgcmV0dXJuO1xuICAgICAgZGVlcE1lcmdlKHRoaXMuc3RhdGUuY29udGV4dCwgY29tcGFjdChjb250ZXh0KSk7XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInNldE9wdGlvbnNcIiwgKG9wdGlvbnMpID0+IHtcbiAgICAgIGNvbnN0IG9wdHMgPSBjb21wYWN0KG9wdGlvbnMpO1xuICAgICAgdGhpcy5hY3Rpb25NYXAgPSB7IC4uLnRoaXMuYWN0aW9uTWFwLCAuLi5vcHRzLmFjdGlvbnMgfTtcbiAgICAgIHRoaXMuZGVsYXlNYXAgPSB7IC4uLnRoaXMuZGVsYXlNYXAsIC4uLm9wdHMuZGVsYXlzIH07XG4gICAgICB0aGlzLmFjdGl2aXR5TWFwID0geyAuLi50aGlzLmFjdGl2aXR5TWFwLCAuLi5vcHRzLmFjdGl2aXRpZXMgfTtcbiAgICAgIHRoaXMuZ3VhcmRNYXAgPSB7IC4uLnRoaXMuZ3VhcmRNYXAsIC4uLm9wdHMuZ3VhcmRzIH07XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImdldFN0YXRlTm9kZVwiLCAoc3RhdGUpID0+IHtcbiAgICAgIGlmICghc3RhdGUpIHJldHVybjtcbiAgICAgIHJldHVybiB0aGlzLmNvbmZpZy5zdGF0ZXM/LltzdGF0ZV07XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImdldE5leHRTdGF0ZUluZm9cIiwgKHRyYW5zaXRpb25zLCBldmVudCkgPT4ge1xuICAgICAgY29uc3QgdHJhbnNpdGlvbiA9IHRoaXMuZGV0ZXJtaW5lVHJhbnNpdGlvbih0cmFuc2l0aW9ucywgZXZlbnQpO1xuICAgICAgY29uc3QgaXNUYXJnZXRsZXNzID0gIXRyYW5zaXRpb24/LnRhcmdldDtcbiAgICAgIGNvbnN0IHRhcmdldCA9IHRyYW5zaXRpb24/LnRhcmdldCA/PyB0aGlzLnN0YXRlLnZhbHVlO1xuICAgICAgY29uc3QgY2hhbmdlZCA9IHRoaXMuc3RhdGUudmFsdWUgIT09IHRhcmdldDtcbiAgICAgIGNvbnN0IHN0YXRlTm9kZSA9IHRoaXMuZ2V0U3RhdGVOb2RlKHRhcmdldCk7XG4gICAgICBjb25zdCByZWVudGVyID0gIWlzVGFyZ2V0bGVzcyAmJiAhY2hhbmdlZCAmJiAhdHJhbnNpdGlvbj8uaW50ZXJuYWw7XG4gICAgICBjb25zdCBpbmZvID0ge1xuICAgICAgICByZWVudGVyLFxuICAgICAgICB0cmFuc2l0aW9uLFxuICAgICAgICBzdGF0ZU5vZGUsXG4gICAgICAgIHRhcmdldCxcbiAgICAgICAgY2hhbmdlZFxuICAgICAgfTtcbiAgICAgIHRoaXMubG9nKFwiTmV4dFN0YXRlOlwiLCBgWyR7ZXZlbnQudHlwZX1dYCwgdGhpcy5zdGF0ZS52YWx1ZSwgXCItLS0tPlwiLCBpbmZvLnRhcmdldCk7XG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZ2V0QWZ0ZXJBY3Rpb25zXCIsICh0cmFuc2l0aW9uLCBkZWxheSkgPT4ge1xuICAgICAgbGV0IGlkO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZW50cnk6ICgpID0+IHtcbiAgICAgICAgICBpZCA9IGdsb2JhbFRoaXMuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuZXh0ID0gdGhpcy5nZXROZXh0U3RhdGVJbmZvKHRyYW5zaXRpb24sIHRoaXMuc3RhdGUuZXZlbnQpO1xuICAgICAgICAgICAgdGhpcy5wZXJmb3JtU3RhdGVDaGFuZ2VFZmZlY3RzKHRoaXMuc3RhdGUudmFsdWUsIG5leHQsIHRoaXMuc3RhdGUuZXZlbnQpO1xuICAgICAgICAgIH0sIGRlbGF5KTtcbiAgICAgICAgfSxcbiAgICAgICAgZXhpdDogKCkgPT4ge1xuICAgICAgICAgIGdsb2JhbFRoaXMuY2xlYXJUaW1lb3V0KGlkKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBBbGwgYGFmdGVyYCBldmVudHMgbGV2ZXJhZ2UgYHNldFRpbWVvdXRgIGFuZCBgY2xlYXJUaW1lb3V0YCxcbiAgICAgKiB3ZSBpbnZva2UgdGhlIGBjbGVhclRpbWVvdXRgIG9uIGV4aXQgYW5kIGBzZXRUaW1lb3V0YCBvbiBlbnRyeS5cbiAgICAgKlxuICAgICAqIFRvIGFjaGlldmUgdGhpcywgd2Ugc3BsaXQgdGhlIGBhZnRlcmAgZGVmaW50aW9uIGludG8gYGVudHJ5YCBhbmQgYGV4aXRgXG4gICAgICogIGZ1bmN0aW9ucyBhbmQgYXBwZW5kIHRoZW0gdG8gdGhlIHN0YXRlJ3MgYGVudHJ5YCBhbmQgYGV4aXRgIGFjdGlvbnNcbiAgICAgKi9cbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZ2V0RGVsYXllZEV2ZW50QWN0aW9uc1wiLCAoc3RhdGUpID0+IHtcbiAgICAgIGNvbnN0IHN0YXRlTm9kZSA9IHRoaXMuZ2V0U3RhdGVOb2RlKHN0YXRlKTtcbiAgICAgIGNvbnN0IGV2ZW50ID0gdGhpcy5zdGF0ZS5ldmVudDtcbiAgICAgIGlmICghc3RhdGVOb2RlIHx8ICFzdGF0ZU5vZGUuYWZ0ZXIpIHJldHVybjtcbiAgICAgIGNvbnN0IGVudHJpZXMgPSBbXTtcbiAgICAgIGNvbnN0IGV4aXRzID0gW107XG4gICAgICBpZiAoaXNBcnJheShzdGF0ZU5vZGUuYWZ0ZXIpKSB7XG4gICAgICAgIGNvbnN0IHRyYW5zaXRpb24gPSB0aGlzLmRldGVybWluZVRyYW5zaXRpb24oc3RhdGVOb2RlLmFmdGVyLCBldmVudCk7XG4gICAgICAgIGlmICghdHJhbnNpdGlvbikgcmV0dXJuO1xuICAgICAgICBpZiAoIWhhc1Byb3AodHJhbnNpdGlvbiwgXCJkZWxheVwiKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgW0B6YWctanMvY29yZSA+IGFmdGVyXSBEZWxheSBpcyByZXF1aXJlZCBmb3IgYWZ0ZXIgdHJhbnNpdGlvbjogJHtKU09OLnN0cmluZ2lmeSh0cmFuc2l0aW9uKX1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZXRlcm1pbmVEZWxheSA9IGRldGVybWluZURlbGF5Rm4odHJhbnNpdGlvbi5kZWxheSwgdGhpcy5kZWxheU1hcCk7XG4gICAgICAgIGNvbnN0IF9fZGVsYXkgPSBkZXRlcm1pbmVEZWxheSh0aGlzLmNvbnRleHRTbmFwc2hvdCwgZXZlbnQpO1xuICAgICAgICBjb25zdCBhY3Rpb25zID0gdGhpcy5nZXRBZnRlckFjdGlvbnModHJhbnNpdGlvbiwgX19kZWxheSk7XG4gICAgICAgIGVudHJpZXMucHVzaChhY3Rpb25zLmVudHJ5KTtcbiAgICAgICAgZXhpdHMucHVzaChhY3Rpb25zLmV4aXQpO1xuICAgICAgICByZXR1cm4geyBlbnRyaWVzLCBleGl0cyB9O1xuICAgICAgfVxuICAgICAgaWYgKGlzT2JqZWN0KHN0YXRlTm9kZS5hZnRlcikpIHtcbiAgICAgICAgZm9yIChjb25zdCBkZWxheSBpbiBzdGF0ZU5vZGUuYWZ0ZXIpIHtcbiAgICAgICAgICBjb25zdCB0cmFuc2l0aW9uID0gc3RhdGVOb2RlLmFmdGVyW2RlbGF5XTtcbiAgICAgICAgICBjb25zdCBkZXRlcm1pbmVEZWxheSA9IGRldGVybWluZURlbGF5Rm4oZGVsYXksIHRoaXMuZGVsYXlNYXApO1xuICAgICAgICAgIGNvbnN0IF9fZGVsYXkgPSBkZXRlcm1pbmVEZWxheSh0aGlzLmNvbnRleHRTbmFwc2hvdCwgZXZlbnQpO1xuICAgICAgICAgIGNvbnN0IGFjdGlvbnMgPSB0aGlzLmdldEFmdGVyQWN0aW9ucyh0cmFuc2l0aW9uLCBfX2RlbGF5KTtcbiAgICAgICAgICBlbnRyaWVzLnB1c2goYWN0aW9ucy5lbnRyeSk7XG4gICAgICAgICAgZXhpdHMucHVzaChhY3Rpb25zLmV4aXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4geyBlbnRyaWVzLCBleGl0cyB9O1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHRvIGV4ZWN1dGVzIGRlZmluZWQgYWN0aW9ucy4gSXQgY2FuIGFjY2VwdCBhY3Rpb25zIGFzIHN0cmluZ1xuICAgICAqIChyZWZlcmVuY2luZyBgb3B0aW9ucy5hY3Rpb25zYCkgb3IgYWN0dWFsIGZ1bmN0aW9ucy5cbiAgICAgKi9cbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZXhlY3V0ZUFjdGlvbnNcIiwgKGFjdGlvbnMsIGV2ZW50KSA9PiB7XG4gICAgICBjb25zdCBwaWNrZWRBY3Rpb25zID0gZGV0ZXJtaW5lQWN0aW9uc0ZuKGFjdGlvbnMsIHRoaXMuZ3VhcmRNYXApKHRoaXMuY29udGV4dFNuYXBzaG90LCBldmVudCwgdGhpcy5ndWFyZE1ldGEpO1xuICAgICAgZm9yIChjb25zdCBhY3Rpb24gb2YgdG9BcnJheShwaWNrZWRBY3Rpb25zKSkge1xuICAgICAgICBjb25zdCBmbiA9IGlzU3RyaW5nKGFjdGlvbikgPyB0aGlzLmFjdGlvbk1hcD8uW2FjdGlvbl0gOiBhY3Rpb247XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgaXNTdHJpbmcoYWN0aW9uKSAmJiAhZm4sXG4gICAgICAgICAgYFtAemFnLWpzL2NvcmUgPiBleGVjdXRlLWFjdGlvbnNdIE5vIGltcGxlbWVudGF0aW9uIGZvdW5kIGZvciBhY3Rpb246IFxcYCR7YWN0aW9ufVxcYGBcbiAgICAgICAgKTtcbiAgICAgICAgZm4/Lih0aGlzLnN0YXRlLmNvbnRleHQsIGV2ZW50LCB0aGlzLm1ldGEpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgcnVubmluZyBhY3Rpdml0aWVzIGFuZCByZWdpc3RlcnNcbiAgICAgKiB0aGVpciBjbGVhbnVwIGZ1bmN0aW9uIGludGVybmFsbHkgKHRvIGJlIGNhbGxlZCBsYXRlciBvbiB3aGVuIHdlIGV4aXQgdGhlIHN0YXRlKVxuICAgICAqL1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJleGVjdXRlQWN0aXZpdGllc1wiLCAoZXZlbnQsIGFjdGl2aXRpZXMsIHN0YXRlKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGFjdGl2aXR5IG9mIGFjdGl2aXRpZXMpIHtcbiAgICAgICAgY29uc3QgZm4gPSBpc1N0cmluZyhhY3Rpdml0eSkgPyB0aGlzLmFjdGl2aXR5TWFwPy5bYWN0aXZpdHldIDogYWN0aXZpdHk7XG4gICAgICAgIGlmICghZm4pIHtcbiAgICAgICAgICB3YXJuKGBbQHphZy1qcy9jb3JlID4gZXhlY3V0ZS1hY3Rpdml0eV0gTm8gaW1wbGVtZW50YXRpb24gZm91bmQgZm9yIGFjdGl2aXR5OiBcXGAke2FjdGl2aXR5fVxcYGApO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNsZWFudXAgPSBmbih0aGlzLnN0YXRlLmNvbnRleHQsIGV2ZW50LCB0aGlzLm1ldGEpO1xuICAgICAgICBpZiAoY2xlYW51cCkge1xuICAgICAgICAgIGNvbnN0IGtleSA9IGlzU3RyaW5nKGFjdGl2aXR5KSA/IGFjdGl2aXR5IDogYWN0aXZpdHkubmFtZSB8fCB1dWlkKCk7XG4gICAgICAgICAgdGhpcy5hZGRBY3Rpdml0eUNsZWFudXAoc3RhdGUgPz8gdGhpcy5zdGF0ZS52YWx1ZSwga2V5LCBjbGVhbnVwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIE5vcm1hbGl6ZXMgdGhlIGBldmVyeWAgZGVmaW5pdGlvbiB0byB0cmFuc2l0aW9uLiBgZXZlcnlgIGNhbiBiZTpcbiAgICAgKiAtIEFuIGFycmF5IG9mIHBvc3NpYmxlIGFjdGlvbnMgdG8gcnVuICh3ZSBuZWVkIHRvIHBpY2sgdGhlIGZpcnN0IG1hdGNoIGJhc2VkIG9uIGd1YXJkKVxuICAgICAqIC0gQW4gb2JqZWN0IG9mIGludGVydmFscyBhbmQgYWN0aW9uc1xuICAgICAqL1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJjcmVhdGVFdmVyeUFjdGl2aXRpZXNcIiwgKGV2ZXJ5LCBjYWxsYmFja2ZuKSA9PiB7XG4gICAgICBpZiAoIWV2ZXJ5KSByZXR1cm47XG4gICAgICBpZiAoaXNBcnJheShldmVyeSkpIHtcbiAgICAgICAgY29uc3QgcGlja2VkID0gdG9BcnJheShldmVyeSkuZmluZCgodHJhbnNpdGlvbikgPT4ge1xuICAgICAgICAgIGNvbnN0IGRlbGF5T3JGbiA9IHRyYW5zaXRpb24uZGVsYXk7XG4gICAgICAgICAgY29uc3QgZGV0ZXJtaW5lRGVsYXkyID0gZGV0ZXJtaW5lRGVsYXlGbihkZWxheU9yRm4sIHRoaXMuZGVsYXlNYXApO1xuICAgICAgICAgIGNvbnN0IGRlbGF5MiA9IGRldGVybWluZURlbGF5Mih0aGlzLmNvbnRleHRTbmFwc2hvdCwgdGhpcy5zdGF0ZS5ldmVudCk7XG4gICAgICAgICAgY29uc3QgZGV0ZXJtaW5lR3VhcmQgPSBkZXRlcm1pbmVHdWFyZEZuKHRyYW5zaXRpb24uZ3VhcmQsIHRoaXMuZ3VhcmRNYXApO1xuICAgICAgICAgIGNvbnN0IGd1YXJkID0gZGV0ZXJtaW5lR3VhcmQodGhpcy5jb250ZXh0U25hcHNob3QsIHRoaXMuc3RhdGUuZXZlbnQsIHRoaXMuZ3VhcmRNZXRhKTtcbiAgICAgICAgICByZXR1cm4gZ3VhcmQgPz8gZGVsYXkyICE9IG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXBpY2tlZCkgcmV0dXJuO1xuICAgICAgICBjb25zdCBkZXRlcm1pbmVEZWxheSA9IGRldGVybWluZURlbGF5Rm4ocGlja2VkLmRlbGF5LCB0aGlzLmRlbGF5TWFwKTtcbiAgICAgICAgY29uc3QgZGVsYXkgPSBkZXRlcm1pbmVEZWxheSh0aGlzLmNvbnRleHRTbmFwc2hvdCwgdGhpcy5zdGF0ZS5ldmVudCk7XG4gICAgICAgIGNvbnN0IGFjdGl2aXR5ID0gKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGlkID0gZ2xvYmFsVGhpcy5zZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmV4ZWN1dGVBY3Rpb25zKHBpY2tlZC5hY3Rpb25zLCB0aGlzLnN0YXRlLmV2ZW50KTtcbiAgICAgICAgICB9LCBkZWxheSk7XG4gICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGdsb2JhbFRoaXMuY2xlYXJJbnRlcnZhbChpZCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgY2FsbGJhY2tmbihhY3Rpdml0eSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGNvbnN0IGludGVydmFsIGluIGV2ZXJ5KSB7XG4gICAgICAgICAgY29uc3QgYWN0aW9ucyA9IGV2ZXJ5Py5baW50ZXJ2YWxdO1xuICAgICAgICAgIGNvbnN0IGRldGVybWluZURlbGF5ID0gZGV0ZXJtaW5lRGVsYXlGbihpbnRlcnZhbCwgdGhpcy5kZWxheU1hcCk7XG4gICAgICAgICAgY29uc3QgZGVsYXkgPSBkZXRlcm1pbmVEZWxheSh0aGlzLmNvbnRleHRTbmFwc2hvdCwgdGhpcy5zdGF0ZS5ldmVudCk7XG4gICAgICAgICAgY29uc3QgYWN0aXZpdHkgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpZCA9IGdsb2JhbFRoaXMuc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLmV4ZWN1dGVBY3Rpb25zKGFjdGlvbnMsIHRoaXMuc3RhdGUuZXZlbnQpO1xuICAgICAgICAgICAgfSwgZGVsYXkpO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgZ2xvYmFsVGhpcy5jbGVhckludGVydmFsKGlkKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfTtcbiAgICAgICAgICBjYWxsYmFja2ZuKGFjdGl2aXR5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJzZXRFdmVudFwiLCAoZXZlbnQpID0+IHtcbiAgICAgIHRoaXMuc3RhdGUucHJldmlvdXNFdmVudCA9IHRoaXMuc3RhdGUuZXZlbnQ7XG4gICAgICB0aGlzLnN0YXRlLmV2ZW50ID0gcmVmKHRvRXZlbnQoZXZlbnQpKTtcbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicGVyZm9ybUV4aXRFZmZlY3RzXCIsIChjdXJyZW50LCBldmVudCkgPT4ge1xuICAgICAgY29uc3QgY3VycmVudFN0YXRlID0gdGhpcy5zdGF0ZS52YWx1ZTtcbiAgICAgIGlmIChjdXJyZW50U3RhdGUgPT09IFwiXCIpIHJldHVybjtcbiAgICAgIGNvbnN0IHN0YXRlTm9kZSA9IGN1cnJlbnQgPyB0aGlzLmdldFN0YXRlTm9kZShjdXJyZW50KSA6IHZvaWQgMDtcbiAgICAgIHRoaXMuc3RvcEFjdGl2aXRpZXMoY3VycmVudFN0YXRlKTtcbiAgICAgIGNvbnN0IF9leGl0ID0gZGV0ZXJtaW5lQWN0aW9uc0ZuKHN0YXRlTm9kZT8uZXhpdCwgdGhpcy5ndWFyZE1hcCkodGhpcy5jb250ZXh0U25hcHNob3QsIGV2ZW50LCB0aGlzLmd1YXJkTWV0YSk7XG4gICAgICBjb25zdCBleGl0QWN0aW9ucyA9IHRvQXJyYXkoX2V4aXQpO1xuICAgICAgY29uc3QgYWZ0ZXJFeGl0QWN0aW9ucyA9IHRoaXMuZGVsYXllZEV2ZW50cy5nZXQoY3VycmVudFN0YXRlKTtcbiAgICAgIGlmIChhZnRlckV4aXRBY3Rpb25zKSB7XG4gICAgICAgIGV4aXRBY3Rpb25zLnB1c2goLi4uYWZ0ZXJFeGl0QWN0aW9ucyk7XG4gICAgICB9XG4gICAgICB0aGlzLmV4ZWN1dGVBY3Rpb25zKGV4aXRBY3Rpb25zLCBldmVudCk7XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInBlcmZvcm1FbnRyeUVmZmVjdHNcIiwgKG5leHQsIGV2ZW50KSA9PiB7XG4gICAgICBjb25zdCBzdGF0ZU5vZGUgPSB0aGlzLmdldFN0YXRlTm9kZShuZXh0KTtcbiAgICAgIGNvbnN0IGFjdGl2aXRpZXMgPSB0b0FycmF5KHN0YXRlTm9kZT8uYWN0aXZpdGllcyk7XG4gICAgICB0aGlzLmNyZWF0ZUV2ZXJ5QWN0aXZpdGllcyhzdGF0ZU5vZGU/LmV2ZXJ5LCAoYWN0aXZpdHkpID0+IHtcbiAgICAgICAgYWN0aXZpdGllcy51bnNoaWZ0KGFjdGl2aXR5KTtcbiAgICAgIH0pO1xuICAgICAgaWYgKGFjdGl2aXRpZXMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLmV4ZWN1dGVBY3Rpdml0aWVzKGV2ZW50LCBhY3Rpdml0aWVzKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBpY2tlZEFjdGlvbnMgPSBkZXRlcm1pbmVBY3Rpb25zRm4oc3RhdGVOb2RlPy5lbnRyeSwgdGhpcy5ndWFyZE1hcCkoXG4gICAgICAgIHRoaXMuY29udGV4dFNuYXBzaG90LFxuICAgICAgICBldmVudCxcbiAgICAgICAgdGhpcy5ndWFyZE1ldGFcbiAgICAgICk7XG4gICAgICBjb25zdCBlbnRyeUFjdGlvbnMgPSB0b0FycmF5KHBpY2tlZEFjdGlvbnMpO1xuICAgICAgY29uc3QgYWZ0ZXJBY3Rpb25zID0gdGhpcy5nZXREZWxheWVkRXZlbnRBY3Rpb25zKG5leHQpO1xuICAgICAgaWYgKHN0YXRlTm9kZT8uYWZ0ZXIgJiYgYWZ0ZXJBY3Rpb25zKSB7XG4gICAgICAgIHRoaXMuZGVsYXllZEV2ZW50cy5zZXQobmV4dCwgYWZ0ZXJBY3Rpb25zPy5leGl0cyk7XG4gICAgICAgIGVudHJ5QWN0aW9ucy5wdXNoKC4uLmFmdGVyQWN0aW9ucy5lbnRyaWVzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZXhlY3V0ZUFjdGlvbnMoZW50cnlBY3Rpb25zLCBldmVudCk7XG4gICAgICBpZiAoc3RhdGVOb2RlPy50eXBlID09PSBcImZpbmFsXCIpIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5kb25lID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kb25lTGlzdGVuZXJzLmZvckVhY2goKGxpc3RlbmVyKSA9PiB7XG4gICAgICAgICAgbGlzdGVuZXIodGhpcy5zdGF0ZVNuYXBzaG90KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJwZXJmb3JtVHJhbnNpdGlvbkVmZmVjdHNcIiwgKHRyYW5zaXRpb25zLCBldmVudCkgPT4ge1xuICAgICAgY29uc3QgdHJhbnNpdGlvbiA9IHRoaXMuZGV0ZXJtaW5lVHJhbnNpdGlvbih0cmFuc2l0aW9ucywgZXZlbnQpO1xuICAgICAgdGhpcy5leGVjdXRlQWN0aW9ucyh0cmFuc2l0aW9uPy5hY3Rpb25zLCBldmVudCk7XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYWxsIHRoZSByZXF1aXJlcyBzaWRlLWVmZmVjdHMgb3IgcmVhY3Rpb25zIHdoZW5cbiAgICAgKiB3ZSBtb3ZlIGZyb20gc3RhdGUgQSA9PiBzdGF0ZSBCLlxuICAgICAqXG4gICAgICogVGhlIEVmZmVjdCBvcmRlcjpcbiAgICAgKiBFeGl0IGFjdGlvbnMgKGN1cnJlbnQgc3RhdGUpID0+IFRyYW5zaXRpb24gYWN0aW9ucyAgPT4gR28gdG8gc3RhdGUgPT4gRW50cnkgYWN0aW9ucyAobmV4dCBzdGF0ZSlcbiAgICAgKi9cbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicGVyZm9ybVN0YXRlQ2hhbmdlRWZmZWN0c1wiLCAoY3VycmVudCwgbmV4dCwgZXZlbnQpID0+IHtcbiAgICAgIHRoaXMuc2V0RXZlbnQoZXZlbnQpO1xuICAgICAgY29uc3QgY2hhbmdlZCA9IG5leHQuY2hhbmdlZCB8fCBuZXh0LnJlZW50ZXI7XG4gICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICB0aGlzLnBlcmZvcm1FeGl0RWZmZWN0cyhjdXJyZW50LCBldmVudCk7XG4gICAgICB9XG4gICAgICB0aGlzLnBlcmZvcm1UcmFuc2l0aW9uRWZmZWN0cyhuZXh0LnRyYW5zaXRpb24sIGV2ZW50KTtcbiAgICAgIHRoaXMuc2V0U3RhdGUobmV4dC50YXJnZXQpO1xuICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgdGhpcy5wZXJmb3JtRW50cnlFZmZlY3RzKG5leHQudGFyZ2V0LCBldmVudCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImRldGVybWluZVRyYW5zaXRpb25cIiwgKHRyYW5zaXRpb24sIGV2ZW50KSA9PiB7XG4gICAgICBjb25zdCBmbiA9IGRldGVybWluZVRyYW5zaXRpb25Gbih0cmFuc2l0aW9uLCB0aGlzLmd1YXJkTWFwKTtcbiAgICAgIHJldHVybiBmbj8uKHRoaXMuY29udGV4dFNuYXBzaG90LCBldmVudCwgdGhpcy5ndWFyZE1ldGEpO1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHRvIHNlbmQgZXZlbnQgdG8gcGFyZW50IG1hY2hpbmUgZnJvbSBzcGF3bmVkIGNoaWxkXG4gICAgICovXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInNlbmRQYXJlbnRcIiwgKGV2dCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgICBpbnZhcmlhbnQoXCJbQHphZy1qcy9jb3JlID4gc2VuZC1wYXJlbnRdIENhbm5vdCBzZW5kIGV2ZW50IHRvIGFuIHVua25vd24gcGFyZW50XCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgZXZlbnQgPSB0b0V2ZW50KGV2dCk7XG4gICAgICB0aGlzLnBhcmVudD8uc2VuZChldmVudCk7XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImxvZ1wiLCAoLi4uYXJncykgPT4ge1xuICAgICAgaWYgKGlzRGV2KCkgJiYgdGhpcy5vcHRpb25zLmRlYnVnKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKC4uLmFyZ3MpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHRvIHNlbmQgYW4gZXZlbnQgdG8gY3VycmVudCBtYWNoaW5lXG4gICAgICovXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInNlbmRcIiwgKGV2dCkgPT4ge1xuICAgICAgY29uc3QgZXZlbnQgPSB0b0V2ZW50KGV2dCk7XG4gICAgICB0aGlzLnRyYW5zaXRpb24odGhpcy5zdGF0ZS52YWx1ZSwgZXZlbnQpO1xuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ0cmFuc2l0aW9uXCIsIChzdGF0ZSwgZXZ0KSA9PiB7XG4gICAgICBjb25zdCBzdGF0ZU5vZGUgPSBpc1N0cmluZyhzdGF0ZSkgPyB0aGlzLmdldFN0YXRlTm9kZShzdGF0ZSkgOiBzdGF0ZT8uc3RhdGVOb2RlO1xuICAgICAgY29uc3QgZXZlbnQgPSB0b0V2ZW50KGV2dCk7XG4gICAgICBpZiAoIXN0YXRlTm9kZSAmJiAhdGhpcy5jb25maWcub24pIHtcbiAgICAgICAgY29uc3QgbXNnID0gdGhpcy5zdGF0dXMgPT09IFwiU3RvcHBlZFwiIC8qIFN0b3BwZWQgKi8gPyBcIltAemFnLWpzL2NvcmUgPiB0cmFuc2l0aW9uXSBDYW5ub3QgdHJhbnNpdGlvbiBhIHN0b3BwZWQgbWFjaGluZVwiIDogYFtAemFnLWpzL2NvcmUgPiB0cmFuc2l0aW9uXSBTdGF0ZSBkb2VzIG5vdCBoYXZlIGEgZGVmaW5pdGlvbiBmb3IgXFxgc3RhdGVcXGA6ICR7c3RhdGV9LCBcXGBldmVudFxcYDogJHtldmVudC50eXBlfWA7XG4gICAgICAgIHdhcm4obXNnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgdHJhbnNpdGlvbnMgPSAoXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLSBGaXggdGhpc1xuICAgICAgICBzdGF0ZU5vZGU/Lm9uPy5bZXZlbnQudHlwZV0gPz8gdGhpcy5jb25maWcub24/LltldmVudC50eXBlXVxuICAgICAgKTtcbiAgICAgIGNvbnN0IG5leHQgPSB0aGlzLmdldE5leHRTdGF0ZUluZm8odHJhbnNpdGlvbnMsIGV2ZW50KTtcbiAgICAgIHRoaXMucGVyZm9ybVN0YXRlQ2hhbmdlRWZmZWN0cyh0aGlzLnN0YXRlLnZhbHVlLCBuZXh0LCBldmVudCk7XG4gICAgICByZXR1cm4gbmV4dC5zdGF0ZU5vZGU7XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInN1YnNjcmliZVwiLCAobGlzdGVuZXIpID0+IHtcbiAgICAgIHRoaXMuc3RhdGVMaXN0ZW5lcnMuYWRkKGxpc3RlbmVyKTtcbiAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gXCJSdW5uaW5nXCIgLyogUnVubmluZyAqLykge1xuICAgICAgICBsaXN0ZW5lcih0aGlzLnN0YXRlU25hcHNob3QpO1xuICAgICAgfVxuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgdGhpcy5zdGF0ZUxpc3RlbmVycy5kZWxldGUobGlzdGVuZXIpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwib25Eb25lXCIsIChsaXN0ZW5lcikgPT4ge1xuICAgICAgdGhpcy5kb25lTGlzdGVuZXJzLmFkZChsaXN0ZW5lcik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwib25UcmFuc2l0aW9uXCIsIChsaXN0ZW5lcikgPT4ge1xuICAgICAgdGhpcy5zdGF0ZUxpc3RlbmVycy5hZGQobGlzdGVuZXIpO1xuICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSBcIlJ1bm5pbmdcIiAvKiBSdW5uaW5nICovKSB7XG4gICAgICAgIGxpc3RlbmVyKHRoaXMuc3RhdGVTbmFwc2hvdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9KTtcbiAgICB0aGlzLmNvbmZpZyA9IHN0cnVjdHVyZWRDbG9uZShjb25maWcpO1xuICAgIHRoaXMub3B0aW9ucyA9IHN0cnVjdHVyZWRDbG9uZShvcHRpb25zID8/IHt9KTtcbiAgICB0aGlzLmlkID0gdGhpcy5jb25maWcuaWQgPz8gYG1hY2hpbmUtJHt1dWlkKCl9YDtcbiAgICB0aGlzLmd1YXJkTWFwID0gdGhpcy5vcHRpb25zPy5ndWFyZHMgPz8ge307XG4gICAgdGhpcy5hY3Rpb25NYXAgPSB0aGlzLm9wdGlvbnM/LmFjdGlvbnMgPz8ge307XG4gICAgdGhpcy5kZWxheU1hcCA9IHRoaXMub3B0aW9ucz8uZGVsYXlzID8/IHt9O1xuICAgIHRoaXMuYWN0aXZpdHlNYXAgPSB0aGlzLm9wdGlvbnM/LmFjdGl2aXRpZXMgPz8ge307XG4gICAgdGhpcy5zeW5jID0gdGhpcy5vcHRpb25zPy5zeW5jID8/IGZhbHNlO1xuICAgIHRoaXMuc3RhdGUgPSBjcmVhdGVQcm94eSh0aGlzLmNvbmZpZyk7XG4gICAgdGhpcy5pbml0aWFsQ29udGV4dCA9IHNuYXBzaG90KHRoaXMuc3RhdGUuY29udGV4dCk7XG4gIH1cbiAgLy8gaW1tdXRhYmxlIHN0YXRlIHZhbHVlXG4gIGdldCBzdGF0ZVNuYXBzaG90KCkge1xuICAgIHJldHVybiBjYXN0KHNuYXBzaG90KHRoaXMuc3RhdGUpKTtcbiAgfVxuICBnZXRTdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZVNuYXBzaG90O1xuICB9XG4gIC8vIGltbXV0YWJsZSBjb250ZXh0IHZhbHVlXG4gIGdldCBjb250ZXh0U25hcHNob3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGVTbmFwc2hvdC5jb250ZXh0O1xuICB9XG4gIC8qKlxuICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgaW5zdGFuY2UgbWV0aG9kcyBvZiB0aGUgbWFjaGluZS5cbiAgICogVXNlZnVsIHdoZW4gc3Bhd25pbmcgY2hpbGQgbWFjaGluZXMgYW5kIG1hbmFnaW5nIHRoZSBjb21tdW5pY2F0aW9uIGJldHdlZW4gdGhlbS5cbiAgICovXG4gIGdldCBzZWxmKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiB7XG4gICAgICBpZDogdGhpcy5pZCxcbiAgICAgIHNlbmQ6IHRoaXMuc2VuZC5iaW5kKHRoaXMpLFxuICAgICAgc2VuZFBhcmVudDogdGhpcy5zZW5kUGFyZW50LmJpbmQodGhpcyksXG4gICAgICBzZW5kQ2hpbGQ6IHRoaXMuc2VuZENoaWxkLmJpbmQodGhpcyksXG4gICAgICBzdG9wOiB0aGlzLnN0b3AuYmluZCh0aGlzKSxcbiAgICAgIHN0b3BDaGlsZDogdGhpcy5zdG9wQ2hpbGQuYmluZCh0aGlzKSxcbiAgICAgIHNwYXduOiB0aGlzLnNwYXduLmJpbmQodGhpcyksXG4gICAgICBzdG9wQWN0aXZpdHk6IHRoaXMuc3RvcEFjdGl2aXR5LmJpbmQodGhpcyksXG4gICAgICBnZXQgc3RhdGUoKSB7XG4gICAgICAgIHJldHVybiBzZWxmLnN0YXRlU25hcHNob3Q7XG4gICAgICB9LFxuICAgICAgZ2V0IGluaXRpYWxDb250ZXh0KCkge1xuICAgICAgICByZXR1cm4gc2VsZi5pbml0aWFsQ29udGV4dDtcbiAgICAgIH0sXG4gICAgICBnZXQgaW5pdGlhbFN0YXRlKCkge1xuICAgICAgICByZXR1cm4gc2VsZi5pbml0aWFsU3RhdGU/LnRhcmdldCA/PyBcIlwiO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZ2V0IG1ldGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXRlOiB0aGlzLnN0YXRlU25hcHNob3QsXG4gICAgICBndWFyZHM6IHRoaXMuZ3VhcmRNYXAsXG4gICAgICBzZW5kOiB0aGlzLnNlbmQuYmluZCh0aGlzKSxcbiAgICAgIHNlbGY6IHRoaXMuc2VsZixcbiAgICAgIGluaXRpYWxDb250ZXh0OiB0aGlzLmluaXRpYWxDb250ZXh0LFxuICAgICAgaW5pdGlhbFN0YXRlOiB0aGlzLmluaXRpYWxTdGF0ZT8udGFyZ2V0ID8/IFwiXCIsXG4gICAgICBnZXRTdGF0ZTogKCkgPT4gdGhpcy5zdGF0ZVNuYXBzaG90LFxuICAgICAgZ2V0QWN0aW9uOiAoa2V5KSA9PiB0aGlzLmFjdGlvbk1hcFtrZXldLFxuICAgICAgZ2V0R3VhcmQ6IChrZXkpID0+IHRoaXMuZ3VhcmRNYXBba2V5XVxuICAgIH07XG4gIH1cbiAgZ2V0IGd1YXJkTWV0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhdGU6IHRoaXMuc3RhdGVTbmFwc2hvdFxuICAgIH07XG4gIH1cbiAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuICAgIHJldHVybiBcIk1hY2hpbmVcIjtcbiAgfVxuICBnZXRIeWRyYXRpb25TdGF0ZSgpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuZ2V0U3RhdGUoKTtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IHN0YXRlLnZhbHVlLFxuICAgICAgdGFnczogc3RhdGUudGFnc1xuICAgIH07XG4gIH1cbn07XG52YXIgY3JlYXRlTWFjaGluZSA9IChjb25maWcsIG9wdGlvbnMpID0+IG5ldyBNYWNoaW5lKGNvbmZpZywgb3B0aW9ucyk7XG52YXIgaXNNYWNoaW5lID0gKHZhbHVlKSA9PiB7XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIE1hY2hpbmUgfHwgdmFsdWU/LnR5cGUgPT09IFwibWFjaGluZVwiIC8qIE1hY2hpbmUgKi87XG59O1xuXG4vLyBzcmMvbWVyZ2UtcHJvcHMudHNcbnZhciBjbHN4ID0gKC4uLmFyZ3MpID0+IGFyZ3MubWFwKChzdHIpID0+IHN0cj8udHJpbT8uKCkpLmZpbHRlcihCb29sZWFuKS5qb2luKFwiIFwiKTtcbnZhciBDU1NfUkVHRVggPSAvKCg/Oi0tKT8oPzpcXHcrLT8pKylcXHMqOlxccyooW147XSopL2c7XG52YXIgc2VyaWFsaXplID0gKHN0eWxlKSA9PiB7XG4gIGNvbnN0IHJlcyA9IHt9O1xuICBsZXQgbWF0Y2g7XG4gIHdoaWxlIChtYXRjaCA9IENTU19SRUdFWC5leGVjKHN0eWxlKSkge1xuICAgIHJlc1ttYXRjaFsxXV0gPSBtYXRjaFsyXTtcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcbnZhciBjc3MgPSAoYSwgYikgPT4ge1xuICBpZiAoaXNTdHJpbmcoYSkpIHtcbiAgICBpZiAoaXNTdHJpbmcoYikpIHJldHVybiBgJHthfTske2J9YDtcbiAgICBhID0gc2VyaWFsaXplKGEpO1xuICB9IGVsc2UgaWYgKGlzU3RyaW5nKGIpKSB7XG4gICAgYiA9IHNlcmlhbGl6ZShiKTtcbiAgfVxuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgYSA/PyB7fSwgYiA/PyB7fSk7XG59O1xuZnVuY3Rpb24gbWVyZ2VQcm9wcyguLi5hcmdzKSB7XG4gIGxldCByZXN1bHQgPSB7fTtcbiAgZm9yIChsZXQgcHJvcHMgb2YgYXJncykge1xuICAgIGZvciAobGV0IGtleSBpbiByZXN1bHQpIHtcbiAgICAgIGlmIChrZXkuc3RhcnRzV2l0aChcIm9uXCIpICYmIHR5cGVvZiByZXN1bHRba2V5XSA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBwcm9wc1trZXldID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmVzdWx0W2tleV0gPSBjYWxsQWxsKHByb3BzW2tleV0sIHJlc3VsdFtrZXldKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoa2V5ID09PSBcImNsYXNzTmFtZVwiIHx8IGtleSA9PT0gXCJjbGFzc1wiKSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gY2xzeChyZXN1bHRba2V5XSwgcHJvcHNba2V5XSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGtleSA9PT0gXCJzdHlsZVwiKSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gY3NzKHJlc3VsdFtrZXldLCBwcm9wc1trZXldKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICByZXN1bHRba2V5XSA9IHByb3BzW2tleV0gIT09IHZvaWQgMCA/IHByb3BzW2tleV0gOiByZXN1bHRba2V5XTtcbiAgICB9XG4gICAgZm9yIChsZXQga2V5IGluIHByb3BzKSB7XG4gICAgICBpZiAocmVzdWx0W2tleV0gPT09IHZvaWQgMCkge1xuICAgICAgICByZXN1bHRba2V5XSA9IHByb3BzW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnQge1xuICBNYWNoaW5lLFxuICBjaG9vc2UsXG4gIGNyZWF0ZU1hY2hpbmUsXG4gIGRlZXBNZXJnZSxcbiAgZ3VhcmRzLFxuICBpc01hY2hpbmUsXG4gIG1lcmdlUHJvcHMsXG4gIHByb3h5MiBhcyBwcm94eSxcbiAgcmVmMiBhcyByZWYsXG4gIHNuYXBzaG90MiBhcyBzbmFwc2hvdCxcbiAgc3Vic2NyaWJlMiBhcyBzdWJzY3JpYmVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@zag-js/core/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@zag-js/dom-event/dist/index.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/@zag-js/dom-event/dist/index.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addDomEvent: () => (/* binding */ addDomEvent),\n/* harmony export */   clickIfLink: () => (/* binding */ clickIfLink),\n/* harmony export */   fireBlurEvent: () => (/* binding */ fireBlurEvent),\n/* harmony export */   fireCustomEvent: () => (/* binding */ fireCustomEvent),\n/* harmony export */   getEventKey: () => (/* binding */ getEventKey),\n/* harmony export */   getEventPoint: () => (/* binding */ getEventPoint),\n/* harmony export */   getEventStep: () => (/* binding */ getEventStep),\n/* harmony export */   getNativeEvent: () => (/* binding */ getNativeEvent),\n/* harmony export */   getRelativePoint: () => (/* binding */ getRelativePoint),\n/* harmony export */   isContextMenuEvent: () => (/* binding */ isContextMenuEvent),\n/* harmony export */   isKeyboardClick: () => (/* binding */ isKeyboardClick),\n/* harmony export */   isLeftClick: () => (/* binding */ isLeftClick),\n/* harmony export */   isModifierKey: () => (/* binding */ isModifierKey),\n/* harmony export */   isPrintableKey: () => (/* binding */ isPrintableKey),\n/* harmony export */   isVirtualClick: () => (/* binding */ isVirtualClick),\n/* harmony export */   isVirtualPointerEvent: () => (/* binding */ isVirtualPointerEvent),\n/* harmony export */   queueBeforeEvent: () => (/* binding */ queueBeforeEvent),\n/* harmony export */   requestPointerLock: () => (/* binding */ requestPointerLock),\n/* harmony export */   trackFocusVisible: () => (/* binding */ trackFocusVisible),\n/* harmony export */   trackPointerMove: () => (/* binding */ trackPointerMove),\n/* harmony export */   trackPress: () => (/* binding */ trackPress),\n/* harmony export */   trackVisualViewport: () => (/* binding */ trackVisualViewport)\n/* harmony export */ });\n/* harmony import */ var _zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @zag-js/dom-query */ \"(ssr)/./node_modules/@zag-js/dom-query/dist/index.mjs\");\n/* harmony import */ var _zag_js_text_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @zag-js/text-selection */ \"(ssr)/./node_modules/@zag-js/text-selection/dist/index.mjs\");\n// src/add-dom-event.ts\nvar addDomEvent = (target, eventName, handler, options) => {\n  const node = typeof target === \"function\" ? target() : target;\n  node?.addEventListener(eventName, handler, options);\n  return () => {\n    node?.removeEventListener(eventName, handler, options);\n  };\n};\n\n// src/assertion.ts\n\nfunction isKeyboardClick(e) {\n  return e.detail === 0 || e.clientX === 0 && e.clientY === 0;\n}\nfunction isPrintableKey(e) {\n  return e.key.length === 1 && !e.ctrlKey && !e.metaKey;\n}\nfunction isVirtualPointerEvent(e) {\n  return e.width === 0 && e.height === 0 || e.width === 1 && e.height === 1 && e.pressure === 0 && e.detail === 0 && e.pointerType === \"mouse\";\n}\nfunction isVirtualClick(e) {\n  if (e.mozInputSource === 0 && e.isTrusted) return true;\n  return e.detail === 0 && !e.pointerType;\n}\nvar isLeftClick = (e) => e.button === 0;\nvar isContextMenuEvent = (e) => {\n  return e.button === 2 || (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.isMac)() && e.ctrlKey && e.button === 0;\n};\nvar isModifierKey = (e) => e.ctrlKey || e.altKey || e.metaKey;\n\n// src/click-link.ts\n\n\n// src/queue-before-event.ts\nfunction queueBeforeEvent(element, type, cb) {\n  const createTimer = (callback) => {\n    const timerId = requestAnimationFrame(callback);\n    return () => cancelAnimationFrame(timerId);\n  };\n  const cancelTimer = createTimer(() => {\n    element.removeEventListener(type, callSync, true);\n    cb();\n  });\n  const callSync = () => {\n    cancelTimer();\n    cb();\n  };\n  element.addEventListener(type, callSync, { once: true, capture: true });\n  return cancelTimer;\n}\n\n// src/click-link.ts\nfunction isLinkElement(element) {\n  return element?.matches(\"a[href]\") ?? false;\n}\nfunction clickIfLink(element) {\n  if (!isLinkElement(element)) return;\n  const click = () => element.click();\n  if ((0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.isFirefox)()) {\n    queueBeforeEvent(element, \"keyup\", click);\n  } else {\n    queueMicrotask(click);\n  }\n}\n\n// src/fire-event.ts\nfunction fireCustomEvent(el, type, init) {\n  if (!el) return;\n  const win = el.ownerDocument.defaultView || window;\n  const event = new win.CustomEvent(type, init);\n  return el.dispatchEvent(event);\n}\nfunction fireBlurEvent(el, init) {\n  const win = el.ownerDocument.defaultView || window;\n  const event = new win.FocusEvent(\"blur\", init);\n  const allowed = el.dispatchEvent(event);\n  const bubbleInit = { ...init, bubbles: true };\n  el.dispatchEvent(new win.FocusEvent(\"focusout\", bubbleInit));\n  return allowed;\n}\n\n// src/get-event-key.ts\nvar keyMap = {\n  Up: \"ArrowUp\",\n  Down: \"ArrowDown\",\n  Esc: \"Escape\",\n  \" \": \"Space\",\n  \",\": \"Comma\",\n  Left: \"ArrowLeft\",\n  Right: \"ArrowRight\"\n};\nvar rtlKeyMap = {\n  ArrowLeft: \"ArrowRight\",\n  ArrowRight: \"ArrowLeft\"\n};\nfunction getEventKey(event, options = {}) {\n  const { dir = \"ltr\", orientation = \"horizontal\" } = options;\n  let { key } = event;\n  key = keyMap[key] ?? key;\n  const isRtl = dir === \"rtl\" && orientation === \"horizontal\";\n  if (isRtl && key in rtlKeyMap) {\n    key = rtlKeyMap[key];\n  }\n  return key;\n}\n\n// src/get-event-point.ts\nfunction pointFromTouch(e, type = \"client\") {\n  const point = e.touches[0] || e.changedTouches[0];\n  return { x: point[`${type}X`], y: point[`${type}Y`] };\n}\nfunction pointFromMouse(point, type = \"client\") {\n  return { x: point[`${type}X`], y: point[`${type}Y`] };\n}\nvar isTouchEvent = (event) => \"touches\" in event && event.touches.length > 0;\nfunction getEventPoint(event, type = \"client\") {\n  return isTouchEvent(event) ? pointFromTouch(event, type) : pointFromMouse(event, type);\n}\n\n// src/get-event-step.ts\nvar PAGE_KEYS = /* @__PURE__ */ new Set([\"PageUp\", \"PageDown\"]);\nvar ARROW_KEYS = /* @__PURE__ */ new Set([\"ArrowUp\", \"ArrowDown\", \"ArrowLeft\", \"ArrowRight\"]);\nfunction getEventStep(event) {\n  if (event.ctrlKey || event.metaKey) {\n    return 0.1;\n  } else {\n    const isPageKey = PAGE_KEYS.has(event.key);\n    const isSkipKey = isPageKey || event.shiftKey && ARROW_KEYS.has(event.key);\n    return isSkipKey ? 10 : 1;\n  }\n}\n\n// src/get-native-event.ts\nfunction getNativeEvent(event) {\n  return event.nativeEvent ?? event;\n}\n\n// src/get-point-value.ts\nfunction clamp(value) {\n  return Math.max(0, Math.min(1, value));\n}\nfunction getRelativePoint(point, element) {\n  const { left, top, width, height } = element.getBoundingClientRect();\n  const offset = { x: point.x - left, y: point.y - top };\n  const percent = { x: clamp(offset.x / width), y: clamp(offset.y / height) };\n  function getPercentValue(options = {}) {\n    const { dir = \"ltr\", orientation = \"horizontal\", inverted } = options;\n    const invertX = typeof inverted === \"object\" ? inverted.x : inverted;\n    const invertY = typeof inverted === \"object\" ? inverted.y : inverted;\n    if (orientation === \"horizontal\") {\n      return dir === \"rtl\" || invertX ? 1 - percent.x : percent.x;\n    }\n    return invertY ? 1 - percent.y : percent.y;\n  }\n  return { offset, percent, getPercentValue };\n}\n\n// src/request-pointer-lock.ts\nfunction requestPointerLock(doc, fn) {\n  const body = doc.body;\n  const supported = \"pointerLockElement\" in doc || \"mozPointerLockElement\" in doc;\n  const isLocked = () => !!doc.pointerLockElement;\n  function onPointerChange() {\n    fn?.(isLocked());\n  }\n  function onPointerError(event) {\n    if (isLocked()) fn?.(false);\n    console.error(\"PointerLock error occured:\", event);\n    doc.exitPointerLock();\n  }\n  if (!supported) return;\n  try {\n    body.requestPointerLock();\n  } catch {\n  }\n  const cleanup = [\n    addDomEvent(doc, \"pointerlockchange\", onPointerChange, false),\n    addDomEvent(doc, \"pointerlockerror\", onPointerError, false)\n  ];\n  return () => {\n    cleanup.forEach((cleanup2) => cleanup2());\n    doc.exitPointerLock();\n  };\n}\n\n// src/track-focus-visible.ts\n\n\n// src/pipe.ts\nvar pipe = (...fns) => (arg) => fns.reduce((acc, fn) => fn(acc), arg);\nvar noop = () => void 0;\n\n// src/track-focus-visible.ts\nvar isValidKey = (e) => {\n  return !(e.metaKey || !(0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.isMac)() && e.altKey || e.ctrlKey || e.key === \"Control\" || e.key === \"Shift\" || e.key === \"Meta\");\n};\nfunction trackFocusVisible(node, options) {\n  if (!node) return;\n  const { onFocus, onBlur } = options;\n  const win = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.getWindow)(node);\n  let focused = false;\n  const handleFocus = (e) => {\n    let isFocusVisible = false;\n    try {\n      isFocusVisible = node.matches(\":focus-visible\");\n    } catch {\n      isFocusVisible = true;\n    }\n    if (!isFocusVisible) return;\n    focused = true;\n    onFocus?.(e);\n  };\n  const handleBlur = (e) => {\n    if (!focused) return;\n    focused = false;\n    onBlur?.(e);\n  };\n  const handleKeydown = (e) => {\n    if (!node.matches(\":focus\") || !isValidKey(e)) return;\n    focused = true;\n    const evt = new win.FocusEvent(\"focus\");\n    onFocus?.(evt);\n  };\n  return pipe(\n    addDomEvent(node, \"focusin\", handleFocus),\n    addDomEvent(node, \"focusout\", handleBlur),\n    addDomEvent(node, \"keydown\", handleKeydown, true)\n  );\n}\n\n// src/track-pointer-move.ts\n\nfunction trackPointerMove(doc, handlers) {\n  const { onPointerMove, onPointerUp } = handlers;\n  const history = [];\n  const handleMove = (event) => {\n    const point = getEventPoint(event);\n    history.push({ ...point, timestamp: performance.now() });\n    const distance = Math.sqrt(point.x ** 2 + point.y ** 2);\n    const moveBuffer = event.pointerType === \"touch\" ? 10 : 5;\n    if (distance < moveBuffer) return;\n    if (event.pointerType === \"mouse\" && event.button === 0) {\n      onPointerUp();\n      return;\n    }\n    onPointerMove({ point, event, velocity: getVelocity(history, 0.1) });\n  };\n  const cleanups = [\n    addDomEvent(doc, \"pointermove\", handleMove, false),\n    addDomEvent(doc, \"pointerup\", onPointerUp, false),\n    addDomEvent(doc, \"pointercancel\", onPointerUp, false),\n    addDomEvent(doc, \"contextmenu\", onPointerUp, false),\n    (0,_zag_js_text_selection__WEBPACK_IMPORTED_MODULE_1__.disableTextSelection)({ doc })\n  ];\n  return () => {\n    cleanups.forEach((cleanup) => cleanup());\n    history.length = 0;\n  };\n}\nfunction lastDevicePoint(history) {\n  return history[history.length - 1];\n}\nfunction ms(seconds) {\n  return seconds * 1e3;\n}\nfunction sec(milliseconds) {\n  return milliseconds / 1e3;\n}\nfunction getVelocity(history, timeDelta) {\n  if (history.length < 2) return { x: 0, y: 0 };\n  let i = history.length - 1;\n  let timestampedPoint = null;\n  const lastPoint = lastDevicePoint(history);\n  while (i >= 0) {\n    timestampedPoint = history[i];\n    if (lastPoint.timestamp - timestampedPoint.timestamp > ms(timeDelta)) {\n      break;\n    }\n    i--;\n  }\n  if (!timestampedPoint) return { x: 0, y: 0 };\n  const time = sec(lastPoint.timestamp - timestampedPoint.timestamp);\n  if (time === 0) return { x: 0, y: 0 };\n  const currentVelocity = {\n    x: (lastPoint.x - timestampedPoint.x) / time,\n    y: (lastPoint.y - timestampedPoint.y) / time\n  };\n  if (currentVelocity.x === Infinity) currentVelocity.x = 0;\n  if (currentVelocity.y === Infinity) currentVelocity.y = 0;\n  return {\n    x: Math.abs(currentVelocity.x),\n    y: Math.abs(currentVelocity.y)\n  };\n}\n\n// src/track-press.ts\n\nfunction trackPress(options) {\n  const {\n    pointerNode,\n    keyboardNode = pointerNode,\n    onPress,\n    onPressStart,\n    onPressEnd,\n    isValidKey: isValidKey2 = (e) => e.key === \"Enter\"\n  } = options;\n  if (!pointerNode) return noop;\n  const win = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.getWindow)(pointerNode);\n  const doc = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.getDocument)(pointerNode);\n  let removeStartListeners = noop;\n  let removeEndListeners = noop;\n  let removeAccessibleListeners = noop;\n  const getInfo = (event) => ({\n    point: getEventPoint(event),\n    event\n  });\n  function startPress(event) {\n    onPressStart?.(getInfo(event));\n  }\n  function cancelPress(event) {\n    onPressEnd?.(getInfo(event));\n  }\n  const startPointerPress = (startEvent) => {\n    removeEndListeners();\n    const endPointerPress = (endEvent) => {\n      const target = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.getEventTarget)(endEvent);\n      if ((0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.contains)(pointerNode, target)) {\n        onPress?.(getInfo(endEvent));\n      } else {\n        onPressEnd?.(getInfo(endEvent));\n      }\n    };\n    const removePointerUpListener = addDomEvent(win, \"pointerup\", endPointerPress, { passive: !onPress });\n    const removePointerCancelListener = addDomEvent(win, \"pointercancel\", cancelPress, { passive: !onPressEnd });\n    removeEndListeners = pipe(removePointerUpListener, removePointerCancelListener);\n    if (doc.activeElement === keyboardNode && startEvent.pointerType === \"mouse\") {\n      startEvent.preventDefault();\n    }\n    startPress(startEvent);\n  };\n  const removePointerListener = addDomEvent(pointerNode, \"pointerdown\", startPointerPress, { passive: !onPressStart });\n  const removeFocusListener = addDomEvent(keyboardNode, \"focus\", startAccessiblePress);\n  removeStartListeners = pipe(removePointerListener, removeFocusListener);\n  function startAccessiblePress() {\n    const handleKeydown = (keydownEvent) => {\n      if (!isValidKey2(keydownEvent)) return;\n      const handleKeyup = (keyupEvent) => {\n        if (!isValidKey2(keyupEvent)) return;\n        const evt2 = new win.PointerEvent(\"pointerup\");\n        const info = getInfo(evt2);\n        onPress?.(info);\n        onPressEnd?.(info);\n      };\n      removeEndListeners();\n      removeEndListeners = addDomEvent(keyboardNode, \"keyup\", handleKeyup);\n      const evt = new win.PointerEvent(\"pointerdown\");\n      startPress(evt);\n    };\n    const handleBlur = () => {\n      const evt = new win.PointerEvent(\"pointercancel\");\n      cancelPress(evt);\n    };\n    const removeKeydownListener = addDomEvent(keyboardNode, \"keydown\", handleKeydown);\n    const removeBlurListener = addDomEvent(keyboardNode, \"blur\", handleBlur);\n    removeAccessibleListeners = pipe(removeKeydownListener, removeBlurListener);\n  }\n  return function() {\n    removeStartListeners();\n    removeEndListeners();\n    removeAccessibleListeners();\n  };\n}\n\n// src/track-visual-viewport.ts\nfunction trackVisualViewport(doc, fn) {\n  const win = doc?.defaultView || window;\n  const onResize = () => {\n    fn?.(getViewportSize(win));\n  };\n  onResize();\n  return addDomEvent(win.visualViewport ?? win, \"resize\", onResize);\n}\nfunction getViewportSize(win) {\n  return {\n    width: win.visualViewport?.width || win.innerWidth,\n    height: win.visualViewport?.height || win.innerHeight\n  };\n}\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHphZy1qcy9kb20tZXZlbnQvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUMwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsd0RBQUs7QUFDaEM7QUFDQTs7QUFFQTtBQUM4Qzs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLDJCQUEyQjtBQUN4RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSw0REFBUztBQUNmO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDLFVBQVUsMENBQTBDO0FBQ3BELFFBQVEsTUFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWSxLQUFLLGlCQUFpQixLQUFLO0FBQ2xEO0FBQ0E7QUFDQSxXQUFXLFlBQVksS0FBSyxpQkFBaUIsS0FBSztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDJCQUEyQjtBQUNyQyxtQkFBbUI7QUFDbkIsb0JBQW9CO0FBQ3BCLHVDQUF1QztBQUN2QyxZQUFZLG9EQUFvRDtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUMrRDs7QUFFL0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5QkFBeUIsd0RBQU07QUFDL0I7QUFDQTtBQUNBO0FBQ0EsVUFBVSxrQkFBa0I7QUFDNUIsY0FBYyw0REFBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDOEQ7QUFDOUQ7QUFDQSxVQUFVLDZCQUE2QjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsd0NBQXdDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1EQUFtRDtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDRFQUFvQixHQUFHLEtBQUs7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNtRztBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsY0FBYyw0REFBVTtBQUN4QixjQUFjLDhEQUFXO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsaUVBQWM7QUFDbkMsVUFBVSwyREFBUTtBQUNsQjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxxRkFBcUYsbUJBQW1CO0FBQ3hHLHlGQUF5RixzQkFBc0I7QUFDL0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkZBQTZGLHdCQUF3QjtBQUNySDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF3QkU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3NpdGVzLy4vbm9kZV9tb2R1bGVzL0B6YWctanMvZG9tLWV2ZW50L2Rpc3QvaW5kZXgubWpzPzBlNDAiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2FkZC1kb20tZXZlbnQudHNcbnZhciBhZGREb21FdmVudCA9ICh0YXJnZXQsIGV2ZW50TmFtZSwgaGFuZGxlciwgb3B0aW9ucykgPT4ge1xuICBjb25zdCBub2RlID0gdHlwZW9mIHRhcmdldCA9PT0gXCJmdW5jdGlvblwiID8gdGFyZ2V0KCkgOiB0YXJnZXQ7XG4gIG5vZGU/LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBub2RlPy5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlciwgb3B0aW9ucyk7XG4gIH07XG59O1xuXG4vLyBzcmMvYXNzZXJ0aW9uLnRzXG5pbXBvcnQgeyBpc01hYyB9IGZyb20gXCJAemFnLWpzL2RvbS1xdWVyeVwiO1xuZnVuY3Rpb24gaXNLZXlib2FyZENsaWNrKGUpIHtcbiAgcmV0dXJuIGUuZGV0YWlsID09PSAwIHx8IGUuY2xpZW50WCA9PT0gMCAmJiBlLmNsaWVudFkgPT09IDA7XG59XG5mdW5jdGlvbiBpc1ByaW50YWJsZUtleShlKSB7XG4gIHJldHVybiBlLmtleS5sZW5ndGggPT09IDEgJiYgIWUuY3RybEtleSAmJiAhZS5tZXRhS2V5O1xufVxuZnVuY3Rpb24gaXNWaXJ0dWFsUG9pbnRlckV2ZW50KGUpIHtcbiAgcmV0dXJuIGUud2lkdGggPT09IDAgJiYgZS5oZWlnaHQgPT09IDAgfHwgZS53aWR0aCA9PT0gMSAmJiBlLmhlaWdodCA9PT0gMSAmJiBlLnByZXNzdXJlID09PSAwICYmIGUuZGV0YWlsID09PSAwICYmIGUucG9pbnRlclR5cGUgPT09IFwibW91c2VcIjtcbn1cbmZ1bmN0aW9uIGlzVmlydHVhbENsaWNrKGUpIHtcbiAgaWYgKGUubW96SW5wdXRTb3VyY2UgPT09IDAgJiYgZS5pc1RydXN0ZWQpIHJldHVybiB0cnVlO1xuICByZXR1cm4gZS5kZXRhaWwgPT09IDAgJiYgIWUucG9pbnRlclR5cGU7XG59XG52YXIgaXNMZWZ0Q2xpY2sgPSAoZSkgPT4gZS5idXR0b24gPT09IDA7XG52YXIgaXNDb250ZXh0TWVudUV2ZW50ID0gKGUpID0+IHtcbiAgcmV0dXJuIGUuYnV0dG9uID09PSAyIHx8IGlzTWFjKCkgJiYgZS5jdHJsS2V5ICYmIGUuYnV0dG9uID09PSAwO1xufTtcbnZhciBpc01vZGlmaWVyS2V5ID0gKGUpID0+IGUuY3RybEtleSB8fCBlLmFsdEtleSB8fCBlLm1ldGFLZXk7XG5cbi8vIHNyYy9jbGljay1saW5rLnRzXG5pbXBvcnQgeyBpc0ZpcmVmb3ggfSBmcm9tIFwiQHphZy1qcy9kb20tcXVlcnlcIjtcblxuLy8gc3JjL3F1ZXVlLWJlZm9yZS1ldmVudC50c1xuZnVuY3Rpb24gcXVldWVCZWZvcmVFdmVudChlbGVtZW50LCB0eXBlLCBjYikge1xuICBjb25zdCBjcmVhdGVUaW1lciA9IChjYWxsYmFjaykgPT4ge1xuICAgIGNvbnN0IHRpbWVySWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2FsbGJhY2spO1xuICAgIHJldHVybiAoKSA9PiBjYW5jZWxBbmltYXRpb25GcmFtZSh0aW1lcklkKTtcbiAgfTtcbiAgY29uc3QgY2FuY2VsVGltZXIgPSBjcmVhdGVUaW1lcigoKSA9PiB7XG4gICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGNhbGxTeW5jLCB0cnVlKTtcbiAgICBjYigpO1xuICB9KTtcbiAgY29uc3QgY2FsbFN5bmMgPSAoKSA9PiB7XG4gICAgY2FuY2VsVGltZXIoKTtcbiAgICBjYigpO1xuICB9O1xuICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgY2FsbFN5bmMsIHsgb25jZTogdHJ1ZSwgY2FwdHVyZTogdHJ1ZSB9KTtcbiAgcmV0dXJuIGNhbmNlbFRpbWVyO1xufVxuXG4vLyBzcmMvY2xpY2stbGluay50c1xuZnVuY3Rpb24gaXNMaW5rRWxlbWVudChlbGVtZW50KSB7XG4gIHJldHVybiBlbGVtZW50Py5tYXRjaGVzKFwiYVtocmVmXVwiKSA/PyBmYWxzZTtcbn1cbmZ1bmN0aW9uIGNsaWNrSWZMaW5rKGVsZW1lbnQpIHtcbiAgaWYgKCFpc0xpbmtFbGVtZW50KGVsZW1lbnQpKSByZXR1cm47XG4gIGNvbnN0IGNsaWNrID0gKCkgPT4gZWxlbWVudC5jbGljaygpO1xuICBpZiAoaXNGaXJlZm94KCkpIHtcbiAgICBxdWV1ZUJlZm9yZUV2ZW50KGVsZW1lbnQsIFwia2V5dXBcIiwgY2xpY2spO1xuICB9IGVsc2Uge1xuICAgIHF1ZXVlTWljcm90YXNrKGNsaWNrKTtcbiAgfVxufVxuXG4vLyBzcmMvZmlyZS1ldmVudC50c1xuZnVuY3Rpb24gZmlyZUN1c3RvbUV2ZW50KGVsLCB0eXBlLCBpbml0KSB7XG4gIGlmICghZWwpIHJldHVybjtcbiAgY29uc3Qgd2luID0gZWwub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyB8fCB3aW5kb3c7XG4gIGNvbnN0IGV2ZW50ID0gbmV3IHdpbi5DdXN0b21FdmVudCh0eXBlLCBpbml0KTtcbiAgcmV0dXJuIGVsLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xufVxuZnVuY3Rpb24gZmlyZUJsdXJFdmVudChlbCwgaW5pdCkge1xuICBjb25zdCB3aW4gPSBlbC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IHx8IHdpbmRvdztcbiAgY29uc3QgZXZlbnQgPSBuZXcgd2luLkZvY3VzRXZlbnQoXCJibHVyXCIsIGluaXQpO1xuICBjb25zdCBhbGxvd2VkID0gZWwuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gIGNvbnN0IGJ1YmJsZUluaXQgPSB7IC4uLmluaXQsIGJ1YmJsZXM6IHRydWUgfTtcbiAgZWwuZGlzcGF0Y2hFdmVudChuZXcgd2luLkZvY3VzRXZlbnQoXCJmb2N1c291dFwiLCBidWJibGVJbml0KSk7XG4gIHJldHVybiBhbGxvd2VkO1xufVxuXG4vLyBzcmMvZ2V0LWV2ZW50LWtleS50c1xudmFyIGtleU1hcCA9IHtcbiAgVXA6IFwiQXJyb3dVcFwiLFxuICBEb3duOiBcIkFycm93RG93blwiLFxuICBFc2M6IFwiRXNjYXBlXCIsXG4gIFwiIFwiOiBcIlNwYWNlXCIsXG4gIFwiLFwiOiBcIkNvbW1hXCIsXG4gIExlZnQ6IFwiQXJyb3dMZWZ0XCIsXG4gIFJpZ2h0OiBcIkFycm93UmlnaHRcIlxufTtcbnZhciBydGxLZXlNYXAgPSB7XG4gIEFycm93TGVmdDogXCJBcnJvd1JpZ2h0XCIsXG4gIEFycm93UmlnaHQ6IFwiQXJyb3dMZWZ0XCJcbn07XG5mdW5jdGlvbiBnZXRFdmVudEtleShldmVudCwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHsgZGlyID0gXCJsdHJcIiwgb3JpZW50YXRpb24gPSBcImhvcml6b250YWxcIiB9ID0gb3B0aW9ucztcbiAgbGV0IHsga2V5IH0gPSBldmVudDtcbiAga2V5ID0ga2V5TWFwW2tleV0gPz8ga2V5O1xuICBjb25zdCBpc1J0bCA9IGRpciA9PT0gXCJydGxcIiAmJiBvcmllbnRhdGlvbiA9PT0gXCJob3Jpem9udGFsXCI7XG4gIGlmIChpc1J0bCAmJiBrZXkgaW4gcnRsS2V5TWFwKSB7XG4gICAga2V5ID0gcnRsS2V5TWFwW2tleV07XG4gIH1cbiAgcmV0dXJuIGtleTtcbn1cblxuLy8gc3JjL2dldC1ldmVudC1wb2ludC50c1xuZnVuY3Rpb24gcG9pbnRGcm9tVG91Y2goZSwgdHlwZSA9IFwiY2xpZW50XCIpIHtcbiAgY29uc3QgcG9pbnQgPSBlLnRvdWNoZXNbMF0gfHwgZS5jaGFuZ2VkVG91Y2hlc1swXTtcbiAgcmV0dXJuIHsgeDogcG9pbnRbYCR7dHlwZX1YYF0sIHk6IHBvaW50W2Ake3R5cGV9WWBdIH07XG59XG5mdW5jdGlvbiBwb2ludEZyb21Nb3VzZShwb2ludCwgdHlwZSA9IFwiY2xpZW50XCIpIHtcbiAgcmV0dXJuIHsgeDogcG9pbnRbYCR7dHlwZX1YYF0sIHk6IHBvaW50W2Ake3R5cGV9WWBdIH07XG59XG52YXIgaXNUb3VjaEV2ZW50ID0gKGV2ZW50KSA9PiBcInRvdWNoZXNcIiBpbiBldmVudCAmJiBldmVudC50b3VjaGVzLmxlbmd0aCA+IDA7XG5mdW5jdGlvbiBnZXRFdmVudFBvaW50KGV2ZW50LCB0eXBlID0gXCJjbGllbnRcIikge1xuICByZXR1cm4gaXNUb3VjaEV2ZW50KGV2ZW50KSA/IHBvaW50RnJvbVRvdWNoKGV2ZW50LCB0eXBlKSA6IHBvaW50RnJvbU1vdXNlKGV2ZW50LCB0eXBlKTtcbn1cblxuLy8gc3JjL2dldC1ldmVudC1zdGVwLnRzXG52YXIgUEFHRV9LRVlTID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1wiUGFnZVVwXCIsIFwiUGFnZURvd25cIl0pO1xudmFyIEFSUk9XX0tFWVMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXCJBcnJvd1VwXCIsIFwiQXJyb3dEb3duXCIsIFwiQXJyb3dMZWZ0XCIsIFwiQXJyb3dSaWdodFwiXSk7XG5mdW5jdGlvbiBnZXRFdmVudFN0ZXAoZXZlbnQpIHtcbiAgaWYgKGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSkge1xuICAgIHJldHVybiAwLjE7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgaXNQYWdlS2V5ID0gUEFHRV9LRVlTLmhhcyhldmVudC5rZXkpO1xuICAgIGNvbnN0IGlzU2tpcEtleSA9IGlzUGFnZUtleSB8fCBldmVudC5zaGlmdEtleSAmJiBBUlJPV19LRVlTLmhhcyhldmVudC5rZXkpO1xuICAgIHJldHVybiBpc1NraXBLZXkgPyAxMCA6IDE7XG4gIH1cbn1cblxuLy8gc3JjL2dldC1uYXRpdmUtZXZlbnQudHNcbmZ1bmN0aW9uIGdldE5hdGl2ZUV2ZW50KGV2ZW50KSB7XG4gIHJldHVybiBldmVudC5uYXRpdmVFdmVudCA/PyBldmVudDtcbn1cblxuLy8gc3JjL2dldC1wb2ludC12YWx1ZS50c1xuZnVuY3Rpb24gY2xhbXAodmFsdWUpIHtcbiAgcmV0dXJuIE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHZhbHVlKSk7XG59XG5mdW5jdGlvbiBnZXRSZWxhdGl2ZVBvaW50KHBvaW50LCBlbGVtZW50KSB7XG4gIGNvbnN0IHsgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0IH0gPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBjb25zdCBvZmZzZXQgPSB7IHg6IHBvaW50LnggLSBsZWZ0LCB5OiBwb2ludC55IC0gdG9wIH07XG4gIGNvbnN0IHBlcmNlbnQgPSB7IHg6IGNsYW1wKG9mZnNldC54IC8gd2lkdGgpLCB5OiBjbGFtcChvZmZzZXQueSAvIGhlaWdodCkgfTtcbiAgZnVuY3Rpb24gZ2V0UGVyY2VudFZhbHVlKG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgZGlyID0gXCJsdHJcIiwgb3JpZW50YXRpb24gPSBcImhvcml6b250YWxcIiwgaW52ZXJ0ZWQgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgaW52ZXJ0WCA9IHR5cGVvZiBpbnZlcnRlZCA9PT0gXCJvYmplY3RcIiA/IGludmVydGVkLnggOiBpbnZlcnRlZDtcbiAgICBjb25zdCBpbnZlcnRZID0gdHlwZW9mIGludmVydGVkID09PSBcIm9iamVjdFwiID8gaW52ZXJ0ZWQueSA6IGludmVydGVkO1xuICAgIGlmIChvcmllbnRhdGlvbiA9PT0gXCJob3Jpem9udGFsXCIpIHtcbiAgICAgIHJldHVybiBkaXIgPT09IFwicnRsXCIgfHwgaW52ZXJ0WCA/IDEgLSBwZXJjZW50LnggOiBwZXJjZW50Lng7XG4gICAgfVxuICAgIHJldHVybiBpbnZlcnRZID8gMSAtIHBlcmNlbnQueSA6IHBlcmNlbnQueTtcbiAgfVxuICByZXR1cm4geyBvZmZzZXQsIHBlcmNlbnQsIGdldFBlcmNlbnRWYWx1ZSB9O1xufVxuXG4vLyBzcmMvcmVxdWVzdC1wb2ludGVyLWxvY2sudHNcbmZ1bmN0aW9uIHJlcXVlc3RQb2ludGVyTG9jayhkb2MsIGZuKSB7XG4gIGNvbnN0IGJvZHkgPSBkb2MuYm9keTtcbiAgY29uc3Qgc3VwcG9ydGVkID0gXCJwb2ludGVyTG9ja0VsZW1lbnRcIiBpbiBkb2MgfHwgXCJtb3pQb2ludGVyTG9ja0VsZW1lbnRcIiBpbiBkb2M7XG4gIGNvbnN0IGlzTG9ja2VkID0gKCkgPT4gISFkb2MucG9pbnRlckxvY2tFbGVtZW50O1xuICBmdW5jdGlvbiBvblBvaW50ZXJDaGFuZ2UoKSB7XG4gICAgZm4/Lihpc0xvY2tlZCgpKTtcbiAgfVxuICBmdW5jdGlvbiBvblBvaW50ZXJFcnJvcihldmVudCkge1xuICAgIGlmIChpc0xvY2tlZCgpKSBmbj8uKGZhbHNlKTtcbiAgICBjb25zb2xlLmVycm9yKFwiUG9pbnRlckxvY2sgZXJyb3Igb2NjdXJlZDpcIiwgZXZlbnQpO1xuICAgIGRvYy5leGl0UG9pbnRlckxvY2soKTtcbiAgfVxuICBpZiAoIXN1cHBvcnRlZCkgcmV0dXJuO1xuICB0cnkge1xuICAgIGJvZHkucmVxdWVzdFBvaW50ZXJMb2NrKCk7XG4gIH0gY2F0Y2gge1xuICB9XG4gIGNvbnN0IGNsZWFudXAgPSBbXG4gICAgYWRkRG9tRXZlbnQoZG9jLCBcInBvaW50ZXJsb2NrY2hhbmdlXCIsIG9uUG9pbnRlckNoYW5nZSwgZmFsc2UpLFxuICAgIGFkZERvbUV2ZW50KGRvYywgXCJwb2ludGVybG9ja2Vycm9yXCIsIG9uUG9pbnRlckVycm9yLCBmYWxzZSlcbiAgXTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBjbGVhbnVwLmZvckVhY2goKGNsZWFudXAyKSA9PiBjbGVhbnVwMigpKTtcbiAgICBkb2MuZXhpdFBvaW50ZXJMb2NrKCk7XG4gIH07XG59XG5cbi8vIHNyYy90cmFjay1mb2N1cy12aXNpYmxlLnRzXG5pbXBvcnQgeyBnZXRXaW5kb3csIGlzTWFjIGFzIGlzTWFjMiB9IGZyb20gXCJAemFnLWpzL2RvbS1xdWVyeVwiO1xuXG4vLyBzcmMvcGlwZS50c1xudmFyIHBpcGUgPSAoLi4uZm5zKSA9PiAoYXJnKSA9PiBmbnMucmVkdWNlKChhY2MsIGZuKSA9PiBmbihhY2MpLCBhcmcpO1xudmFyIG5vb3AgPSAoKSA9PiB2b2lkIDA7XG5cbi8vIHNyYy90cmFjay1mb2N1cy12aXNpYmxlLnRzXG52YXIgaXNWYWxpZEtleSA9IChlKSA9PiB7XG4gIHJldHVybiAhKGUubWV0YUtleSB8fCAhaXNNYWMyKCkgJiYgZS5hbHRLZXkgfHwgZS5jdHJsS2V5IHx8IGUua2V5ID09PSBcIkNvbnRyb2xcIiB8fCBlLmtleSA9PT0gXCJTaGlmdFwiIHx8IGUua2V5ID09PSBcIk1ldGFcIik7XG59O1xuZnVuY3Rpb24gdHJhY2tGb2N1c1Zpc2libGUobm9kZSwgb3B0aW9ucykge1xuICBpZiAoIW5vZGUpIHJldHVybjtcbiAgY29uc3QgeyBvbkZvY3VzLCBvbkJsdXIgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHdpbiA9IGdldFdpbmRvdyhub2RlKTtcbiAgbGV0IGZvY3VzZWQgPSBmYWxzZTtcbiAgY29uc3QgaGFuZGxlRm9jdXMgPSAoZSkgPT4ge1xuICAgIGxldCBpc0ZvY3VzVmlzaWJsZSA9IGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICBpc0ZvY3VzVmlzaWJsZSA9IG5vZGUubWF0Y2hlcyhcIjpmb2N1cy12aXNpYmxlXCIpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgaXNGb2N1c1Zpc2libGUgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoIWlzRm9jdXNWaXNpYmxlKSByZXR1cm47XG4gICAgZm9jdXNlZCA9IHRydWU7XG4gICAgb25Gb2N1cz8uKGUpO1xuICB9O1xuICBjb25zdCBoYW5kbGVCbHVyID0gKGUpID0+IHtcbiAgICBpZiAoIWZvY3VzZWQpIHJldHVybjtcbiAgICBmb2N1c2VkID0gZmFsc2U7XG4gICAgb25CbHVyPy4oZSk7XG4gIH07XG4gIGNvbnN0IGhhbmRsZUtleWRvd24gPSAoZSkgPT4ge1xuICAgIGlmICghbm9kZS5tYXRjaGVzKFwiOmZvY3VzXCIpIHx8ICFpc1ZhbGlkS2V5KGUpKSByZXR1cm47XG4gICAgZm9jdXNlZCA9IHRydWU7XG4gICAgY29uc3QgZXZ0ID0gbmV3IHdpbi5Gb2N1c0V2ZW50KFwiZm9jdXNcIik7XG4gICAgb25Gb2N1cz8uKGV2dCk7XG4gIH07XG4gIHJldHVybiBwaXBlKFxuICAgIGFkZERvbUV2ZW50KG5vZGUsIFwiZm9jdXNpblwiLCBoYW5kbGVGb2N1cyksXG4gICAgYWRkRG9tRXZlbnQobm9kZSwgXCJmb2N1c291dFwiLCBoYW5kbGVCbHVyKSxcbiAgICBhZGREb21FdmVudChub2RlLCBcImtleWRvd25cIiwgaGFuZGxlS2V5ZG93biwgdHJ1ZSlcbiAgKTtcbn1cblxuLy8gc3JjL3RyYWNrLXBvaW50ZXItbW92ZS50c1xuaW1wb3J0IHsgZGlzYWJsZVRleHRTZWxlY3Rpb24gfSBmcm9tIFwiQHphZy1qcy90ZXh0LXNlbGVjdGlvblwiO1xuZnVuY3Rpb24gdHJhY2tQb2ludGVyTW92ZShkb2MsIGhhbmRsZXJzKSB7XG4gIGNvbnN0IHsgb25Qb2ludGVyTW92ZSwgb25Qb2ludGVyVXAgfSA9IGhhbmRsZXJzO1xuICBjb25zdCBoaXN0b3J5ID0gW107XG4gIGNvbnN0IGhhbmRsZU1vdmUgPSAoZXZlbnQpID0+IHtcbiAgICBjb25zdCBwb2ludCA9IGdldEV2ZW50UG9pbnQoZXZlbnQpO1xuICAgIGhpc3RvcnkucHVzaCh7IC4uLnBvaW50LCB0aW1lc3RhbXA6IHBlcmZvcm1hbmNlLm5vdygpIH0pO1xuICAgIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5zcXJ0KHBvaW50LnggKiogMiArIHBvaW50LnkgKiogMik7XG4gICAgY29uc3QgbW92ZUJ1ZmZlciA9IGV2ZW50LnBvaW50ZXJUeXBlID09PSBcInRvdWNoXCIgPyAxMCA6IDU7XG4gICAgaWYgKGRpc3RhbmNlIDwgbW92ZUJ1ZmZlcikgcmV0dXJuO1xuICAgIGlmIChldmVudC5wb2ludGVyVHlwZSA9PT0gXCJtb3VzZVwiICYmIGV2ZW50LmJ1dHRvbiA9PT0gMCkge1xuICAgICAgb25Qb2ludGVyVXAoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgb25Qb2ludGVyTW92ZSh7IHBvaW50LCBldmVudCwgdmVsb2NpdHk6IGdldFZlbG9jaXR5KGhpc3RvcnksIDAuMSkgfSk7XG4gIH07XG4gIGNvbnN0IGNsZWFudXBzID0gW1xuICAgIGFkZERvbUV2ZW50KGRvYywgXCJwb2ludGVybW92ZVwiLCBoYW5kbGVNb3ZlLCBmYWxzZSksXG4gICAgYWRkRG9tRXZlbnQoZG9jLCBcInBvaW50ZXJ1cFwiLCBvblBvaW50ZXJVcCwgZmFsc2UpLFxuICAgIGFkZERvbUV2ZW50KGRvYywgXCJwb2ludGVyY2FuY2VsXCIsIG9uUG9pbnRlclVwLCBmYWxzZSksXG4gICAgYWRkRG9tRXZlbnQoZG9jLCBcImNvbnRleHRtZW51XCIsIG9uUG9pbnRlclVwLCBmYWxzZSksXG4gICAgZGlzYWJsZVRleHRTZWxlY3Rpb24oeyBkb2MgfSlcbiAgXTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBjbGVhbnVwcy5mb3JFYWNoKChjbGVhbnVwKSA9PiBjbGVhbnVwKCkpO1xuICAgIGhpc3RvcnkubGVuZ3RoID0gMDtcbiAgfTtcbn1cbmZ1bmN0aW9uIGxhc3REZXZpY2VQb2ludChoaXN0b3J5KSB7XG4gIHJldHVybiBoaXN0b3J5W2hpc3RvcnkubGVuZ3RoIC0gMV07XG59XG5mdW5jdGlvbiBtcyhzZWNvbmRzKSB7XG4gIHJldHVybiBzZWNvbmRzICogMWUzO1xufVxuZnVuY3Rpb24gc2VjKG1pbGxpc2Vjb25kcykge1xuICByZXR1cm4gbWlsbGlzZWNvbmRzIC8gMWUzO1xufVxuZnVuY3Rpb24gZ2V0VmVsb2NpdHkoaGlzdG9yeSwgdGltZURlbHRhKSB7XG4gIGlmIChoaXN0b3J5Lmxlbmd0aCA8IDIpIHJldHVybiB7IHg6IDAsIHk6IDAgfTtcbiAgbGV0IGkgPSBoaXN0b3J5Lmxlbmd0aCAtIDE7XG4gIGxldCB0aW1lc3RhbXBlZFBvaW50ID0gbnVsbDtcbiAgY29uc3QgbGFzdFBvaW50ID0gbGFzdERldmljZVBvaW50KGhpc3RvcnkpO1xuICB3aGlsZSAoaSA+PSAwKSB7XG4gICAgdGltZXN0YW1wZWRQb2ludCA9IGhpc3RvcnlbaV07XG4gICAgaWYgKGxhc3RQb2ludC50aW1lc3RhbXAgLSB0aW1lc3RhbXBlZFBvaW50LnRpbWVzdGFtcCA+IG1zKHRpbWVEZWx0YSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpLS07XG4gIH1cbiAgaWYgKCF0aW1lc3RhbXBlZFBvaW50KSByZXR1cm4geyB4OiAwLCB5OiAwIH07XG4gIGNvbnN0IHRpbWUgPSBzZWMobGFzdFBvaW50LnRpbWVzdGFtcCAtIHRpbWVzdGFtcGVkUG9pbnQudGltZXN0YW1wKTtcbiAgaWYgKHRpbWUgPT09IDApIHJldHVybiB7IHg6IDAsIHk6IDAgfTtcbiAgY29uc3QgY3VycmVudFZlbG9jaXR5ID0ge1xuICAgIHg6IChsYXN0UG9pbnQueCAtIHRpbWVzdGFtcGVkUG9pbnQueCkgLyB0aW1lLFxuICAgIHk6IChsYXN0UG9pbnQueSAtIHRpbWVzdGFtcGVkUG9pbnQueSkgLyB0aW1lXG4gIH07XG4gIGlmIChjdXJyZW50VmVsb2NpdHkueCA9PT0gSW5maW5pdHkpIGN1cnJlbnRWZWxvY2l0eS54ID0gMDtcbiAgaWYgKGN1cnJlbnRWZWxvY2l0eS55ID09PSBJbmZpbml0eSkgY3VycmVudFZlbG9jaXR5LnkgPSAwO1xuICByZXR1cm4ge1xuICAgIHg6IE1hdGguYWJzKGN1cnJlbnRWZWxvY2l0eS54KSxcbiAgICB5OiBNYXRoLmFicyhjdXJyZW50VmVsb2NpdHkueSlcbiAgfTtcbn1cblxuLy8gc3JjL3RyYWNrLXByZXNzLnRzXG5pbXBvcnQgeyBjb250YWlucywgZ2V0RG9jdW1lbnQsIGdldEV2ZW50VGFyZ2V0LCBnZXRXaW5kb3cgYXMgZ2V0V2luZG93MiB9IGZyb20gXCJAemFnLWpzL2RvbS1xdWVyeVwiO1xuZnVuY3Rpb24gdHJhY2tQcmVzcyhvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICBwb2ludGVyTm9kZSxcbiAgICBrZXlib2FyZE5vZGUgPSBwb2ludGVyTm9kZSxcbiAgICBvblByZXNzLFxuICAgIG9uUHJlc3NTdGFydCxcbiAgICBvblByZXNzRW5kLFxuICAgIGlzVmFsaWRLZXk6IGlzVmFsaWRLZXkyID0gKGUpID0+IGUua2V5ID09PSBcIkVudGVyXCJcbiAgfSA9IG9wdGlvbnM7XG4gIGlmICghcG9pbnRlck5vZGUpIHJldHVybiBub29wO1xuICBjb25zdCB3aW4gPSBnZXRXaW5kb3cyKHBvaW50ZXJOb2RlKTtcbiAgY29uc3QgZG9jID0gZ2V0RG9jdW1lbnQocG9pbnRlck5vZGUpO1xuICBsZXQgcmVtb3ZlU3RhcnRMaXN0ZW5lcnMgPSBub29wO1xuICBsZXQgcmVtb3ZlRW5kTGlzdGVuZXJzID0gbm9vcDtcbiAgbGV0IHJlbW92ZUFjY2Vzc2libGVMaXN0ZW5lcnMgPSBub29wO1xuICBjb25zdCBnZXRJbmZvID0gKGV2ZW50KSA9PiAoe1xuICAgIHBvaW50OiBnZXRFdmVudFBvaW50KGV2ZW50KSxcbiAgICBldmVudFxuICB9KTtcbiAgZnVuY3Rpb24gc3RhcnRQcmVzcyhldmVudCkge1xuICAgIG9uUHJlc3NTdGFydD8uKGdldEluZm8oZXZlbnQpKTtcbiAgfVxuICBmdW5jdGlvbiBjYW5jZWxQcmVzcyhldmVudCkge1xuICAgIG9uUHJlc3NFbmQ/LihnZXRJbmZvKGV2ZW50KSk7XG4gIH1cbiAgY29uc3Qgc3RhcnRQb2ludGVyUHJlc3MgPSAoc3RhcnRFdmVudCkgPT4ge1xuICAgIHJlbW92ZUVuZExpc3RlbmVycygpO1xuICAgIGNvbnN0IGVuZFBvaW50ZXJQcmVzcyA9IChlbmRFdmVudCkgPT4ge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gZ2V0RXZlbnRUYXJnZXQoZW5kRXZlbnQpO1xuICAgICAgaWYgKGNvbnRhaW5zKHBvaW50ZXJOb2RlLCB0YXJnZXQpKSB7XG4gICAgICAgIG9uUHJlc3M/LihnZXRJbmZvKGVuZEV2ZW50KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvblByZXNzRW5kPy4oZ2V0SW5mbyhlbmRFdmVudCkpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgcmVtb3ZlUG9pbnRlclVwTGlzdGVuZXIgPSBhZGREb21FdmVudCh3aW4sIFwicG9pbnRlcnVwXCIsIGVuZFBvaW50ZXJQcmVzcywgeyBwYXNzaXZlOiAhb25QcmVzcyB9KTtcbiAgICBjb25zdCByZW1vdmVQb2ludGVyQ2FuY2VsTGlzdGVuZXIgPSBhZGREb21FdmVudCh3aW4sIFwicG9pbnRlcmNhbmNlbFwiLCBjYW5jZWxQcmVzcywgeyBwYXNzaXZlOiAhb25QcmVzc0VuZCB9KTtcbiAgICByZW1vdmVFbmRMaXN0ZW5lcnMgPSBwaXBlKHJlbW92ZVBvaW50ZXJVcExpc3RlbmVyLCByZW1vdmVQb2ludGVyQ2FuY2VsTGlzdGVuZXIpO1xuICAgIGlmIChkb2MuYWN0aXZlRWxlbWVudCA9PT0ga2V5Ym9hcmROb2RlICYmIHN0YXJ0RXZlbnQucG9pbnRlclR5cGUgPT09IFwibW91c2VcIikge1xuICAgICAgc3RhcnRFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgICBzdGFydFByZXNzKHN0YXJ0RXZlbnQpO1xuICB9O1xuICBjb25zdCByZW1vdmVQb2ludGVyTGlzdGVuZXIgPSBhZGREb21FdmVudChwb2ludGVyTm9kZSwgXCJwb2ludGVyZG93blwiLCBzdGFydFBvaW50ZXJQcmVzcywgeyBwYXNzaXZlOiAhb25QcmVzc1N0YXJ0IH0pO1xuICBjb25zdCByZW1vdmVGb2N1c0xpc3RlbmVyID0gYWRkRG9tRXZlbnQoa2V5Ym9hcmROb2RlLCBcImZvY3VzXCIsIHN0YXJ0QWNjZXNzaWJsZVByZXNzKTtcbiAgcmVtb3ZlU3RhcnRMaXN0ZW5lcnMgPSBwaXBlKHJlbW92ZVBvaW50ZXJMaXN0ZW5lciwgcmVtb3ZlRm9jdXNMaXN0ZW5lcik7XG4gIGZ1bmN0aW9uIHN0YXJ0QWNjZXNzaWJsZVByZXNzKCkge1xuICAgIGNvbnN0IGhhbmRsZUtleWRvd24gPSAoa2V5ZG93bkV2ZW50KSA9PiB7XG4gICAgICBpZiAoIWlzVmFsaWRLZXkyKGtleWRvd25FdmVudCkpIHJldHVybjtcbiAgICAgIGNvbnN0IGhhbmRsZUtleXVwID0gKGtleXVwRXZlbnQpID0+IHtcbiAgICAgICAgaWYgKCFpc1ZhbGlkS2V5MihrZXl1cEV2ZW50KSkgcmV0dXJuO1xuICAgICAgICBjb25zdCBldnQyID0gbmV3IHdpbi5Qb2ludGVyRXZlbnQoXCJwb2ludGVydXBcIik7XG4gICAgICAgIGNvbnN0IGluZm8gPSBnZXRJbmZvKGV2dDIpO1xuICAgICAgICBvblByZXNzPy4oaW5mbyk7XG4gICAgICAgIG9uUHJlc3NFbmQ/LihpbmZvKTtcbiAgICAgIH07XG4gICAgICByZW1vdmVFbmRMaXN0ZW5lcnMoKTtcbiAgICAgIHJlbW92ZUVuZExpc3RlbmVycyA9IGFkZERvbUV2ZW50KGtleWJvYXJkTm9kZSwgXCJrZXl1cFwiLCBoYW5kbGVLZXl1cCk7XG4gICAgICBjb25zdCBldnQgPSBuZXcgd2luLlBvaW50ZXJFdmVudChcInBvaW50ZXJkb3duXCIpO1xuICAgICAgc3RhcnRQcmVzcyhldnQpO1xuICAgIH07XG4gICAgY29uc3QgaGFuZGxlQmx1ciA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGV2dCA9IG5ldyB3aW4uUG9pbnRlckV2ZW50KFwicG9pbnRlcmNhbmNlbFwiKTtcbiAgICAgIGNhbmNlbFByZXNzKGV2dCk7XG4gICAgfTtcbiAgICBjb25zdCByZW1vdmVLZXlkb3duTGlzdGVuZXIgPSBhZGREb21FdmVudChrZXlib2FyZE5vZGUsIFwia2V5ZG93blwiLCBoYW5kbGVLZXlkb3duKTtcbiAgICBjb25zdCByZW1vdmVCbHVyTGlzdGVuZXIgPSBhZGREb21FdmVudChrZXlib2FyZE5vZGUsIFwiYmx1clwiLCBoYW5kbGVCbHVyKTtcbiAgICByZW1vdmVBY2Nlc3NpYmxlTGlzdGVuZXJzID0gcGlwZShyZW1vdmVLZXlkb3duTGlzdGVuZXIsIHJlbW92ZUJsdXJMaXN0ZW5lcik7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJlbW92ZVN0YXJ0TGlzdGVuZXJzKCk7XG4gICAgcmVtb3ZlRW5kTGlzdGVuZXJzKCk7XG4gICAgcmVtb3ZlQWNjZXNzaWJsZUxpc3RlbmVycygpO1xuICB9O1xufVxuXG4vLyBzcmMvdHJhY2stdmlzdWFsLXZpZXdwb3J0LnRzXG5mdW5jdGlvbiB0cmFja1Zpc3VhbFZpZXdwb3J0KGRvYywgZm4pIHtcbiAgY29uc3Qgd2luID0gZG9jPy5kZWZhdWx0VmlldyB8fCB3aW5kb3c7XG4gIGNvbnN0IG9uUmVzaXplID0gKCkgPT4ge1xuICAgIGZuPy4oZ2V0Vmlld3BvcnRTaXplKHdpbikpO1xuICB9O1xuICBvblJlc2l6ZSgpO1xuICByZXR1cm4gYWRkRG9tRXZlbnQod2luLnZpc3VhbFZpZXdwb3J0ID8/IHdpbiwgXCJyZXNpemVcIiwgb25SZXNpemUpO1xufVxuZnVuY3Rpb24gZ2V0Vmlld3BvcnRTaXplKHdpbikge1xuICByZXR1cm4ge1xuICAgIHdpZHRoOiB3aW4udmlzdWFsVmlld3BvcnQ/LndpZHRoIHx8IHdpbi5pbm5lcldpZHRoLFxuICAgIGhlaWdodDogd2luLnZpc3VhbFZpZXdwb3J0Py5oZWlnaHQgfHwgd2luLmlubmVySGVpZ2h0XG4gIH07XG59XG5leHBvcnQge1xuICBhZGREb21FdmVudCxcbiAgY2xpY2tJZkxpbmssXG4gIGZpcmVCbHVyRXZlbnQsXG4gIGZpcmVDdXN0b21FdmVudCxcbiAgZ2V0RXZlbnRLZXksXG4gIGdldEV2ZW50UG9pbnQsXG4gIGdldEV2ZW50U3RlcCxcbiAgZ2V0TmF0aXZlRXZlbnQsXG4gIGdldFJlbGF0aXZlUG9pbnQsXG4gIGlzQ29udGV4dE1lbnVFdmVudCxcbiAgaXNLZXlib2FyZENsaWNrLFxuICBpc0xlZnRDbGljayxcbiAgaXNNb2RpZmllcktleSxcbiAgaXNQcmludGFibGVLZXksXG4gIGlzVmlydHVhbENsaWNrLFxuICBpc1ZpcnR1YWxQb2ludGVyRXZlbnQsXG4gIHF1ZXVlQmVmb3JlRXZlbnQsXG4gIHJlcXVlc3RQb2ludGVyTG9jayxcbiAgdHJhY2tGb2N1c1Zpc2libGUsXG4gIHRyYWNrUG9pbnRlck1vdmUsXG4gIHRyYWNrUHJlc3MsXG4gIHRyYWNrVmlzdWFsVmlld3BvcnRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@zag-js/dom-event/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@zag-js/dom-query/dist/index.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/@zag-js/dom-query/dist/index.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MAX_Z_INDEX: () => (/* binding */ MAX_Z_INDEX),\n/* harmony export */   ariaAttr: () => (/* binding */ ariaAttr),\n/* harmony export */   contains: () => (/* binding */ contains),\n/* harmony export */   createScope: () => (/* binding */ createScope),\n/* harmony export */   dataAttr: () => (/* binding */ dataAttr),\n/* harmony export */   defaultItemToId: () => (/* binding */ defaultItemToId),\n/* harmony export */   getActiveElement: () => (/* binding */ getActiveElement),\n/* harmony export */   getBeforeInputValue: () => (/* binding */ getBeforeInputValue),\n/* harmony export */   getByText: () => (/* binding */ getByText),\n/* harmony export */   getByTypeahead: () => (/* binding */ getByTypeahead),\n/* harmony export */   getComputedStyle: () => (/* binding */ getComputedStyle),\n/* harmony export */   getDataUrl: () => (/* binding */ getDataUrl),\n/* harmony export */   getDocument: () => (/* binding */ getDocument),\n/* harmony export */   getDocumentElement: () => (/* binding */ getDocumentElement),\n/* harmony export */   getEventTarget: () => (/* binding */ getEventTarget),\n/* harmony export */   getFirstFocusable: () => (/* binding */ getFirstFocusable),\n/* harmony export */   getFirstTabbable: () => (/* binding */ getFirstTabbable),\n/* harmony export */   getFocusables: () => (/* binding */ getFocusables),\n/* harmony export */   getInitialFocus: () => (/* binding */ getInitialFocus),\n/* harmony export */   getLastTabbable: () => (/* binding */ getLastTabbable),\n/* harmony export */   getNearestOverflowAncestor: () => (/* binding */ getNearestOverflowAncestor),\n/* harmony export */   getNextTabbable: () => (/* binding */ getNextTabbable),\n/* harmony export */   getNodeName: () => (/* binding */ getNodeName),\n/* harmony export */   getOverflowAncestors: () => (/* binding */ getOverflowAncestors),\n/* harmony export */   getParentNode: () => (/* binding */ getParentNode),\n/* harmony export */   getPlatform: () => (/* binding */ getPlatform),\n/* harmony export */   getScrollPosition: () => (/* binding */ getScrollPosition),\n/* harmony export */   getTabbableEdges: () => (/* binding */ getTabbableEdges),\n/* harmony export */   getTabbables: () => (/* binding */ getTabbables),\n/* harmony export */   getWindow: () => (/* binding */ getWindow),\n/* harmony export */   indexOfId: () => (/* binding */ indexOfId),\n/* harmony export */   isApple: () => (/* binding */ isApple),\n/* harmony export */   isComposingEvent: () => (/* binding */ isComposingEvent),\n/* harmony export */   isDocument: () => (/* binding */ isDocument),\n/* harmony export */   isDom: () => (/* binding */ isDom),\n/* harmony export */   isDownloadingEvent: () => (/* binding */ isDownloadingEvent),\n/* harmony export */   isEditableElement: () => (/* binding */ isEditableElement),\n/* harmony export */   isFirefox: () => (/* binding */ isFirefox),\n/* harmony export */   isFocusable: () => (/* binding */ isFocusable),\n/* harmony export */   isHTMLElement: () => (/* binding */ isHTMLElement),\n/* harmony export */   isHiddenElement: () => (/* binding */ isHiddenElement),\n/* harmony export */   isInView: () => (/* binding */ isInView),\n/* harmony export */   isIos: () => (/* binding */ isIos),\n/* harmony export */   isMac: () => (/* binding */ isMac),\n/* harmony export */   isModKey: () => (/* binding */ isModKey),\n/* harmony export */   isNode: () => (/* binding */ isNode),\n/* harmony export */   isOpeningInNewTab: () => (/* binding */ isOpeningInNewTab),\n/* harmony export */   isOverflowElement: () => (/* binding */ isOverflowElement),\n/* harmony export */   isRootElement: () => (/* binding */ isRootElement),\n/* harmony export */   isSafari: () => (/* binding */ isSafari),\n/* harmony export */   isSelfTarget: () => (/* binding */ isSelfTarget),\n/* harmony export */   isShadowRoot: () => (/* binding */ isShadowRoot),\n/* harmony export */   isTabbable: () => (/* binding */ isTabbable),\n/* harmony export */   isTouchDevice: () => (/* binding */ isTouchDevice),\n/* harmony export */   isValidTabEvent: () => (/* binding */ isValidTabEvent),\n/* harmony export */   isVisualViewport: () => (/* binding */ isVisualViewport),\n/* harmony export */   isWebKit: () => (/* binding */ isWebKit),\n/* harmony export */   isWindow: () => (/* binding */ isWindow),\n/* harmony export */   itemById: () => (/* binding */ itemById),\n/* harmony export */   nextById: () => (/* binding */ nextById),\n/* harmony export */   nextTick: () => (/* binding */ nextTick),\n/* harmony export */   observeAttributes: () => (/* binding */ observeAttributes),\n/* harmony export */   observeChildren: () => (/* binding */ observeChildren),\n/* harmony export */   prevById: () => (/* binding */ prevById),\n/* harmony export */   proxyTabFocus: () => (/* binding */ proxyTabFocus),\n/* harmony export */   query: () => (/* binding */ query),\n/* harmony export */   queryAll: () => (/* binding */ queryAll),\n/* harmony export */   raf: () => (/* binding */ raf),\n/* harmony export */   scrollIntoView: () => (/* binding */ scrollIntoView),\n/* harmony export */   set: () => (/* binding */ set),\n/* harmony export */   setAttribute: () => (/* binding */ setAttribute),\n/* harmony export */   setProperty: () => (/* binding */ setProperty),\n/* harmony export */   setStyle: () => (/* binding */ setStyle),\n/* harmony export */   visuallyHiddenStyle: () => (/* binding */ visuallyHiddenStyle),\n/* harmony export */   waitForElement: () => (/* binding */ waitForElement),\n/* harmony export */   waitForElements: () => (/* binding */ waitForElements)\n/* harmony export */ });\n// src/attrs.ts\nvar dataAttr = (guard) => guard ? \"\" : void 0;\nvar ariaAttr = (guard) => guard ? \"true\" : void 0;\n\n// src/constants.ts\nvar MAX_Z_INDEX = 2147483647;\n\n// src/is.ts\nvar ELEMENT_NODE = 1;\nvar DOCUMENT_NODE = 9;\nvar DOCUMENT_FRAGMENT_NODE = 11;\nvar isObject = (v) => typeof v === \"object\" && v !== null;\nvar isHTMLElement = (el) => isObject(el) && el.nodeType === ELEMENT_NODE && typeof el.nodeName === \"string\";\nvar isDocument = (el) => isObject(el) && el.nodeType === DOCUMENT_NODE;\nvar isWindow = (el) => isObject(el) && el === el.window;\nvar isVisualViewport = (el) => isObject(el) && el.constructor.name === \"VisualViewport\";\nvar getNodeName = (node) => {\n  if (isHTMLElement(node)) return node.localName || \"\";\n  return \"#document\";\n};\nfunction isRootElement(node) {\n  return [\"html\", \"body\", \"#document\"].includes(getNodeName(node));\n}\nvar isNode = (el) => isObject(el) && el.nodeType !== void 0;\nvar isShadowRoot = (el) => isNode(el) && el.nodeType === DOCUMENT_FRAGMENT_NODE && \"host\" in el;\n\n// src/contains.ts\nfunction contains(parent, child) {\n  if (!parent || !child) return false;\n  if (!isHTMLElement(parent) || !isHTMLElement(child)) return false;\n  return parent === child || parent.contains(child);\n}\n\n// src/env.ts\nfunction getDocument(el) {\n  if (isDocument(el)) return el;\n  if (isWindow(el)) return el.document;\n  return el?.ownerDocument ?? document;\n}\nfunction getDocumentElement(el) {\n  return getDocument(el).documentElement;\n}\nfunction getWindow(el) {\n  if (isShadowRoot(el)) return getWindow(el.host);\n  if (isDocument(el)) return el.defaultView ?? window;\n  if (isHTMLElement(el)) return el.ownerDocument?.defaultView ?? window;\n  return window;\n}\nfunction getActiveElement(el) {\n  const doc = getDocument(el);\n  let activeElement = doc.activeElement;\n  while (activeElement?.shadowRoot) {\n    const el2 = activeElement.shadowRoot.activeElement;\n    if (el2 === activeElement) break;\n    else activeElement = el2;\n  }\n  return activeElement;\n}\n\n// src/data-url.ts\nfunction getDataUrl(svg, opts) {\n  const { type, quality = 0.92 } = opts;\n  if (!svg) throw new Error(\"[get-data-url]: could not find the svg element\");\n  const win = getWindow(svg);\n  const doc = win.document;\n  const serializer = new win.XMLSerializer();\n  const source = '<?xml version=\"1.0\" standalone=\"no\"?>\\r\\n' + serializer.serializeToString(svg);\n  const svgString = \"data:image/svg+xml;charset=utf-8,\" + encodeURIComponent(source);\n  if (type === \"image/svg+xml\") {\n    return Promise.resolve(svgString);\n  }\n  const svgBounds = svg.getBoundingClientRect();\n  const dpr = win.devicePixelRatio || 1;\n  const canvas = doc.createElement(\"canvas\");\n  const image = new win.Image();\n  image.src = svgString;\n  canvas.width = svgBounds.width * dpr;\n  canvas.height = svgBounds.height * dpr;\n  const context = canvas.getContext(\"2d\");\n  context.scale(dpr, dpr);\n  return new Promise((resolve) => {\n    image.onload = () => {\n      context.drawImage(image, 0, 0);\n      resolve(canvas.toDataURL(type, quality));\n    };\n  });\n}\n\n// src/platform.ts\nvar isDom = () => typeof document !== \"undefined\";\nfunction getPlatform() {\n  const agent = navigator.userAgentData;\n  return agent?.platform ?? navigator.platform;\n}\nvar pt = (v) => isDom() && v.test(getPlatform());\nvar ua = (v) => isDom() && v.test(navigator.userAgent);\nvar vn = (v) => isDom() && v.test(navigator.vendor);\nvar isTouchDevice = () => isDom() && !!navigator.maxTouchPoints;\nvar isMac = () => pt(/^Mac/);\nvar isSafari = () => isApple() && vn(/apple/i);\nvar isFirefox = () => ua(/firefox\\//i);\nvar isApple = () => pt(/mac|iphone|ipad|ipod/i);\nvar isIos = () => pt(/iP(hone|ad|od)|iOS/);\nvar isWebKit = () => ua(/AppleWebKit/);\nvar isModKey = (event) => isApple() ? event.metaKey : event.ctrlKey;\n\n// src/event.ts\nfunction getBeforeInputValue(event) {\n  const { selectionStart, selectionEnd, value } = event.currentTarget;\n  return value.slice(0, selectionStart) + event.data + value.slice(selectionEnd);\n}\nfunction getComposedPath(event) {\n  return event.composedPath?.() ?? event.nativeEvent?.composedPath?.();\n}\nfunction getEventTarget(event) {\n  const composedPath = getComposedPath(event);\n  return composedPath?.[0] ?? event.target;\n}\nvar isSelfTarget = (event) => {\n  return contains(event.currentTarget, getEventTarget(event));\n};\nfunction isOpeningInNewTab(event) {\n  const element = event.currentTarget;\n  if (!element) return false;\n  const isAppleDevice = isApple();\n  if (isAppleDevice && !event.metaKey) return false;\n  if (!isAppleDevice && !event.ctrlKey) return false;\n  const localName = element.localName;\n  if (localName === \"a\") return true;\n  if (localName === \"button\" && element.type === \"submit\") return true;\n  if (localName === \"input\" && element.type === \"submit\") return true;\n  return false;\n}\nfunction isDownloadingEvent(event) {\n  const element = event.currentTarget;\n  if (!element) return false;\n  const localName = element.localName;\n  if (!event.altKey) return false;\n  if (localName === \"a\") return true;\n  if (localName === \"button\" && element.type === \"submit\") return true;\n  if (localName === \"input\" && element.type === \"submit\") return true;\n  return false;\n}\nfunction isComposingEvent(event) {\n  return event.nativeEvent?.isComposing ?? event.isComposing;\n}\n\n// src/get-by-id.ts\nvar defaultItemToId = (v) => v.id;\nfunction itemById(v, id, itemToId = defaultItemToId) {\n  return v.find((item) => itemToId(item) === id);\n}\nfunction indexOfId(v, id, itemToId = defaultItemToId) {\n  const item = itemById(v, id, itemToId);\n  return item ? v.indexOf(item) : -1;\n}\nfunction nextById(v, id, loop = true) {\n  let idx = indexOfId(v, id);\n  idx = loop ? (idx + 1) % v.length : Math.min(idx + 1, v.length - 1);\n  return v[idx];\n}\nfunction prevById(v, id, loop = true) {\n  let idx = indexOfId(v, id);\n  if (idx === -1) return loop ? v[v.length - 1] : null;\n  idx = loop ? (idx - 1 + v.length) % v.length : Math.max(0, idx - 1);\n  return v[idx];\n}\n\n// src/sanitize.ts\nvar sanitize = (str) => str.split(\"\").map((char) => {\n  const code = char.charCodeAt(0);\n  if (code > 0 && code < 128) return char;\n  if (code >= 128 && code <= 255) return `/x${code.toString(16)}`.replace(\"/\", \"\\\\\");\n  return \"\";\n}).join(\"\").trim();\n\n// src/get-by-text.ts\nvar getValueText = (item) => sanitize(item.dataset.valuetext ?? item.textContent ?? \"\");\nvar match = (valueText, query2) => valueText.trim().toLowerCase().startsWith(query2.toLowerCase());\nvar wrap = (v, idx) => {\n  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length]);\n};\nfunction getByText(v, text, currentId, itemToId = defaultItemToId) {\n  const index = currentId ? indexOfId(v, currentId, itemToId) : -1;\n  let items = currentId ? wrap(v, index) : v;\n  const isSingleKey = text.length === 1;\n  if (isSingleKey) {\n    items = items.filter((item) => itemToId(item) !== currentId);\n  }\n  return items.find((item) => match(getValueText(item), text));\n}\n\n// src/get-by-typeahead.ts\nfunction getByTypeaheadImpl(_items, options) {\n  const { state, activeId, key, timeout = 350, itemToId } = options;\n  const search = state.keysSoFar + key;\n  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);\n  const query2 = isRepeated ? search[0] : search;\n  let items = _items.slice();\n  const next = getByText(items, query2, activeId, itemToId);\n  function cleanup() {\n    clearTimeout(state.timer);\n    state.timer = -1;\n  }\n  function update(value) {\n    state.keysSoFar = value;\n    cleanup();\n    if (value !== \"\") {\n      state.timer = +setTimeout(() => {\n        update(\"\");\n        cleanup();\n      }, timeout);\n    }\n  }\n  update(search);\n  return next;\n}\nvar getByTypeahead = /* @__PURE__ */ Object.assign(getByTypeaheadImpl, {\n  defaultOptions: { keysSoFar: \"\", timer: -1 },\n  isValidEvent: isValidTypeaheadEvent\n});\nfunction isValidTypeaheadEvent(event) {\n  return event.key.length === 1 && !event.ctrlKey && !event.metaKey;\n}\n\n// src/get-computed-style.ts\nvar styleCache = /* @__PURE__ */ new WeakMap();\nfunction getComputedStyle(el) {\n  if (!styleCache.has(el)) {\n    styleCache.set(el, getWindow(el).getComputedStyle(el));\n  }\n  return styleCache.get(el);\n}\n\n// src/get-parent-node.ts\nfunction getParentNode(node) {\n  if (getNodeName(node) === \"html\") {\n    return node;\n  }\n  const result = (\n    // Step into the shadow DOM of the parent of a slotted node.\n    node.assignedSlot || // DOM Element detected.\n    node.parentNode || // ShadowRoot detected.\n    isShadowRoot(node) && node.host || // Fallback.\n    getDocumentElement(node)\n  );\n  return isShadowRoot(result) ? result.host : result;\n}\n\n// src/get-scroll-position.ts\nfunction getScrollPosition(element) {\n  if (isHTMLElement(element)) {\n    return { scrollLeft: element.scrollLeft, scrollTop: element.scrollTop };\n  }\n  return { scrollLeft: element.scrollX, scrollTop: element.scrollY };\n}\n\n// src/tabbable.ts\nvar isHTMLElement2 = (element) => typeof element === \"object\" && element !== null && element.nodeType === 1;\nvar isFrame = (element) => isHTMLElement2(element) && element.tagName === \"IFRAME\";\nfunction isVisible(el) {\n  if (!isHTMLElement2(el)) return false;\n  return el.offsetWidth > 0 || el.offsetHeight > 0 || el.getClientRects().length > 0;\n}\nfunction hasNegativeTabIndex(element) {\n  const tabIndex = parseInt(element.getAttribute(\"tabindex\") || \"0\", 10);\n  return tabIndex < 0;\n}\nvar focusableSelector = \"input:not([type='hidden']):not([disabled]), select:not([disabled]), textarea:not([disabled]), a[href], button:not([disabled]), [tabindex], iframe, object, embed, area[href], audio[controls], video[controls], [contenteditable]:not([contenteditable='false']), details > summary:first-of-type\";\nvar getFocusables = (container, includeContainer = false) => {\n  if (!container) return [];\n  const elements = Array.from(container.querySelectorAll(focusableSelector));\n  const include = includeContainer == true || includeContainer == \"if-empty\" && elements.length === 0;\n  if (include && isHTMLElement2(container) && isFocusable(container)) {\n    elements.unshift(container);\n  }\n  const focusableElements = elements.filter(isFocusable);\n  focusableElements.forEach((element, i) => {\n    if (isFrame(element) && element.contentDocument) {\n      const frameBody = element.contentDocument.body;\n      focusableElements.splice(i, 1, ...getFocusables(frameBody));\n    }\n  });\n  return focusableElements;\n};\nfunction isFocusable(element) {\n  if (!element || element.closest(\"[inert]\")) return false;\n  return element.matches(focusableSelector) && isVisible(element);\n}\nfunction getFirstFocusable(container, includeContainer) {\n  const [first] = getFocusables(container, includeContainer);\n  return first || null;\n}\nfunction getTabbables(container, includeContainer) {\n  if (!container) return [];\n  const elements = Array.from(container.querySelectorAll(focusableSelector));\n  const tabbableElements = elements.filter(isTabbable);\n  if (includeContainer && isTabbable(container)) {\n    tabbableElements.unshift(container);\n  }\n  tabbableElements.forEach((element, i) => {\n    if (isFrame(element) && element.contentDocument) {\n      const frameBody = element.contentDocument.body;\n      const allFrameTabbable = getTabbables(frameBody);\n      tabbableElements.splice(i, 1, ...allFrameTabbable);\n    }\n  });\n  if (!tabbableElements.length && includeContainer) {\n    return elements;\n  }\n  return tabbableElements;\n}\nfunction isTabbable(el) {\n  if (el != null && el.tabIndex > 0) return true;\n  return isFocusable(el) && !hasNegativeTabIndex(el);\n}\nfunction getFirstTabbable(container, includeContainer) {\n  const [first] = getTabbables(container, includeContainer);\n  return first || null;\n}\nfunction getLastTabbable(container, includeContainer) {\n  const elements = getTabbables(container, includeContainer);\n  return elements[elements.length - 1] || null;\n}\nfunction getTabbableEdges(container, includeContainer) {\n  const elements = getTabbables(container, includeContainer);\n  const first = elements[0] || null;\n  const last = elements[elements.length - 1] || null;\n  return [first, last];\n}\nfunction getNextTabbable(container, current) {\n  const tabbables = getTabbables(container);\n  const doc = container?.ownerDocument || document;\n  const currentElement = current ?? doc.activeElement;\n  if (!currentElement) return null;\n  const index = tabbables.indexOf(currentElement);\n  return tabbables[index + 1] || null;\n}\n\n// src/initial-focus.ts\nfunction getInitialFocus(options) {\n  const { root, getInitialEl, filter, enabled = true } = options;\n  if (!enabled) return;\n  let node = null;\n  node || (node = typeof getInitialEl === \"function\" ? getInitialEl() : getInitialEl);\n  node || (node = root?.querySelector(\"[data-autofocus],[autofocus]\"));\n  if (!node) {\n    const tabbables = getTabbables(root);\n    node = filter ? tabbables.filter(filter)[0] : tabbables[0];\n  }\n  return node || root || void 0;\n}\nfunction isValidTabEvent(event) {\n  const container = event.currentTarget;\n  if (!container) return false;\n  const [firstTabbable, lastTabbable] = getTabbableEdges(container);\n  const doc = container.ownerDocument || document;\n  if (doc.activeElement === firstTabbable && event.shiftKey) return false;\n  if (doc.activeElement === lastTabbable && !event.shiftKey) return false;\n  if (!firstTabbable && !lastTabbable) return false;\n  return true;\n}\n\n// src/is-editable-element.ts\nfunction isEditableElement(el) {\n  if (el == null || !isHTMLElement(el)) {\n    return false;\n  }\n  try {\n    const win = getWindow(el);\n    return el instanceof win.HTMLInputElement && el.selectionStart != null || /(textarea|select)/.test(el.localName) || el.isContentEditable;\n  } catch {\n    return false;\n  }\n}\n\n// src/is-hidden-element.ts\nfunction isHiddenElement(node) {\n  if (node.parentElement && isHiddenElement(node.parentElement)) return true;\n  return node.hidden;\n}\n\n// src/is-overflow-element.ts\nvar OVERFLOW_RE = /auto|scroll|overlay|hidden|clip/;\nfunction isOverflowElement(el) {\n  const win = getWindow(el);\n  const { overflow, overflowX, overflowY, display } = win.getComputedStyle(el);\n  return OVERFLOW_RE.test(overflow + overflowY + overflowX) && ![\"inline\", \"contents\"].includes(display);\n}\n\n// src/raf.ts\nfunction nextTick(fn) {\n  const set2 = /* @__PURE__ */ new Set();\n  function raf2(fn2) {\n    const id = globalThis.requestAnimationFrame(fn2);\n    set2.add(() => globalThis.cancelAnimationFrame(id));\n  }\n  raf2(() => raf2(fn));\n  return function cleanup() {\n    set2.forEach((fn2) => fn2());\n  };\n}\nfunction raf(fn) {\n  const id = globalThis.requestAnimationFrame(fn);\n  return () => {\n    globalThis.cancelAnimationFrame(id);\n  };\n}\n\n// src/observe-attributes.ts\nfunction observeAttributesImpl(node, options) {\n  if (!node) return;\n  const { attributes, callback: fn } = options;\n  const win = node.ownerDocument.defaultView || window;\n  const obs = new win.MutationObserver((changes) => {\n    for (const change of changes) {\n      if (change.type === \"attributes\" && change.attributeName && attributes.includes(change.attributeName)) {\n        fn(change);\n      }\n    }\n  });\n  obs.observe(node, { attributes: true, attributeFilter: attributes });\n  return () => obs.disconnect();\n}\nfunction observeAttributes(nodeOrFn, options) {\n  const { defer } = options;\n  const func = defer ? raf : (v) => v();\n  const cleanups2 = [];\n  cleanups2.push(\n    func(() => {\n      const node = typeof nodeOrFn === \"function\" ? nodeOrFn() : nodeOrFn;\n      cleanups2.push(observeAttributesImpl(node, options));\n    })\n  );\n  return () => {\n    cleanups2.forEach((fn) => fn?.());\n  };\n}\n\n// src/observe-children.ts\nfunction observeChildrenImpl(node, options) {\n  const { callback: fn } = options;\n  if (!node) return;\n  const win = node.ownerDocument.defaultView || window;\n  const obs = new win.MutationObserver(fn);\n  obs.observe(node, { childList: true, subtree: true });\n  return () => obs.disconnect();\n}\nfunction observeChildren(nodeOrFn, options) {\n  const { defer } = options;\n  const func = defer ? raf : (v) => v();\n  const cleanups2 = [];\n  cleanups2.push(\n    func(() => {\n      const node = typeof nodeOrFn === \"function\" ? nodeOrFn() : nodeOrFn;\n      cleanups2.push(observeChildrenImpl(node, options));\n    })\n  );\n  return () => {\n    cleanups2.forEach((fn) => fn?.());\n  };\n}\n\n// src/overflow.ts\nfunction getNearestOverflowAncestor(el) {\n  const parentNode = getParentNode(el);\n  if (isRootElement(parentNode)) {\n    return getDocument(parentNode).body;\n  }\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n  return getNearestOverflowAncestor(parentNode);\n}\nfunction getOverflowAncestors(el, list = []) {\n  const scrollableAncestor = getNearestOverflowAncestor(el);\n  const isBody = scrollableAncestor === el.ownerDocument.body;\n  const win = getWindow(scrollableAncestor);\n  if (isBody) {\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []);\n  }\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, []));\n}\nvar getRect = (el) => {\n  if (isHTMLElement(el)) {\n    return el.getBoundingClientRect();\n  }\n  if (isVisualViewport(el)) {\n    return { top: 0, left: 0, bottom: el.height, right: el.width };\n  }\n  return { top: 0, left: 0, bottom: el.innerHeight, right: el.innerWidth };\n};\nfunction isInView(el, ancestor) {\n  if (!isHTMLElement(el)) return true;\n  const ancestorRect = getRect(ancestor);\n  const elRect = el.getBoundingClientRect();\n  return elRect.top >= ancestorRect.top && elRect.left >= ancestorRect.left && elRect.bottom <= ancestorRect.bottom && elRect.right <= ancestorRect.right;\n}\n\n// src/proxy-tab-focus.ts\nfunction proxyTabFocusImpl(container, options = {}) {\n  const { triggerElement, onFocus } = options;\n  const doc = container?.ownerDocument || document;\n  const body = doc.body;\n  function onKeyDown(event) {\n    if (event.key !== \"Tab\") return;\n    let elementToFocus = null;\n    const [firstTabbable, lastTabbable] = getTabbableEdges(container, true);\n    const noTabbableElements = !firstTabbable && !lastTabbable;\n    if (event.shiftKey && (doc.activeElement === firstTabbable || noTabbableElements)) {\n      elementToFocus = triggerElement;\n    } else if (!event.shiftKey && doc.activeElement === triggerElement) {\n      elementToFocus = firstTabbable;\n    } else if (!event.shiftKey && (doc.activeElement === lastTabbable || noTabbableElements)) {\n      elementToFocus = getNextTabbable(body, triggerElement);\n    }\n    if (!elementToFocus) return;\n    event.preventDefault();\n    if (typeof onFocus === \"function\") {\n      onFocus(elementToFocus);\n    } else {\n      elementToFocus.focus();\n    }\n  }\n  doc?.addEventListener(\"keydown\", onKeyDown, true);\n  return () => {\n    doc?.removeEventListener(\"keydown\", onKeyDown, true);\n  };\n}\nfunction proxyTabFocus(container, options) {\n  const { defer, triggerElement, ...restOptions } = options;\n  const func = defer ? raf : (v) => v();\n  const cleanups2 = [];\n  cleanups2.push(\n    func(() => {\n      const node = typeof container === \"function\" ? container() : container;\n      const trigger = typeof triggerElement === \"function\" ? triggerElement() : triggerElement;\n      cleanups2.push(proxyTabFocusImpl(node, { triggerElement: trigger, ...restOptions }));\n    })\n  );\n  return () => {\n    cleanups2.forEach((fn) => fn?.());\n  };\n}\n\n// src/query.ts\nfunction queryAll(root, selector) {\n  return Array.from(root?.querySelectorAll(selector) ?? []);\n}\nfunction query(root, selector) {\n  return root?.querySelector(selector) ?? null;\n}\n\n// src/scope.ts\nfunction createScope(methods) {\n  const dom = {\n    getRootNode: (ctx) => ctx.getRootNode?.() ?? document,\n    getDoc: (ctx) => getDocument(dom.getRootNode(ctx)),\n    getWin: (ctx) => dom.getDoc(ctx).defaultView ?? window,\n    getActiveElement: (ctx) => dom.getRootNode(ctx).activeElement,\n    isActiveElement: (ctx, elem) => elem === dom.getActiveElement(ctx),\n    getById: (ctx, id) => dom.getRootNode(ctx).getElementById(id),\n    setValue: (elem, value) => {\n      if (elem == null || value == null) return;\n      const valueAsString = value.toString();\n      if (elem.value === valueAsString) return;\n      elem.value = value.toString();\n    }\n  };\n  return { ...dom, ...methods };\n}\n\n// src/scroll-into-view.ts\nfunction isScrollable(el) {\n  return el.scrollHeight > el.clientHeight || el.scrollWidth > el.clientWidth;\n}\nfunction scrollIntoView(el, options) {\n  const { rootEl, ...scrollOptions } = options || {};\n  if (!el || !rootEl) {\n    return;\n  }\n  if (!isOverflowElement(rootEl) || !isScrollable(rootEl)) {\n    return;\n  }\n  el.scrollIntoView(scrollOptions);\n}\n\n// src/set.ts\nvar cleanups = /* @__PURE__ */ new WeakMap();\nfunction set(element, key, setup) {\n  if (!cleanups.has(element)) {\n    cleanups.set(element, /* @__PURE__ */ new Map());\n  }\n  const elementCleanups = cleanups.get(element);\n  const prevCleanup = elementCleanups.get(key);\n  if (!prevCleanup) {\n    elementCleanups.set(key, setup());\n    return () => {\n      elementCleanups.get(key)?.();\n      elementCleanups.delete(key);\n    };\n  }\n  const cleanup = setup();\n  const nextCleanup = () => {\n    cleanup();\n    prevCleanup();\n    elementCleanups.delete(key);\n  };\n  elementCleanups.set(key, nextCleanup);\n  return () => {\n    const isCurrent = elementCleanups.get(key) === nextCleanup;\n    if (!isCurrent) return;\n    cleanup();\n    elementCleanups.set(key, prevCleanup);\n  };\n}\nfunction setAttribute(element, attr, value) {\n  const setup = () => {\n    const previousValue = element.getAttribute(attr);\n    element.setAttribute(attr, value);\n    return () => {\n      if (previousValue == null) {\n        element.removeAttribute(attr);\n      } else {\n        element.setAttribute(attr, previousValue);\n      }\n    };\n  };\n  return set(element, attr, setup);\n}\nfunction setProperty(element, property, value) {\n  const setup = () => {\n    const exists = property in element;\n    const previousValue = element[property];\n    element[property] = value;\n    return () => {\n      if (!exists) {\n        delete element[property];\n      } else {\n        element[property] = previousValue;\n      }\n    };\n  };\n  return set(element, property, setup);\n}\nfunction setStyle(element, style) {\n  if (!element) return () => {\n  };\n  const setup = () => {\n    const prevStyle = element.style.cssText;\n    Object.assign(element.style, style);\n    return () => {\n      element.style.cssText = prevStyle;\n    };\n  };\n  return set(element, \"style\", setup);\n}\n\n// src/visually-hidden.ts\nvar visuallyHiddenStyle = {\n  border: \"0\",\n  clip: \"rect(0 0 0 0)\",\n  height: \"1px\",\n  margin: \"-1px\",\n  overflow: \"hidden\",\n  padding: \"0\",\n  position: \"absolute\",\n  width: \"1px\",\n  whiteSpace: \"nowrap\",\n  wordWrap: \"normal\"\n};\n\n// src/wait-for.ts\nvar fps = 1e3 / 60;\nfunction waitForElement(query2, cb) {\n  const el = query2();\n  if (isHTMLElement(el) && el.isConnected) {\n    cb(el);\n    return () => void 0;\n  } else {\n    const timerId = setInterval(() => {\n      const el2 = query2();\n      if (isHTMLElement(el2) && el2.isConnected) {\n        cb(el2);\n        clearInterval(timerId);\n      }\n    }, fps);\n    return () => clearInterval(timerId);\n  }\n}\nfunction waitForElements(queries, cb) {\n  const cleanups2 = [];\n  queries?.forEach((query2) => {\n    const clean = waitForElement(query2, cb);\n    cleanups2.push(clean);\n  });\n  return () => {\n    cleanups2.forEach((fn) => fn());\n  };\n}\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHphZy1qcy9kb20tcXVlcnkvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsdUJBQXVCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLHNDQUFzQztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGtCQUFrQjtBQUNoRTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLGdEQUFnRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsNkNBQTZDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsMENBQTBDO0FBQ3BEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsMkJBQTJCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILHNCQUFzQiwrQ0FBK0M7QUFDckU7QUFDQTtBQUNBO0FBQ0EsVUFBVSxRQUFRO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLGVBQWU7QUFDekI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdDQUFnQztBQUN0RDtBQUNBO0FBQ0E7QUFDQSxVQUFVLFFBQVE7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrREFBa0Q7QUFDbEQsVUFBVSwwQkFBMEI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHdDQUF3QztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MseUNBQXlDO0FBQ3hGLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDJCQUEyQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQThFRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2l0ZXMvLi9ub2RlX21vZHVsZXMvQHphZy1qcy9kb20tcXVlcnkvZGlzdC9pbmRleC5tanM/NjY0MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvYXR0cnMudHNcbnZhciBkYXRhQXR0ciA9IChndWFyZCkgPT4gZ3VhcmQgPyBcIlwiIDogdm9pZCAwO1xudmFyIGFyaWFBdHRyID0gKGd1YXJkKSA9PiBndWFyZCA/IFwidHJ1ZVwiIDogdm9pZCAwO1xuXG4vLyBzcmMvY29uc3RhbnRzLnRzXG52YXIgTUFYX1pfSU5ERVggPSAyMTQ3NDgzNjQ3O1xuXG4vLyBzcmMvaXMudHNcbnZhciBFTEVNRU5UX05PREUgPSAxO1xudmFyIERPQ1VNRU5UX05PREUgPSA5O1xudmFyIERPQ1VNRU5UX0ZSQUdNRU5UX05PREUgPSAxMTtcbnZhciBpc09iamVjdCA9ICh2KSA9PiB0eXBlb2YgdiA9PT0gXCJvYmplY3RcIiAmJiB2ICE9PSBudWxsO1xudmFyIGlzSFRNTEVsZW1lbnQgPSAoZWwpID0+IGlzT2JqZWN0KGVsKSAmJiBlbC5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFICYmIHR5cGVvZiBlbC5ub2RlTmFtZSA9PT0gXCJzdHJpbmdcIjtcbnZhciBpc0RvY3VtZW50ID0gKGVsKSA9PiBpc09iamVjdChlbCkgJiYgZWwubm9kZVR5cGUgPT09IERPQ1VNRU5UX05PREU7XG52YXIgaXNXaW5kb3cgPSAoZWwpID0+IGlzT2JqZWN0KGVsKSAmJiBlbCA9PT0gZWwud2luZG93O1xudmFyIGlzVmlzdWFsVmlld3BvcnQgPSAoZWwpID0+IGlzT2JqZWN0KGVsKSAmJiBlbC5jb25zdHJ1Y3Rvci5uYW1lID09PSBcIlZpc3VhbFZpZXdwb3J0XCI7XG52YXIgZ2V0Tm9kZU5hbWUgPSAobm9kZSkgPT4ge1xuICBpZiAoaXNIVE1MRWxlbWVudChub2RlKSkgcmV0dXJuIG5vZGUubG9jYWxOYW1lIHx8IFwiXCI7XG4gIHJldHVybiBcIiNkb2N1bWVudFwiO1xufTtcbmZ1bmN0aW9uIGlzUm9vdEVsZW1lbnQobm9kZSkge1xuICByZXR1cm4gW1wiaHRtbFwiLCBcImJvZHlcIiwgXCIjZG9jdW1lbnRcIl0uaW5jbHVkZXMoZ2V0Tm9kZU5hbWUobm9kZSkpO1xufVxudmFyIGlzTm9kZSA9IChlbCkgPT4gaXNPYmplY3QoZWwpICYmIGVsLm5vZGVUeXBlICE9PSB2b2lkIDA7XG52YXIgaXNTaGFkb3dSb290ID0gKGVsKSA9PiBpc05vZGUoZWwpICYmIGVsLm5vZGVUeXBlID09PSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFICYmIFwiaG9zdFwiIGluIGVsO1xuXG4vLyBzcmMvY29udGFpbnMudHNcbmZ1bmN0aW9uIGNvbnRhaW5zKHBhcmVudCwgY2hpbGQpIHtcbiAgaWYgKCFwYXJlbnQgfHwgIWNoaWxkKSByZXR1cm4gZmFsc2U7XG4gIGlmICghaXNIVE1MRWxlbWVudChwYXJlbnQpIHx8ICFpc0hUTUxFbGVtZW50KGNoaWxkKSkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gcGFyZW50ID09PSBjaGlsZCB8fCBwYXJlbnQuY29udGFpbnMoY2hpbGQpO1xufVxuXG4vLyBzcmMvZW52LnRzXG5mdW5jdGlvbiBnZXREb2N1bWVudChlbCkge1xuICBpZiAoaXNEb2N1bWVudChlbCkpIHJldHVybiBlbDtcbiAgaWYgKGlzV2luZG93KGVsKSkgcmV0dXJuIGVsLmRvY3VtZW50O1xuICByZXR1cm4gZWw/Lm93bmVyRG9jdW1lbnQgPz8gZG9jdW1lbnQ7XG59XG5mdW5jdGlvbiBnZXREb2N1bWVudEVsZW1lbnQoZWwpIHtcbiAgcmV0dXJuIGdldERvY3VtZW50KGVsKS5kb2N1bWVudEVsZW1lbnQ7XG59XG5mdW5jdGlvbiBnZXRXaW5kb3coZWwpIHtcbiAgaWYgKGlzU2hhZG93Um9vdChlbCkpIHJldHVybiBnZXRXaW5kb3coZWwuaG9zdCk7XG4gIGlmIChpc0RvY3VtZW50KGVsKSkgcmV0dXJuIGVsLmRlZmF1bHRWaWV3ID8/IHdpbmRvdztcbiAgaWYgKGlzSFRNTEVsZW1lbnQoZWwpKSByZXR1cm4gZWwub3duZXJEb2N1bWVudD8uZGVmYXVsdFZpZXcgPz8gd2luZG93O1xuICByZXR1cm4gd2luZG93O1xufVxuZnVuY3Rpb24gZ2V0QWN0aXZlRWxlbWVudChlbCkge1xuICBjb25zdCBkb2MgPSBnZXREb2N1bWVudChlbCk7XG4gIGxldCBhY3RpdmVFbGVtZW50ID0gZG9jLmFjdGl2ZUVsZW1lbnQ7XG4gIHdoaWxlIChhY3RpdmVFbGVtZW50Py5zaGFkb3dSb290KSB7XG4gICAgY29uc3QgZWwyID0gYWN0aXZlRWxlbWVudC5zaGFkb3dSb290LmFjdGl2ZUVsZW1lbnQ7XG4gICAgaWYgKGVsMiA9PT0gYWN0aXZlRWxlbWVudCkgYnJlYWs7XG4gICAgZWxzZSBhY3RpdmVFbGVtZW50ID0gZWwyO1xuICB9XG4gIHJldHVybiBhY3RpdmVFbGVtZW50O1xufVxuXG4vLyBzcmMvZGF0YS11cmwudHNcbmZ1bmN0aW9uIGdldERhdGFVcmwoc3ZnLCBvcHRzKSB7XG4gIGNvbnN0IHsgdHlwZSwgcXVhbGl0eSA9IDAuOTIgfSA9IG9wdHM7XG4gIGlmICghc3ZnKSB0aHJvdyBuZXcgRXJyb3IoXCJbZ2V0LWRhdGEtdXJsXTogY291bGQgbm90IGZpbmQgdGhlIHN2ZyBlbGVtZW50XCIpO1xuICBjb25zdCB3aW4gPSBnZXRXaW5kb3coc3ZnKTtcbiAgY29uc3QgZG9jID0gd2luLmRvY3VtZW50O1xuICBjb25zdCBzZXJpYWxpemVyID0gbmV3IHdpbi5YTUxTZXJpYWxpemVyKCk7XG4gIGNvbnN0IHNvdXJjZSA9ICc8P3htbCB2ZXJzaW9uPVwiMS4wXCIgc3RhbmRhbG9uZT1cIm5vXCI/PlxcclxcbicgKyBzZXJpYWxpemVyLnNlcmlhbGl6ZVRvU3RyaW5nKHN2Zyk7XG4gIGNvbnN0IHN2Z1N0cmluZyA9IFwiZGF0YTppbWFnZS9zdmcreG1sO2NoYXJzZXQ9dXRmLTgsXCIgKyBlbmNvZGVVUklDb21wb25lbnQoc291cmNlKTtcbiAgaWYgKHR5cGUgPT09IFwiaW1hZ2Uvc3ZnK3htbFwiKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShzdmdTdHJpbmcpO1xuICB9XG4gIGNvbnN0IHN2Z0JvdW5kcyA9IHN2Zy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgY29uc3QgZHByID0gd2luLmRldmljZVBpeGVsUmF0aW8gfHwgMTtcbiAgY29uc3QgY2FudmFzID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gIGNvbnN0IGltYWdlID0gbmV3IHdpbi5JbWFnZSgpO1xuICBpbWFnZS5zcmMgPSBzdmdTdHJpbmc7XG4gIGNhbnZhcy53aWR0aCA9IHN2Z0JvdW5kcy53aWR0aCAqIGRwcjtcbiAgY2FudmFzLmhlaWdodCA9IHN2Z0JvdW5kcy5oZWlnaHQgKiBkcHI7XG4gIGNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICBjb250ZXh0LnNjYWxlKGRwciwgZHByKTtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgaW1hZ2Uub25sb2FkID0gKCkgPT4ge1xuICAgICAgY29udGV4dC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDApO1xuICAgICAgcmVzb2x2ZShjYW52YXMudG9EYXRhVVJMKHR5cGUsIHF1YWxpdHkpKTtcbiAgICB9O1xuICB9KTtcbn1cblxuLy8gc3JjL3BsYXRmb3JtLnRzXG52YXIgaXNEb20gPSAoKSA9PiB0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCI7XG5mdW5jdGlvbiBnZXRQbGF0Zm9ybSgpIHtcbiAgY29uc3QgYWdlbnQgPSBuYXZpZ2F0b3IudXNlckFnZW50RGF0YTtcbiAgcmV0dXJuIGFnZW50Py5wbGF0Zm9ybSA/PyBuYXZpZ2F0b3IucGxhdGZvcm07XG59XG52YXIgcHQgPSAodikgPT4gaXNEb20oKSAmJiB2LnRlc3QoZ2V0UGxhdGZvcm0oKSk7XG52YXIgdWEgPSAodikgPT4gaXNEb20oKSAmJiB2LnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG52YXIgdm4gPSAodikgPT4gaXNEb20oKSAmJiB2LnRlc3QobmF2aWdhdG9yLnZlbmRvcik7XG52YXIgaXNUb3VjaERldmljZSA9ICgpID0+IGlzRG9tKCkgJiYgISFuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHM7XG52YXIgaXNNYWMgPSAoKSA9PiBwdCgvXk1hYy8pO1xudmFyIGlzU2FmYXJpID0gKCkgPT4gaXNBcHBsZSgpICYmIHZuKC9hcHBsZS9pKTtcbnZhciBpc0ZpcmVmb3ggPSAoKSA9PiB1YSgvZmlyZWZveFxcLy9pKTtcbnZhciBpc0FwcGxlID0gKCkgPT4gcHQoL21hY3xpcGhvbmV8aXBhZHxpcG9kL2kpO1xudmFyIGlzSW9zID0gKCkgPT4gcHQoL2lQKGhvbmV8YWR8b2QpfGlPUy8pO1xudmFyIGlzV2ViS2l0ID0gKCkgPT4gdWEoL0FwcGxlV2ViS2l0Lyk7XG52YXIgaXNNb2RLZXkgPSAoZXZlbnQpID0+IGlzQXBwbGUoKSA/IGV2ZW50Lm1ldGFLZXkgOiBldmVudC5jdHJsS2V5O1xuXG4vLyBzcmMvZXZlbnQudHNcbmZ1bmN0aW9uIGdldEJlZm9yZUlucHV0VmFsdWUoZXZlbnQpIHtcbiAgY29uc3QgeyBzZWxlY3Rpb25TdGFydCwgc2VsZWN0aW9uRW5kLCB2YWx1ZSB9ID0gZXZlbnQuY3VycmVudFRhcmdldDtcbiAgcmV0dXJuIHZhbHVlLnNsaWNlKDAsIHNlbGVjdGlvblN0YXJ0KSArIGV2ZW50LmRhdGEgKyB2YWx1ZS5zbGljZShzZWxlY3Rpb25FbmQpO1xufVxuZnVuY3Rpb24gZ2V0Q29tcG9zZWRQYXRoKGV2ZW50KSB7XG4gIHJldHVybiBldmVudC5jb21wb3NlZFBhdGg/LigpID8/IGV2ZW50Lm5hdGl2ZUV2ZW50Py5jb21wb3NlZFBhdGg/LigpO1xufVxuZnVuY3Rpb24gZ2V0RXZlbnRUYXJnZXQoZXZlbnQpIHtcbiAgY29uc3QgY29tcG9zZWRQYXRoID0gZ2V0Q29tcG9zZWRQYXRoKGV2ZW50KTtcbiAgcmV0dXJuIGNvbXBvc2VkUGF0aD8uWzBdID8/IGV2ZW50LnRhcmdldDtcbn1cbnZhciBpc1NlbGZUYXJnZXQgPSAoZXZlbnQpID0+IHtcbiAgcmV0dXJuIGNvbnRhaW5zKGV2ZW50LmN1cnJlbnRUYXJnZXQsIGdldEV2ZW50VGFyZ2V0KGV2ZW50KSk7XG59O1xuZnVuY3Rpb24gaXNPcGVuaW5nSW5OZXdUYWIoZXZlbnQpIHtcbiAgY29uc3QgZWxlbWVudCA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gIGlmICghZWxlbWVudCkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBpc0FwcGxlRGV2aWNlID0gaXNBcHBsZSgpO1xuICBpZiAoaXNBcHBsZURldmljZSAmJiAhZXZlbnQubWV0YUtleSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoIWlzQXBwbGVEZXZpY2UgJiYgIWV2ZW50LmN0cmxLZXkpIHJldHVybiBmYWxzZTtcbiAgY29uc3QgbG9jYWxOYW1lID0gZWxlbWVudC5sb2NhbE5hbWU7XG4gIGlmIChsb2NhbE5hbWUgPT09IFwiYVwiKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKGxvY2FsTmFtZSA9PT0gXCJidXR0b25cIiAmJiBlbGVtZW50LnR5cGUgPT09IFwic3VibWl0XCIpIHJldHVybiB0cnVlO1xuICBpZiAobG9jYWxOYW1lID09PSBcImlucHV0XCIgJiYgZWxlbWVudC50eXBlID09PSBcInN1Ym1pdFwiKSByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNEb3dubG9hZGluZ0V2ZW50KGV2ZW50KSB7XG4gIGNvbnN0IGVsZW1lbnQgPSBldmVudC5jdXJyZW50VGFyZ2V0O1xuICBpZiAoIWVsZW1lbnQpIHJldHVybiBmYWxzZTtcbiAgY29uc3QgbG9jYWxOYW1lID0gZWxlbWVudC5sb2NhbE5hbWU7XG4gIGlmICghZXZlbnQuYWx0S2V5KSByZXR1cm4gZmFsc2U7XG4gIGlmIChsb2NhbE5hbWUgPT09IFwiYVwiKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKGxvY2FsTmFtZSA9PT0gXCJidXR0b25cIiAmJiBlbGVtZW50LnR5cGUgPT09IFwic3VibWl0XCIpIHJldHVybiB0cnVlO1xuICBpZiAobG9jYWxOYW1lID09PSBcImlucHV0XCIgJiYgZWxlbWVudC50eXBlID09PSBcInN1Ym1pdFwiKSByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNDb21wb3NpbmdFdmVudChldmVudCkge1xuICByZXR1cm4gZXZlbnQubmF0aXZlRXZlbnQ/LmlzQ29tcG9zaW5nID8/IGV2ZW50LmlzQ29tcG9zaW5nO1xufVxuXG4vLyBzcmMvZ2V0LWJ5LWlkLnRzXG52YXIgZGVmYXVsdEl0ZW1Ub0lkID0gKHYpID0+IHYuaWQ7XG5mdW5jdGlvbiBpdGVtQnlJZCh2LCBpZCwgaXRlbVRvSWQgPSBkZWZhdWx0SXRlbVRvSWQpIHtcbiAgcmV0dXJuIHYuZmluZCgoaXRlbSkgPT4gaXRlbVRvSWQoaXRlbSkgPT09IGlkKTtcbn1cbmZ1bmN0aW9uIGluZGV4T2ZJZCh2LCBpZCwgaXRlbVRvSWQgPSBkZWZhdWx0SXRlbVRvSWQpIHtcbiAgY29uc3QgaXRlbSA9IGl0ZW1CeUlkKHYsIGlkLCBpdGVtVG9JZCk7XG4gIHJldHVybiBpdGVtID8gdi5pbmRleE9mKGl0ZW0pIDogLTE7XG59XG5mdW5jdGlvbiBuZXh0QnlJZCh2LCBpZCwgbG9vcCA9IHRydWUpIHtcbiAgbGV0IGlkeCA9IGluZGV4T2ZJZCh2LCBpZCk7XG4gIGlkeCA9IGxvb3AgPyAoaWR4ICsgMSkgJSB2Lmxlbmd0aCA6IE1hdGgubWluKGlkeCArIDEsIHYubGVuZ3RoIC0gMSk7XG4gIHJldHVybiB2W2lkeF07XG59XG5mdW5jdGlvbiBwcmV2QnlJZCh2LCBpZCwgbG9vcCA9IHRydWUpIHtcbiAgbGV0IGlkeCA9IGluZGV4T2ZJZCh2LCBpZCk7XG4gIGlmIChpZHggPT09IC0xKSByZXR1cm4gbG9vcCA/IHZbdi5sZW5ndGggLSAxXSA6IG51bGw7XG4gIGlkeCA9IGxvb3AgPyAoaWR4IC0gMSArIHYubGVuZ3RoKSAlIHYubGVuZ3RoIDogTWF0aC5tYXgoMCwgaWR4IC0gMSk7XG4gIHJldHVybiB2W2lkeF07XG59XG5cbi8vIHNyYy9zYW5pdGl6ZS50c1xudmFyIHNhbml0aXplID0gKHN0cikgPT4gc3RyLnNwbGl0KFwiXCIpLm1hcCgoY2hhcikgPT4ge1xuICBjb25zdCBjb2RlID0gY2hhci5jaGFyQ29kZUF0KDApO1xuICBpZiAoY29kZSA+IDAgJiYgY29kZSA8IDEyOCkgcmV0dXJuIGNoYXI7XG4gIGlmIChjb2RlID49IDEyOCAmJiBjb2RlIDw9IDI1NSkgcmV0dXJuIGAveCR7Y29kZS50b1N0cmluZygxNil9YC5yZXBsYWNlKFwiL1wiLCBcIlxcXFxcIik7XG4gIHJldHVybiBcIlwiO1xufSkuam9pbihcIlwiKS50cmltKCk7XG5cbi8vIHNyYy9nZXQtYnktdGV4dC50c1xudmFyIGdldFZhbHVlVGV4dCA9IChpdGVtKSA9PiBzYW5pdGl6ZShpdGVtLmRhdGFzZXQudmFsdWV0ZXh0ID8/IGl0ZW0udGV4dENvbnRlbnQgPz8gXCJcIik7XG52YXIgbWF0Y2ggPSAodmFsdWVUZXh0LCBxdWVyeTIpID0+IHZhbHVlVGV4dC50cmltKCkudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKHF1ZXJ5Mi50b0xvd2VyQ2FzZSgpKTtcbnZhciB3cmFwID0gKHYsIGlkeCkgPT4ge1xuICByZXR1cm4gdi5tYXAoKF8sIGluZGV4KSA9PiB2WyhNYXRoLm1heChpZHgsIDApICsgaW5kZXgpICUgdi5sZW5ndGhdKTtcbn07XG5mdW5jdGlvbiBnZXRCeVRleHQodiwgdGV4dCwgY3VycmVudElkLCBpdGVtVG9JZCA9IGRlZmF1bHRJdGVtVG9JZCkge1xuICBjb25zdCBpbmRleCA9IGN1cnJlbnRJZCA/IGluZGV4T2ZJZCh2LCBjdXJyZW50SWQsIGl0ZW1Ub0lkKSA6IC0xO1xuICBsZXQgaXRlbXMgPSBjdXJyZW50SWQgPyB3cmFwKHYsIGluZGV4KSA6IHY7XG4gIGNvbnN0IGlzU2luZ2xlS2V5ID0gdGV4dC5sZW5ndGggPT09IDE7XG4gIGlmIChpc1NpbmdsZUtleSkge1xuICAgIGl0ZW1zID0gaXRlbXMuZmlsdGVyKChpdGVtKSA9PiBpdGVtVG9JZChpdGVtKSAhPT0gY3VycmVudElkKTtcbiAgfVxuICByZXR1cm4gaXRlbXMuZmluZCgoaXRlbSkgPT4gbWF0Y2goZ2V0VmFsdWVUZXh0KGl0ZW0pLCB0ZXh0KSk7XG59XG5cbi8vIHNyYy9nZXQtYnktdHlwZWFoZWFkLnRzXG5mdW5jdGlvbiBnZXRCeVR5cGVhaGVhZEltcGwoX2l0ZW1zLCBvcHRpb25zKSB7XG4gIGNvbnN0IHsgc3RhdGUsIGFjdGl2ZUlkLCBrZXksIHRpbWVvdXQgPSAzNTAsIGl0ZW1Ub0lkIH0gPSBvcHRpb25zO1xuICBjb25zdCBzZWFyY2ggPSBzdGF0ZS5rZXlzU29GYXIgKyBrZXk7XG4gIGNvbnN0IGlzUmVwZWF0ZWQgPSBzZWFyY2gubGVuZ3RoID4gMSAmJiBBcnJheS5mcm9tKHNlYXJjaCkuZXZlcnkoKGNoYXIpID0+IGNoYXIgPT09IHNlYXJjaFswXSk7XG4gIGNvbnN0IHF1ZXJ5MiA9IGlzUmVwZWF0ZWQgPyBzZWFyY2hbMF0gOiBzZWFyY2g7XG4gIGxldCBpdGVtcyA9IF9pdGVtcy5zbGljZSgpO1xuICBjb25zdCBuZXh0ID0gZ2V0QnlUZXh0KGl0ZW1zLCBxdWVyeTIsIGFjdGl2ZUlkLCBpdGVtVG9JZCk7XG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHN0YXRlLnRpbWVyKTtcbiAgICBzdGF0ZS50aW1lciA9IC0xO1xuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZSh2YWx1ZSkge1xuICAgIHN0YXRlLmtleXNTb0ZhciA9IHZhbHVlO1xuICAgIGNsZWFudXAoKTtcbiAgICBpZiAodmFsdWUgIT09IFwiXCIpIHtcbiAgICAgIHN0YXRlLnRpbWVyID0gK3NldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB1cGRhdGUoXCJcIik7XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgIH0sIHRpbWVvdXQpO1xuICAgIH1cbiAgfVxuICB1cGRhdGUoc2VhcmNoKTtcbiAgcmV0dXJuIG5leHQ7XG59XG52YXIgZ2V0QnlUeXBlYWhlYWQgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmFzc2lnbihnZXRCeVR5cGVhaGVhZEltcGwsIHtcbiAgZGVmYXVsdE9wdGlvbnM6IHsga2V5c1NvRmFyOiBcIlwiLCB0aW1lcjogLTEgfSxcbiAgaXNWYWxpZEV2ZW50OiBpc1ZhbGlkVHlwZWFoZWFkRXZlbnRcbn0pO1xuZnVuY3Rpb24gaXNWYWxpZFR5cGVhaGVhZEV2ZW50KGV2ZW50KSB7XG4gIHJldHVybiBldmVudC5rZXkubGVuZ3RoID09PSAxICYmICFldmVudC5jdHJsS2V5ICYmICFldmVudC5tZXRhS2V5O1xufVxuXG4vLyBzcmMvZ2V0LWNvbXB1dGVkLXN0eWxlLnRzXG52YXIgc3R5bGVDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gZ2V0Q29tcHV0ZWRTdHlsZShlbCkge1xuICBpZiAoIXN0eWxlQ2FjaGUuaGFzKGVsKSkge1xuICAgIHN0eWxlQ2FjaGUuc2V0KGVsLCBnZXRXaW5kb3coZWwpLmdldENvbXB1dGVkU3R5bGUoZWwpKTtcbiAgfVxuICByZXR1cm4gc3R5bGVDYWNoZS5nZXQoZWwpO1xufVxuXG4vLyBzcmMvZ2V0LXBhcmVudC1ub2RlLnRzXG5mdW5jdGlvbiBnZXRQYXJlbnROb2RlKG5vZGUpIHtcbiAgaWYgKGdldE5vZGVOYW1lKG5vZGUpID09PSBcImh0bWxcIikge1xuICAgIHJldHVybiBub2RlO1xuICB9XG4gIGNvbnN0IHJlc3VsdCA9IChcbiAgICAvLyBTdGVwIGludG8gdGhlIHNoYWRvdyBET00gb2YgdGhlIHBhcmVudCBvZiBhIHNsb3R0ZWQgbm9kZS5cbiAgICBub2RlLmFzc2lnbmVkU2xvdCB8fCAvLyBET00gRWxlbWVudCBkZXRlY3RlZC5cbiAgICBub2RlLnBhcmVudE5vZGUgfHwgLy8gU2hhZG93Um9vdCBkZXRlY3RlZC5cbiAgICBpc1NoYWRvd1Jvb3Qobm9kZSkgJiYgbm9kZS5ob3N0IHx8IC8vIEZhbGxiYWNrLlxuICAgIGdldERvY3VtZW50RWxlbWVudChub2RlKVxuICApO1xuICByZXR1cm4gaXNTaGFkb3dSb290KHJlc3VsdCkgPyByZXN1bHQuaG9zdCA6IHJlc3VsdDtcbn1cblxuLy8gc3JjL2dldC1zY3JvbGwtcG9zaXRpb24udHNcbmZ1bmN0aW9uIGdldFNjcm9sbFBvc2l0aW9uKGVsZW1lbnQpIHtcbiAgaWYgKGlzSFRNTEVsZW1lbnQoZWxlbWVudCkpIHtcbiAgICByZXR1cm4geyBzY3JvbGxMZWZ0OiBlbGVtZW50LnNjcm9sbExlZnQsIHNjcm9sbFRvcDogZWxlbWVudC5zY3JvbGxUb3AgfTtcbiAgfVxuICByZXR1cm4geyBzY3JvbGxMZWZ0OiBlbGVtZW50LnNjcm9sbFgsIHNjcm9sbFRvcDogZWxlbWVudC5zY3JvbGxZIH07XG59XG5cbi8vIHNyYy90YWJiYWJsZS50c1xudmFyIGlzSFRNTEVsZW1lbnQyID0gKGVsZW1lbnQpID0+IHR5cGVvZiBlbGVtZW50ID09PSBcIm9iamVjdFwiICYmIGVsZW1lbnQgIT09IG51bGwgJiYgZWxlbWVudC5ub2RlVHlwZSA9PT0gMTtcbnZhciBpc0ZyYW1lID0gKGVsZW1lbnQpID0+IGlzSFRNTEVsZW1lbnQyKGVsZW1lbnQpICYmIGVsZW1lbnQudGFnTmFtZSA9PT0gXCJJRlJBTUVcIjtcbmZ1bmN0aW9uIGlzVmlzaWJsZShlbCkge1xuICBpZiAoIWlzSFRNTEVsZW1lbnQyKGVsKSkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gZWwub2Zmc2V0V2lkdGggPiAwIHx8IGVsLm9mZnNldEhlaWdodCA+IDAgfHwgZWwuZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggPiAwO1xufVxuZnVuY3Rpb24gaGFzTmVnYXRpdmVUYWJJbmRleChlbGVtZW50KSB7XG4gIGNvbnN0IHRhYkluZGV4ID0gcGFyc2VJbnQoZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiKSB8fCBcIjBcIiwgMTApO1xuICByZXR1cm4gdGFiSW5kZXggPCAwO1xufVxudmFyIGZvY3VzYWJsZVNlbGVjdG9yID0gXCJpbnB1dDpub3QoW3R5cGU9J2hpZGRlbiddKTpub3QoW2Rpc2FibGVkXSksIHNlbGVjdDpub3QoW2Rpc2FibGVkXSksIHRleHRhcmVhOm5vdChbZGlzYWJsZWRdKSwgYVtocmVmXSwgYnV0dG9uOm5vdChbZGlzYWJsZWRdKSwgW3RhYmluZGV4XSwgaWZyYW1lLCBvYmplY3QsIGVtYmVkLCBhcmVhW2hyZWZdLCBhdWRpb1tjb250cm9sc10sIHZpZGVvW2NvbnRyb2xzXSwgW2NvbnRlbnRlZGl0YWJsZV06bm90KFtjb250ZW50ZWRpdGFibGU9J2ZhbHNlJ10pLCBkZXRhaWxzID4gc3VtbWFyeTpmaXJzdC1vZi10eXBlXCI7XG52YXIgZ2V0Rm9jdXNhYmxlcyA9IChjb250YWluZXIsIGluY2x1ZGVDb250YWluZXIgPSBmYWxzZSkgPT4ge1xuICBpZiAoIWNvbnRhaW5lcikgcmV0dXJuIFtdO1xuICBjb25zdCBlbGVtZW50cyA9IEFycmF5LmZyb20oY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoZm9jdXNhYmxlU2VsZWN0b3IpKTtcbiAgY29uc3QgaW5jbHVkZSA9IGluY2x1ZGVDb250YWluZXIgPT0gdHJ1ZSB8fCBpbmNsdWRlQ29udGFpbmVyID09IFwiaWYtZW1wdHlcIiAmJiBlbGVtZW50cy5sZW5ndGggPT09IDA7XG4gIGlmIChpbmNsdWRlICYmIGlzSFRNTEVsZW1lbnQyKGNvbnRhaW5lcikgJiYgaXNGb2N1c2FibGUoY29udGFpbmVyKSkge1xuICAgIGVsZW1lbnRzLnVuc2hpZnQoY29udGFpbmVyKTtcbiAgfVxuICBjb25zdCBmb2N1c2FibGVFbGVtZW50cyA9IGVsZW1lbnRzLmZpbHRlcihpc0ZvY3VzYWJsZSk7XG4gIGZvY3VzYWJsZUVsZW1lbnRzLmZvckVhY2goKGVsZW1lbnQsIGkpID0+IHtcbiAgICBpZiAoaXNGcmFtZShlbGVtZW50KSAmJiBlbGVtZW50LmNvbnRlbnREb2N1bWVudCkge1xuICAgICAgY29uc3QgZnJhbWVCb2R5ID0gZWxlbWVudC5jb250ZW50RG9jdW1lbnQuYm9keTtcbiAgICAgIGZvY3VzYWJsZUVsZW1lbnRzLnNwbGljZShpLCAxLCAuLi5nZXRGb2N1c2FibGVzKGZyYW1lQm9keSkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBmb2N1c2FibGVFbGVtZW50cztcbn07XG5mdW5jdGlvbiBpc0ZvY3VzYWJsZShlbGVtZW50KSB7XG4gIGlmICghZWxlbWVudCB8fCBlbGVtZW50LmNsb3Nlc3QoXCJbaW5lcnRdXCIpKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBlbGVtZW50Lm1hdGNoZXMoZm9jdXNhYmxlU2VsZWN0b3IpICYmIGlzVmlzaWJsZShlbGVtZW50KTtcbn1cbmZ1bmN0aW9uIGdldEZpcnN0Rm9jdXNhYmxlKGNvbnRhaW5lciwgaW5jbHVkZUNvbnRhaW5lcikge1xuICBjb25zdCBbZmlyc3RdID0gZ2V0Rm9jdXNhYmxlcyhjb250YWluZXIsIGluY2x1ZGVDb250YWluZXIpO1xuICByZXR1cm4gZmlyc3QgfHwgbnVsbDtcbn1cbmZ1bmN0aW9uIGdldFRhYmJhYmxlcyhjb250YWluZXIsIGluY2x1ZGVDb250YWluZXIpIHtcbiAgaWYgKCFjb250YWluZXIpIHJldHVybiBbXTtcbiAgY29uc3QgZWxlbWVudHMgPSBBcnJheS5mcm9tKGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKGZvY3VzYWJsZVNlbGVjdG9yKSk7XG4gIGNvbnN0IHRhYmJhYmxlRWxlbWVudHMgPSBlbGVtZW50cy5maWx0ZXIoaXNUYWJiYWJsZSk7XG4gIGlmIChpbmNsdWRlQ29udGFpbmVyICYmIGlzVGFiYmFibGUoY29udGFpbmVyKSkge1xuICAgIHRhYmJhYmxlRWxlbWVudHMudW5zaGlmdChjb250YWluZXIpO1xuICB9XG4gIHRhYmJhYmxlRWxlbWVudHMuZm9yRWFjaCgoZWxlbWVudCwgaSkgPT4ge1xuICAgIGlmIChpc0ZyYW1lKGVsZW1lbnQpICYmIGVsZW1lbnQuY29udGVudERvY3VtZW50KSB7XG4gICAgICBjb25zdCBmcmFtZUJvZHkgPSBlbGVtZW50LmNvbnRlbnREb2N1bWVudC5ib2R5O1xuICAgICAgY29uc3QgYWxsRnJhbWVUYWJiYWJsZSA9IGdldFRhYmJhYmxlcyhmcmFtZUJvZHkpO1xuICAgICAgdGFiYmFibGVFbGVtZW50cy5zcGxpY2UoaSwgMSwgLi4uYWxsRnJhbWVUYWJiYWJsZSk7XG4gICAgfVxuICB9KTtcbiAgaWYgKCF0YWJiYWJsZUVsZW1lbnRzLmxlbmd0aCAmJiBpbmNsdWRlQ29udGFpbmVyKSB7XG4gICAgcmV0dXJuIGVsZW1lbnRzO1xuICB9XG4gIHJldHVybiB0YWJiYWJsZUVsZW1lbnRzO1xufVxuZnVuY3Rpb24gaXNUYWJiYWJsZShlbCkge1xuICBpZiAoZWwgIT0gbnVsbCAmJiBlbC50YWJJbmRleCA+IDApIHJldHVybiB0cnVlO1xuICByZXR1cm4gaXNGb2N1c2FibGUoZWwpICYmICFoYXNOZWdhdGl2ZVRhYkluZGV4KGVsKTtcbn1cbmZ1bmN0aW9uIGdldEZpcnN0VGFiYmFibGUoY29udGFpbmVyLCBpbmNsdWRlQ29udGFpbmVyKSB7XG4gIGNvbnN0IFtmaXJzdF0gPSBnZXRUYWJiYWJsZXMoY29udGFpbmVyLCBpbmNsdWRlQ29udGFpbmVyKTtcbiAgcmV0dXJuIGZpcnN0IHx8IG51bGw7XG59XG5mdW5jdGlvbiBnZXRMYXN0VGFiYmFibGUoY29udGFpbmVyLCBpbmNsdWRlQ29udGFpbmVyKSB7XG4gIGNvbnN0IGVsZW1lbnRzID0gZ2V0VGFiYmFibGVzKGNvbnRhaW5lciwgaW5jbHVkZUNvbnRhaW5lcik7XG4gIHJldHVybiBlbGVtZW50c1tlbGVtZW50cy5sZW5ndGggLSAxXSB8fCBudWxsO1xufVxuZnVuY3Rpb24gZ2V0VGFiYmFibGVFZGdlcyhjb250YWluZXIsIGluY2x1ZGVDb250YWluZXIpIHtcbiAgY29uc3QgZWxlbWVudHMgPSBnZXRUYWJiYWJsZXMoY29udGFpbmVyLCBpbmNsdWRlQ29udGFpbmVyKTtcbiAgY29uc3QgZmlyc3QgPSBlbGVtZW50c1swXSB8fCBudWxsO1xuICBjb25zdCBsYXN0ID0gZWxlbWVudHNbZWxlbWVudHMubGVuZ3RoIC0gMV0gfHwgbnVsbDtcbiAgcmV0dXJuIFtmaXJzdCwgbGFzdF07XG59XG5mdW5jdGlvbiBnZXROZXh0VGFiYmFibGUoY29udGFpbmVyLCBjdXJyZW50KSB7XG4gIGNvbnN0IHRhYmJhYmxlcyA9IGdldFRhYmJhYmxlcyhjb250YWluZXIpO1xuICBjb25zdCBkb2MgPSBjb250YWluZXI/Lm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQ7XG4gIGNvbnN0IGN1cnJlbnRFbGVtZW50ID0gY3VycmVudCA/PyBkb2MuYWN0aXZlRWxlbWVudDtcbiAgaWYgKCFjdXJyZW50RWxlbWVudCkgcmV0dXJuIG51bGw7XG4gIGNvbnN0IGluZGV4ID0gdGFiYmFibGVzLmluZGV4T2YoY3VycmVudEVsZW1lbnQpO1xuICByZXR1cm4gdGFiYmFibGVzW2luZGV4ICsgMV0gfHwgbnVsbDtcbn1cblxuLy8gc3JjL2luaXRpYWwtZm9jdXMudHNcbmZ1bmN0aW9uIGdldEluaXRpYWxGb2N1cyhvcHRpb25zKSB7XG4gIGNvbnN0IHsgcm9vdCwgZ2V0SW5pdGlhbEVsLCBmaWx0ZXIsIGVuYWJsZWQgPSB0cnVlIH0gPSBvcHRpb25zO1xuICBpZiAoIWVuYWJsZWQpIHJldHVybjtcbiAgbGV0IG5vZGUgPSBudWxsO1xuICBub2RlIHx8IChub2RlID0gdHlwZW9mIGdldEluaXRpYWxFbCA9PT0gXCJmdW5jdGlvblwiID8gZ2V0SW5pdGlhbEVsKCkgOiBnZXRJbml0aWFsRWwpO1xuICBub2RlIHx8IChub2RlID0gcm9vdD8ucXVlcnlTZWxlY3RvcihcIltkYXRhLWF1dG9mb2N1c10sW2F1dG9mb2N1c11cIikpO1xuICBpZiAoIW5vZGUpIHtcbiAgICBjb25zdCB0YWJiYWJsZXMgPSBnZXRUYWJiYWJsZXMocm9vdCk7XG4gICAgbm9kZSA9IGZpbHRlciA/IHRhYmJhYmxlcy5maWx0ZXIoZmlsdGVyKVswXSA6IHRhYmJhYmxlc1swXTtcbiAgfVxuICByZXR1cm4gbm9kZSB8fCByb290IHx8IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRUYWJFdmVudChldmVudCkge1xuICBjb25zdCBjb250YWluZXIgPSBldmVudC5jdXJyZW50VGFyZ2V0O1xuICBpZiAoIWNvbnRhaW5lcikgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBbZmlyc3RUYWJiYWJsZSwgbGFzdFRhYmJhYmxlXSA9IGdldFRhYmJhYmxlRWRnZXMoY29udGFpbmVyKTtcbiAgY29uc3QgZG9jID0gY29udGFpbmVyLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQ7XG4gIGlmIChkb2MuYWN0aXZlRWxlbWVudCA9PT0gZmlyc3RUYWJiYWJsZSAmJiBldmVudC5zaGlmdEtleSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoZG9jLmFjdGl2ZUVsZW1lbnQgPT09IGxhc3RUYWJiYWJsZSAmJiAhZXZlbnQuc2hpZnRLZXkpIHJldHVybiBmYWxzZTtcbiAgaWYgKCFmaXJzdFRhYmJhYmxlICYmICFsYXN0VGFiYmFibGUpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIHNyYy9pcy1lZGl0YWJsZS1lbGVtZW50LnRzXG5mdW5jdGlvbiBpc0VkaXRhYmxlRWxlbWVudChlbCkge1xuICBpZiAoZWwgPT0gbnVsbCB8fCAhaXNIVE1MRWxlbWVudChlbCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCB3aW4gPSBnZXRXaW5kb3coZWwpO1xuICAgIHJldHVybiBlbCBpbnN0YW5jZW9mIHdpbi5IVE1MSW5wdXRFbGVtZW50ICYmIGVsLnNlbGVjdGlvblN0YXJ0ICE9IG51bGwgfHwgLyh0ZXh0YXJlYXxzZWxlY3QpLy50ZXN0KGVsLmxvY2FsTmFtZSkgfHwgZWwuaXNDb250ZW50RWRpdGFibGU7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vLyBzcmMvaXMtaGlkZGVuLWVsZW1lbnQudHNcbmZ1bmN0aW9uIGlzSGlkZGVuRWxlbWVudChub2RlKSB7XG4gIGlmIChub2RlLnBhcmVudEVsZW1lbnQgJiYgaXNIaWRkZW5FbGVtZW50KG5vZGUucGFyZW50RWxlbWVudCkpIHJldHVybiB0cnVlO1xuICByZXR1cm4gbm9kZS5oaWRkZW47XG59XG5cbi8vIHNyYy9pcy1vdmVyZmxvdy1lbGVtZW50LnRzXG52YXIgT1ZFUkZMT1dfUkUgPSAvYXV0b3xzY3JvbGx8b3ZlcmxheXxoaWRkZW58Y2xpcC87XG5mdW5jdGlvbiBpc092ZXJmbG93RWxlbWVudChlbCkge1xuICBjb25zdCB3aW4gPSBnZXRXaW5kb3coZWwpO1xuICBjb25zdCB7IG92ZXJmbG93LCBvdmVyZmxvd1gsIG92ZXJmbG93WSwgZGlzcGxheSB9ID0gd2luLmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICByZXR1cm4gT1ZFUkZMT1dfUkUudGVzdChvdmVyZmxvdyArIG92ZXJmbG93WSArIG92ZXJmbG93WCkgJiYgIVtcImlubGluZVwiLCBcImNvbnRlbnRzXCJdLmluY2x1ZGVzKGRpc3BsYXkpO1xufVxuXG4vLyBzcmMvcmFmLnRzXG5mdW5jdGlvbiBuZXh0VGljayhmbikge1xuICBjb25zdCBzZXQyID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgZnVuY3Rpb24gcmFmMihmbjIpIHtcbiAgICBjb25zdCBpZCA9IGdsb2JhbFRoaXMucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZuMik7XG4gICAgc2V0Mi5hZGQoKCkgPT4gZ2xvYmFsVGhpcy5jYW5jZWxBbmltYXRpb25GcmFtZShpZCkpO1xuICB9XG4gIHJhZjIoKCkgPT4gcmFmMihmbikpO1xuICByZXR1cm4gZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBzZXQyLmZvckVhY2goKGZuMikgPT4gZm4yKCkpO1xuICB9O1xufVxuZnVuY3Rpb24gcmFmKGZuKSB7XG4gIGNvbnN0IGlkID0gZ2xvYmFsVGhpcy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZm4pO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGdsb2JhbFRoaXMuY2FuY2VsQW5pbWF0aW9uRnJhbWUoaWQpO1xuICB9O1xufVxuXG4vLyBzcmMvb2JzZXJ2ZS1hdHRyaWJ1dGVzLnRzXG5mdW5jdGlvbiBvYnNlcnZlQXR0cmlidXRlc0ltcGwobm9kZSwgb3B0aW9ucykge1xuICBpZiAoIW5vZGUpIHJldHVybjtcbiAgY29uc3QgeyBhdHRyaWJ1dGVzLCBjYWxsYmFjazogZm4gfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHdpbiA9IG5vZGUub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyB8fCB3aW5kb3c7XG4gIGNvbnN0IG9icyA9IG5ldyB3aW4uTXV0YXRpb25PYnNlcnZlcigoY2hhbmdlcykgPT4ge1xuICAgIGZvciAoY29uc3QgY2hhbmdlIG9mIGNoYW5nZXMpIHtcbiAgICAgIGlmIChjaGFuZ2UudHlwZSA9PT0gXCJhdHRyaWJ1dGVzXCIgJiYgY2hhbmdlLmF0dHJpYnV0ZU5hbWUgJiYgYXR0cmlidXRlcy5pbmNsdWRlcyhjaGFuZ2UuYXR0cmlidXRlTmFtZSkpIHtcbiAgICAgICAgZm4oY2hhbmdlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBvYnMub2JzZXJ2ZShub2RlLCB7IGF0dHJpYnV0ZXM6IHRydWUsIGF0dHJpYnV0ZUZpbHRlcjogYXR0cmlidXRlcyB9KTtcbiAgcmV0dXJuICgpID0+IG9icy5kaXNjb25uZWN0KCk7XG59XG5mdW5jdGlvbiBvYnNlcnZlQXR0cmlidXRlcyhub2RlT3JGbiwgb3B0aW9ucykge1xuICBjb25zdCB7IGRlZmVyIH0gPSBvcHRpb25zO1xuICBjb25zdCBmdW5jID0gZGVmZXIgPyByYWYgOiAodikgPT4gdigpO1xuICBjb25zdCBjbGVhbnVwczIgPSBbXTtcbiAgY2xlYW51cHMyLnB1c2goXG4gICAgZnVuYygoKSA9PiB7XG4gICAgICBjb25zdCBub2RlID0gdHlwZW9mIG5vZGVPckZuID09PSBcImZ1bmN0aW9uXCIgPyBub2RlT3JGbigpIDogbm9kZU9yRm47XG4gICAgICBjbGVhbnVwczIucHVzaChvYnNlcnZlQXR0cmlidXRlc0ltcGwobm9kZSwgb3B0aW9ucykpO1xuICAgIH0pXG4gICk7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgY2xlYW51cHMyLmZvckVhY2goKGZuKSA9PiBmbj8uKCkpO1xuICB9O1xufVxuXG4vLyBzcmMvb2JzZXJ2ZS1jaGlsZHJlbi50c1xuZnVuY3Rpb24gb2JzZXJ2ZUNoaWxkcmVuSW1wbChub2RlLCBvcHRpb25zKSB7XG4gIGNvbnN0IHsgY2FsbGJhY2s6IGZuIH0gPSBvcHRpb25zO1xuICBpZiAoIW5vZGUpIHJldHVybjtcbiAgY29uc3Qgd2luID0gbm9kZS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IHx8IHdpbmRvdztcbiAgY29uc3Qgb2JzID0gbmV3IHdpbi5NdXRhdGlvbk9ic2VydmVyKGZuKTtcbiAgb2JzLm9ic2VydmUobm9kZSwgeyBjaGlsZExpc3Q6IHRydWUsIHN1YnRyZWU6IHRydWUgfSk7XG4gIHJldHVybiAoKSA9PiBvYnMuZGlzY29ubmVjdCgpO1xufVxuZnVuY3Rpb24gb2JzZXJ2ZUNoaWxkcmVuKG5vZGVPckZuLCBvcHRpb25zKSB7XG4gIGNvbnN0IHsgZGVmZXIgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGZ1bmMgPSBkZWZlciA/IHJhZiA6ICh2KSA9PiB2KCk7XG4gIGNvbnN0IGNsZWFudXBzMiA9IFtdO1xuICBjbGVhbnVwczIucHVzaChcbiAgICBmdW5jKCgpID0+IHtcbiAgICAgIGNvbnN0IG5vZGUgPSB0eXBlb2Ygbm9kZU9yRm4gPT09IFwiZnVuY3Rpb25cIiA/IG5vZGVPckZuKCkgOiBub2RlT3JGbjtcbiAgICAgIGNsZWFudXBzMi5wdXNoKG9ic2VydmVDaGlsZHJlbkltcGwobm9kZSwgb3B0aW9ucykpO1xuICAgIH0pXG4gICk7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgY2xlYW51cHMyLmZvckVhY2goKGZuKSA9PiBmbj8uKCkpO1xuICB9O1xufVxuXG4vLyBzcmMvb3ZlcmZsb3cudHNcbmZ1bmN0aW9uIGdldE5lYXJlc3RPdmVyZmxvd0FuY2VzdG9yKGVsKSB7XG4gIGNvbnN0IHBhcmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKGVsKTtcbiAgaWYgKGlzUm9vdEVsZW1lbnQocGFyZW50Tm9kZSkpIHtcbiAgICByZXR1cm4gZ2V0RG9jdW1lbnQocGFyZW50Tm9kZSkuYm9keTtcbiAgfVxuICBpZiAoaXNIVE1MRWxlbWVudChwYXJlbnROb2RlKSAmJiBpc092ZXJmbG93RWxlbWVudChwYXJlbnROb2RlKSkge1xuICAgIHJldHVybiBwYXJlbnROb2RlO1xuICB9XG4gIHJldHVybiBnZXROZWFyZXN0T3ZlcmZsb3dBbmNlc3RvcihwYXJlbnROb2RlKTtcbn1cbmZ1bmN0aW9uIGdldE92ZXJmbG93QW5jZXN0b3JzKGVsLCBsaXN0ID0gW10pIHtcbiAgY29uc3Qgc2Nyb2xsYWJsZUFuY2VzdG9yID0gZ2V0TmVhcmVzdE92ZXJmbG93QW5jZXN0b3IoZWwpO1xuICBjb25zdCBpc0JvZHkgPSBzY3JvbGxhYmxlQW5jZXN0b3IgPT09IGVsLm93bmVyRG9jdW1lbnQuYm9keTtcbiAgY29uc3Qgd2luID0gZ2V0V2luZG93KHNjcm9sbGFibGVBbmNlc3Rvcik7XG4gIGlmIChpc0JvZHkpIHtcbiAgICByZXR1cm4gbGlzdC5jb25jYXQod2luLCB3aW4udmlzdWFsVmlld3BvcnQgfHwgW10sIGlzT3ZlcmZsb3dFbGVtZW50KHNjcm9sbGFibGVBbmNlc3RvcikgPyBzY3JvbGxhYmxlQW5jZXN0b3IgOiBbXSk7XG4gIH1cbiAgcmV0dXJuIGxpc3QuY29uY2F0KHNjcm9sbGFibGVBbmNlc3RvciwgZ2V0T3ZlcmZsb3dBbmNlc3RvcnMoc2Nyb2xsYWJsZUFuY2VzdG9yLCBbXSkpO1xufVxudmFyIGdldFJlY3QgPSAoZWwpID0+IHtcbiAgaWYgKGlzSFRNTEVsZW1lbnQoZWwpKSB7XG4gICAgcmV0dXJuIGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB9XG4gIGlmIChpc1Zpc3VhbFZpZXdwb3J0KGVsKSkge1xuICAgIHJldHVybiB7IHRvcDogMCwgbGVmdDogMCwgYm90dG9tOiBlbC5oZWlnaHQsIHJpZ2h0OiBlbC53aWR0aCB9O1xuICB9XG4gIHJldHVybiB7IHRvcDogMCwgbGVmdDogMCwgYm90dG9tOiBlbC5pbm5lckhlaWdodCwgcmlnaHQ6IGVsLmlubmVyV2lkdGggfTtcbn07XG5mdW5jdGlvbiBpc0luVmlldyhlbCwgYW5jZXN0b3IpIHtcbiAgaWYgKCFpc0hUTUxFbGVtZW50KGVsKSkgcmV0dXJuIHRydWU7XG4gIGNvbnN0IGFuY2VzdG9yUmVjdCA9IGdldFJlY3QoYW5jZXN0b3IpO1xuICBjb25zdCBlbFJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgcmV0dXJuIGVsUmVjdC50b3AgPj0gYW5jZXN0b3JSZWN0LnRvcCAmJiBlbFJlY3QubGVmdCA+PSBhbmNlc3RvclJlY3QubGVmdCAmJiBlbFJlY3QuYm90dG9tIDw9IGFuY2VzdG9yUmVjdC5ib3R0b20gJiYgZWxSZWN0LnJpZ2h0IDw9IGFuY2VzdG9yUmVjdC5yaWdodDtcbn1cblxuLy8gc3JjL3Byb3h5LXRhYi1mb2N1cy50c1xuZnVuY3Rpb24gcHJveHlUYWJGb2N1c0ltcGwoY29udGFpbmVyLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgeyB0cmlnZ2VyRWxlbWVudCwgb25Gb2N1cyB9ID0gb3B0aW9ucztcbiAgY29uc3QgZG9jID0gY29udGFpbmVyPy5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50O1xuICBjb25zdCBib2R5ID0gZG9jLmJvZHk7XG4gIGZ1bmN0aW9uIG9uS2V5RG93bihldmVudCkge1xuICAgIGlmIChldmVudC5rZXkgIT09IFwiVGFiXCIpIHJldHVybjtcbiAgICBsZXQgZWxlbWVudFRvRm9jdXMgPSBudWxsO1xuICAgIGNvbnN0IFtmaXJzdFRhYmJhYmxlLCBsYXN0VGFiYmFibGVdID0gZ2V0VGFiYmFibGVFZGdlcyhjb250YWluZXIsIHRydWUpO1xuICAgIGNvbnN0IG5vVGFiYmFibGVFbGVtZW50cyA9ICFmaXJzdFRhYmJhYmxlICYmICFsYXN0VGFiYmFibGU7XG4gICAgaWYgKGV2ZW50LnNoaWZ0S2V5ICYmIChkb2MuYWN0aXZlRWxlbWVudCA9PT0gZmlyc3RUYWJiYWJsZSB8fCBub1RhYmJhYmxlRWxlbWVudHMpKSB7XG4gICAgICBlbGVtZW50VG9Gb2N1cyA9IHRyaWdnZXJFbGVtZW50O1xuICAgIH0gZWxzZSBpZiAoIWV2ZW50LnNoaWZ0S2V5ICYmIGRvYy5hY3RpdmVFbGVtZW50ID09PSB0cmlnZ2VyRWxlbWVudCkge1xuICAgICAgZWxlbWVudFRvRm9jdXMgPSBmaXJzdFRhYmJhYmxlO1xuICAgIH0gZWxzZSBpZiAoIWV2ZW50LnNoaWZ0S2V5ICYmIChkb2MuYWN0aXZlRWxlbWVudCA9PT0gbGFzdFRhYmJhYmxlIHx8IG5vVGFiYmFibGVFbGVtZW50cykpIHtcbiAgICAgIGVsZW1lbnRUb0ZvY3VzID0gZ2V0TmV4dFRhYmJhYmxlKGJvZHksIHRyaWdnZXJFbGVtZW50KTtcbiAgICB9XG4gICAgaWYgKCFlbGVtZW50VG9Gb2N1cykgcmV0dXJuO1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgaWYgKHR5cGVvZiBvbkZvY3VzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIG9uRm9jdXMoZWxlbWVudFRvRm9jdXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50VG9Gb2N1cy5mb2N1cygpO1xuICAgIH1cbiAgfVxuICBkb2M/LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIG9uS2V5RG93biwgdHJ1ZSk7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgZG9jPy5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBvbktleURvd24sIHRydWUpO1xuICB9O1xufVxuZnVuY3Rpb24gcHJveHlUYWJGb2N1cyhjb250YWluZXIsIG9wdGlvbnMpIHtcbiAgY29uc3QgeyBkZWZlciwgdHJpZ2dlckVsZW1lbnQsIC4uLnJlc3RPcHRpb25zIH0gPSBvcHRpb25zO1xuICBjb25zdCBmdW5jID0gZGVmZXIgPyByYWYgOiAodikgPT4gdigpO1xuICBjb25zdCBjbGVhbnVwczIgPSBbXTtcbiAgY2xlYW51cHMyLnB1c2goXG4gICAgZnVuYygoKSA9PiB7XG4gICAgICBjb25zdCBub2RlID0gdHlwZW9mIGNvbnRhaW5lciA9PT0gXCJmdW5jdGlvblwiID8gY29udGFpbmVyKCkgOiBjb250YWluZXI7XG4gICAgICBjb25zdCB0cmlnZ2VyID0gdHlwZW9mIHRyaWdnZXJFbGVtZW50ID09PSBcImZ1bmN0aW9uXCIgPyB0cmlnZ2VyRWxlbWVudCgpIDogdHJpZ2dlckVsZW1lbnQ7XG4gICAgICBjbGVhbnVwczIucHVzaChwcm94eVRhYkZvY3VzSW1wbChub2RlLCB7IHRyaWdnZXJFbGVtZW50OiB0cmlnZ2VyLCAuLi5yZXN0T3B0aW9ucyB9KSk7XG4gICAgfSlcbiAgKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBjbGVhbnVwczIuZm9yRWFjaCgoZm4pID0+IGZuPy4oKSk7XG4gIH07XG59XG5cbi8vIHNyYy9xdWVyeS50c1xuZnVuY3Rpb24gcXVlcnlBbGwocm9vdCwgc2VsZWN0b3IpIHtcbiAgcmV0dXJuIEFycmF5LmZyb20ocm9vdD8ucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikgPz8gW10pO1xufVxuZnVuY3Rpb24gcXVlcnkocm9vdCwgc2VsZWN0b3IpIHtcbiAgcmV0dXJuIHJvb3Q/LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpID8/IG51bGw7XG59XG5cbi8vIHNyYy9zY29wZS50c1xuZnVuY3Rpb24gY3JlYXRlU2NvcGUobWV0aG9kcykge1xuICBjb25zdCBkb20gPSB7XG4gICAgZ2V0Um9vdE5vZGU6IChjdHgpID0+IGN0eC5nZXRSb290Tm9kZT8uKCkgPz8gZG9jdW1lbnQsXG4gICAgZ2V0RG9jOiAoY3R4KSA9PiBnZXREb2N1bWVudChkb20uZ2V0Um9vdE5vZGUoY3R4KSksXG4gICAgZ2V0V2luOiAoY3R4KSA9PiBkb20uZ2V0RG9jKGN0eCkuZGVmYXVsdFZpZXcgPz8gd2luZG93LFxuICAgIGdldEFjdGl2ZUVsZW1lbnQ6IChjdHgpID0+IGRvbS5nZXRSb290Tm9kZShjdHgpLmFjdGl2ZUVsZW1lbnQsXG4gICAgaXNBY3RpdmVFbGVtZW50OiAoY3R4LCBlbGVtKSA9PiBlbGVtID09PSBkb20uZ2V0QWN0aXZlRWxlbWVudChjdHgpLFxuICAgIGdldEJ5SWQ6IChjdHgsIGlkKSA9PiBkb20uZ2V0Um9vdE5vZGUoY3R4KS5nZXRFbGVtZW50QnlJZChpZCksXG4gICAgc2V0VmFsdWU6IChlbGVtLCB2YWx1ZSkgPT4ge1xuICAgICAgaWYgKGVsZW0gPT0gbnVsbCB8fCB2YWx1ZSA9PSBudWxsKSByZXR1cm47XG4gICAgICBjb25zdCB2YWx1ZUFzU3RyaW5nID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgIGlmIChlbGVtLnZhbHVlID09PSB2YWx1ZUFzU3RyaW5nKSByZXR1cm47XG4gICAgICBlbGVtLnZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiB7IC4uLmRvbSwgLi4ubWV0aG9kcyB9O1xufVxuXG4vLyBzcmMvc2Nyb2xsLWludG8tdmlldy50c1xuZnVuY3Rpb24gaXNTY3JvbGxhYmxlKGVsKSB7XG4gIHJldHVybiBlbC5zY3JvbGxIZWlnaHQgPiBlbC5jbGllbnRIZWlnaHQgfHwgZWwuc2Nyb2xsV2lkdGggPiBlbC5jbGllbnRXaWR0aDtcbn1cbmZ1bmN0aW9uIHNjcm9sbEludG9WaWV3KGVsLCBvcHRpb25zKSB7XG4gIGNvbnN0IHsgcm9vdEVsLCAuLi5zY3JvbGxPcHRpb25zIH0gPSBvcHRpb25zIHx8IHt9O1xuICBpZiAoIWVsIHx8ICFyb290RWwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCFpc092ZXJmbG93RWxlbWVudChyb290RWwpIHx8ICFpc1Njcm9sbGFibGUocm9vdEVsKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBlbC5zY3JvbGxJbnRvVmlldyhzY3JvbGxPcHRpb25zKTtcbn1cblxuLy8gc3JjL3NldC50c1xudmFyIGNsZWFudXBzID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiBzZXQoZWxlbWVudCwga2V5LCBzZXR1cCkge1xuICBpZiAoIWNsZWFudXBzLmhhcyhlbGVtZW50KSkge1xuICAgIGNsZWFudXBzLnNldChlbGVtZW50LCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKTtcbiAgfVxuICBjb25zdCBlbGVtZW50Q2xlYW51cHMgPSBjbGVhbnVwcy5nZXQoZWxlbWVudCk7XG4gIGNvbnN0IHByZXZDbGVhbnVwID0gZWxlbWVudENsZWFudXBzLmdldChrZXkpO1xuICBpZiAoIXByZXZDbGVhbnVwKSB7XG4gICAgZWxlbWVudENsZWFudXBzLnNldChrZXksIHNldHVwKCkpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBlbGVtZW50Q2xlYW51cHMuZ2V0KGtleSk/LigpO1xuICAgICAgZWxlbWVudENsZWFudXBzLmRlbGV0ZShrZXkpO1xuICAgIH07XG4gIH1cbiAgY29uc3QgY2xlYW51cCA9IHNldHVwKCk7XG4gIGNvbnN0IG5leHRDbGVhbnVwID0gKCkgPT4ge1xuICAgIGNsZWFudXAoKTtcbiAgICBwcmV2Q2xlYW51cCgpO1xuICAgIGVsZW1lbnRDbGVhbnVwcy5kZWxldGUoa2V5KTtcbiAgfTtcbiAgZWxlbWVudENsZWFudXBzLnNldChrZXksIG5leHRDbGVhbnVwKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBjb25zdCBpc0N1cnJlbnQgPSBlbGVtZW50Q2xlYW51cHMuZ2V0KGtleSkgPT09IG5leHRDbGVhbnVwO1xuICAgIGlmICghaXNDdXJyZW50KSByZXR1cm47XG4gICAgY2xlYW51cCgpO1xuICAgIGVsZW1lbnRDbGVhbnVwcy5zZXQoa2V5LCBwcmV2Q2xlYW51cCk7XG4gIH07XG59XG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGUoZWxlbWVudCwgYXR0ciwgdmFsdWUpIHtcbiAgY29uc3Qgc2V0dXAgPSAoKSA9PiB7XG4gICAgY29uc3QgcHJldmlvdXNWYWx1ZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKGF0dHIpO1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGF0dHIsIHZhbHVlKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKHByZXZpb3VzVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShhdHRyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGF0dHIsIHByZXZpb3VzVmFsdWUpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG4gIHJldHVybiBzZXQoZWxlbWVudCwgYXR0ciwgc2V0dXApO1xufVxuZnVuY3Rpb24gc2V0UHJvcGVydHkoZWxlbWVudCwgcHJvcGVydHksIHZhbHVlKSB7XG4gIGNvbnN0IHNldHVwID0gKCkgPT4ge1xuICAgIGNvbnN0IGV4aXN0cyA9IHByb3BlcnR5IGluIGVsZW1lbnQ7XG4gICAgY29uc3QgcHJldmlvdXNWYWx1ZSA9IGVsZW1lbnRbcHJvcGVydHldO1xuICAgIGVsZW1lbnRbcHJvcGVydHldID0gdmFsdWU7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmICghZXhpc3RzKSB7XG4gICAgICAgIGRlbGV0ZSBlbGVtZW50W3Byb3BlcnR5XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnRbcHJvcGVydHldID0gcHJldmlvdXNWYWx1ZTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuICByZXR1cm4gc2V0KGVsZW1lbnQsIHByb3BlcnR5LCBzZXR1cCk7XG59XG5mdW5jdGlvbiBzZXRTdHlsZShlbGVtZW50LCBzdHlsZSkge1xuICBpZiAoIWVsZW1lbnQpIHJldHVybiAoKSA9PiB7XG4gIH07XG4gIGNvbnN0IHNldHVwID0gKCkgPT4ge1xuICAgIGNvbnN0IHByZXZTdHlsZSA9IGVsZW1lbnQuc3R5bGUuY3NzVGV4dDtcbiAgICBPYmplY3QuYXNzaWduKGVsZW1lbnQuc3R5bGUsIHN0eWxlKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgZWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gcHJldlN0eWxlO1xuICAgIH07XG4gIH07XG4gIHJldHVybiBzZXQoZWxlbWVudCwgXCJzdHlsZVwiLCBzZXR1cCk7XG59XG5cbi8vIHNyYy92aXN1YWxseS1oaWRkZW4udHNcbnZhciB2aXN1YWxseUhpZGRlblN0eWxlID0ge1xuICBib3JkZXI6IFwiMFwiLFxuICBjbGlwOiBcInJlY3QoMCAwIDAgMClcIixcbiAgaGVpZ2h0OiBcIjFweFwiLFxuICBtYXJnaW46IFwiLTFweFwiLFxuICBvdmVyZmxvdzogXCJoaWRkZW5cIixcbiAgcGFkZGluZzogXCIwXCIsXG4gIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gIHdpZHRoOiBcIjFweFwiLFxuICB3aGl0ZVNwYWNlOiBcIm5vd3JhcFwiLFxuICB3b3JkV3JhcDogXCJub3JtYWxcIlxufTtcblxuLy8gc3JjL3dhaXQtZm9yLnRzXG52YXIgZnBzID0gMWUzIC8gNjA7XG5mdW5jdGlvbiB3YWl0Rm9yRWxlbWVudChxdWVyeTIsIGNiKSB7XG4gIGNvbnN0IGVsID0gcXVlcnkyKCk7XG4gIGlmIChpc0hUTUxFbGVtZW50KGVsKSAmJiBlbC5pc0Nvbm5lY3RlZCkge1xuICAgIGNiKGVsKTtcbiAgICByZXR1cm4gKCkgPT4gdm9pZCAwO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHRpbWVySWQgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBjb25zdCBlbDIgPSBxdWVyeTIoKTtcbiAgICAgIGlmIChpc0hUTUxFbGVtZW50KGVsMikgJiYgZWwyLmlzQ29ubmVjdGVkKSB7XG4gICAgICAgIGNiKGVsMik7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGltZXJJZCk7XG4gICAgICB9XG4gICAgfSwgZnBzKTtcbiAgICByZXR1cm4gKCkgPT4gY2xlYXJJbnRlcnZhbCh0aW1lcklkKTtcbiAgfVxufVxuZnVuY3Rpb24gd2FpdEZvckVsZW1lbnRzKHF1ZXJpZXMsIGNiKSB7XG4gIGNvbnN0IGNsZWFudXBzMiA9IFtdO1xuICBxdWVyaWVzPy5mb3JFYWNoKChxdWVyeTIpID0+IHtcbiAgICBjb25zdCBjbGVhbiA9IHdhaXRGb3JFbGVtZW50KHF1ZXJ5MiwgY2IpO1xuICAgIGNsZWFudXBzMi5wdXNoKGNsZWFuKTtcbiAgfSk7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgY2xlYW51cHMyLmZvckVhY2goKGZuKSA9PiBmbigpKTtcbiAgfTtcbn1cbmV4cG9ydCB7XG4gIE1BWF9aX0lOREVYLFxuICBhcmlhQXR0cixcbiAgY29udGFpbnMsXG4gIGNyZWF0ZVNjb3BlLFxuICBkYXRhQXR0cixcbiAgZGVmYXVsdEl0ZW1Ub0lkLFxuICBnZXRBY3RpdmVFbGVtZW50LFxuICBnZXRCZWZvcmVJbnB1dFZhbHVlLFxuICBnZXRCeVRleHQsXG4gIGdldEJ5VHlwZWFoZWFkLFxuICBnZXRDb21wdXRlZFN0eWxlLFxuICBnZXREYXRhVXJsLFxuICBnZXREb2N1bWVudCxcbiAgZ2V0RG9jdW1lbnRFbGVtZW50LFxuICBnZXRFdmVudFRhcmdldCxcbiAgZ2V0Rmlyc3RGb2N1c2FibGUsXG4gIGdldEZpcnN0VGFiYmFibGUsXG4gIGdldEZvY3VzYWJsZXMsXG4gIGdldEluaXRpYWxGb2N1cyxcbiAgZ2V0TGFzdFRhYmJhYmxlLFxuICBnZXROZWFyZXN0T3ZlcmZsb3dBbmNlc3RvcixcbiAgZ2V0TmV4dFRhYmJhYmxlLFxuICBnZXROb2RlTmFtZSxcbiAgZ2V0T3ZlcmZsb3dBbmNlc3RvcnMsXG4gIGdldFBhcmVudE5vZGUsXG4gIGdldFBsYXRmb3JtLFxuICBnZXRTY3JvbGxQb3NpdGlvbixcbiAgZ2V0VGFiYmFibGVFZGdlcyxcbiAgZ2V0VGFiYmFibGVzLFxuICBnZXRXaW5kb3csXG4gIGluZGV4T2ZJZCxcbiAgaXNBcHBsZSxcbiAgaXNDb21wb3NpbmdFdmVudCxcbiAgaXNEb2N1bWVudCxcbiAgaXNEb20sXG4gIGlzRG93bmxvYWRpbmdFdmVudCxcbiAgaXNFZGl0YWJsZUVsZW1lbnQsXG4gIGlzRmlyZWZveCxcbiAgaXNGb2N1c2FibGUsXG4gIGlzSFRNTEVsZW1lbnQsXG4gIGlzSGlkZGVuRWxlbWVudCxcbiAgaXNJblZpZXcsXG4gIGlzSW9zLFxuICBpc01hYyxcbiAgaXNNb2RLZXksXG4gIGlzTm9kZSxcbiAgaXNPcGVuaW5nSW5OZXdUYWIsXG4gIGlzT3ZlcmZsb3dFbGVtZW50LFxuICBpc1Jvb3RFbGVtZW50LFxuICBpc1NhZmFyaSxcbiAgaXNTZWxmVGFyZ2V0LFxuICBpc1NoYWRvd1Jvb3QsXG4gIGlzVGFiYmFibGUsXG4gIGlzVG91Y2hEZXZpY2UsXG4gIGlzVmFsaWRUYWJFdmVudCxcbiAgaXNWaXN1YWxWaWV3cG9ydCxcbiAgaXNXZWJLaXQsXG4gIGlzV2luZG93LFxuICBpdGVtQnlJZCxcbiAgbmV4dEJ5SWQsXG4gIG5leHRUaWNrLFxuICBvYnNlcnZlQXR0cmlidXRlcyxcbiAgb2JzZXJ2ZUNoaWxkcmVuLFxuICBwcmV2QnlJZCxcbiAgcHJveHlUYWJGb2N1cyxcbiAgcXVlcnksXG4gIHF1ZXJ5QWxsLFxuICByYWYsXG4gIHNjcm9sbEludG9WaWV3LFxuICBzZXQsXG4gIHNldEF0dHJpYnV0ZSxcbiAgc2V0UHJvcGVydHksXG4gIHNldFN0eWxlLFxuICB2aXN1YWxseUhpZGRlblN0eWxlLFxuICB3YWl0Rm9yRWxlbWVudCxcbiAgd2FpdEZvckVsZW1lbnRzXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@zag-js/dom-query/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@zag-js/popper/dist/index.mjs":
/*!****************************************************!*\
  !*** ./node_modules/@zag-js/popper/dist/index.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getPlacement: () => (/* binding */ getPlacement),\n/* harmony export */   getPlacementSide: () => (/* binding */ getPlacementSide),\n/* harmony export */   getPlacementStyles: () => (/* binding */ getPlacementStyles),\n/* harmony export */   isValidPlacement: () => (/* binding */ isValidPlacement)\n/* harmony export */ });\n/* harmony import */ var _floating_ui_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @floating-ui/dom */ \"(ssr)/./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs\");\n/* harmony import */ var _zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @zag-js/dom-query */ \"(ssr)/./node_modules/@zag-js/dom-query/dist/index.mjs\");\n/* harmony import */ var _zag_js_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @zag-js/utils */ \"(ssr)/./node_modules/@zag-js/utils/dist/index.mjs\");\n// src/get-placement.ts\n\n\n\n\n// src/get-anchor.ts\n\nfunction createDOMRect(x = 0, y = 0, width = 0, height = 0) {\n  if (typeof DOMRect === \"function\") {\n    return new DOMRect(x, y, width, height);\n  }\n  const rect = {\n    x,\n    y,\n    width,\n    height,\n    top: y,\n    right: x + width,\n    bottom: y + height,\n    left: x\n  };\n  return { ...rect, toJSON: () => rect };\n}\nfunction getDOMRect(anchorRect) {\n  if (!anchorRect) return createDOMRect();\n  const { x, y, width, height } = anchorRect;\n  return createDOMRect(x, y, width, height);\n}\nfunction getAnchorElement(anchorElement, getAnchorRect) {\n  return {\n    contextElement: (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(anchorElement) ? anchorElement : void 0,\n    getBoundingClientRect: () => {\n      const anchor = anchorElement;\n      const anchorRect = getAnchorRect?.(anchor);\n      if (anchorRect || !anchor) {\n        return getDOMRect(anchorRect);\n      }\n      return anchor.getBoundingClientRect();\n    }\n  };\n}\n\n// src/middleware.ts\nvar toVar = (value) => ({ variable: value, reference: `var(${value})` });\nvar cssVars = {\n  arrowSize: toVar(\"--arrow-size\"),\n  arrowSizeHalf: toVar(\"--arrow-size-half\"),\n  arrowBg: toVar(\"--arrow-background\"),\n  transformOrigin: toVar(\"--transform-origin\"),\n  arrowOffset: toVar(\"--arrow-offset\")\n};\nvar getTransformOrigin = (arrow2) => ({\n  top: \"bottom center\",\n  \"top-start\": arrow2 ? `${arrow2.x}px bottom` : \"left bottom\",\n  \"top-end\": arrow2 ? `${arrow2.x}px bottom` : \"right bottom\",\n  bottom: \"top center\",\n  \"bottom-start\": arrow2 ? `${arrow2.x}px top` : \"top left\",\n  \"bottom-end\": arrow2 ? `${arrow2.x}px top` : \"top right\",\n  left: \"right center\",\n  \"left-start\": arrow2 ? `right ${arrow2.y}px` : \"right top\",\n  \"left-end\": arrow2 ? `right ${arrow2.y}px` : \"right bottom\",\n  right: \"left center\",\n  \"right-start\": arrow2 ? `left ${arrow2.y}px` : \"left top\",\n  \"right-end\": arrow2 ? `left ${arrow2.y}px` : \"left bottom\"\n});\nvar transformOriginMiddleware = {\n  name: \"transformOrigin\",\n  fn({ placement, elements, middlewareData }) {\n    const { arrow: arrow2 } = middlewareData;\n    const transformOrigin = getTransformOrigin(arrow2)[placement];\n    const { floating } = elements;\n    floating.style.setProperty(cssVars.transformOrigin.variable, transformOrigin);\n    return {\n      data: { transformOrigin }\n    };\n  }\n};\nvar rectMiddleware = {\n  name: \"rects\",\n  fn({ rects }) {\n    return {\n      data: rects\n    };\n  }\n};\nvar shiftArrowMiddleware = (arrowEl) => {\n  if (!arrowEl) return;\n  return {\n    name: \"shiftArrow\",\n    fn({ placement, middlewareData }) {\n      if (!middlewareData.arrow) return {};\n      const { x, y } = middlewareData.arrow;\n      const dir = placement.split(\"-\")[0];\n      Object.assign(arrowEl.style, {\n        left: x != null ? `${x}px` : \"\",\n        top: y != null ? `${y}px` : \"\",\n        [dir]: `calc(100% + ${cssVars.arrowOffset.reference})`\n      });\n      return {};\n    }\n  };\n};\n\n// src/placement.ts\nfunction isValidPlacement(v) {\n  return /^(?:top|bottom|left|right)(?:-(?:start|end))?$/.test(v);\n}\nfunction getPlacementDetails(placement) {\n  const [side, align] = placement.split(\"-\");\n  return { side, align, hasAlign: align != null };\n}\nfunction getPlacementSide(placement) {\n  return placement.split(\"-\")[0];\n}\n\n// src/get-placement.ts\nvar defaultOptions = {\n  strategy: \"absolute\",\n  placement: \"bottom\",\n  listeners: true,\n  gutter: 8,\n  flip: true,\n  slide: true,\n  overlap: false,\n  sameWidth: false,\n  fitViewport: false,\n  overflowPadding: 8,\n  arrowPadding: 4\n};\nfunction roundByDpr(win, value) {\n  const dpr = win.devicePixelRatio || 1;\n  return Math.round(value * dpr) / dpr;\n}\nfunction getBoundaryMiddleware(opts) {\n  return (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_1__.runIfFn)(opts.boundary);\n}\nfunction getArrowMiddleware(arrowElement, opts) {\n  if (!arrowElement) return;\n  return (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_2__.arrow)({\n    element: arrowElement,\n    padding: opts.arrowPadding\n  });\n}\nfunction getOffsetMiddleware(arrowElement, opts) {\n  if ((0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_1__.isNull)(opts.offset ?? opts.gutter)) return;\n  return (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_2__.offset)(({ placement }) => {\n    const arrowOffset = (arrowElement?.clientHeight || 0) / 2;\n    const gutter = opts.offset?.mainAxis ?? opts.gutter;\n    const mainAxis = typeof gutter === \"number\" ? gutter + arrowOffset : gutter ?? arrowOffset;\n    const { hasAlign } = getPlacementDetails(placement);\n    const shift2 = !hasAlign ? opts.shift : void 0;\n    const crossAxis = opts.offset?.crossAxis ?? shift2;\n    return (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_1__.compact)({\n      crossAxis,\n      mainAxis,\n      alignmentAxis: opts.shift\n    });\n  });\n}\nfunction getFlipMiddleware(opts) {\n  if (!opts.flip) return;\n  return (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_2__.flip)({\n    boundary: getBoundaryMiddleware(opts),\n    padding: opts.overflowPadding,\n    fallbackPlacements: opts.flip === true ? void 0 : opts.flip\n  });\n}\nfunction getShiftMiddleware(opts) {\n  if (!opts.slide && !opts.overlap) return;\n  return (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_2__.shift)({\n    boundary: getBoundaryMiddleware(opts),\n    mainAxis: opts.slide,\n    crossAxis: opts.overlap,\n    padding: opts.overflowPadding,\n    limiter: (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_2__.limitShift)()\n  });\n}\nfunction getSizeMiddleware(opts) {\n  return (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_2__.size)({\n    padding: opts.overflowPadding,\n    apply({ elements, rects, availableHeight, availableWidth }) {\n      const floating = elements.floating;\n      const referenceWidth = Math.round(rects.reference.width);\n      availableWidth = Math.floor(availableWidth);\n      availableHeight = Math.floor(availableHeight);\n      floating.style.setProperty(\"--reference-width\", `${referenceWidth}px`);\n      floating.style.setProperty(\"--available-width\", `${availableWidth}px`);\n      floating.style.setProperty(\"--available-height\", `${availableHeight}px`);\n    }\n  });\n}\nfunction getAutoUpdateOptions(opts) {\n  if (!opts) return {};\n  if (opts === true) {\n    return { ancestorResize: true, ancestorScroll: true, elementResize: true, layoutShift: true };\n  }\n  return opts;\n}\nfunction getPlacementImpl(referenceOrVirtual, floating, opts = {}) {\n  const reference = getAnchorElement(referenceOrVirtual, opts.getAnchorRect);\n  if (!floating || !reference) return;\n  const options = Object.assign({}, defaultOptions, opts);\n  const arrowEl = floating.querySelector(\"[data-part=arrow]\");\n  const middleware = [\n    getOffsetMiddleware(arrowEl, options),\n    getFlipMiddleware(options),\n    getShiftMiddleware(options),\n    getArrowMiddleware(arrowEl, options),\n    shiftArrowMiddleware(arrowEl),\n    transformOriginMiddleware,\n    getSizeMiddleware(options),\n    rectMiddleware\n  ];\n  const { placement, strategy, onComplete, onPositioned } = options;\n  const updatePosition = async () => {\n    if (!reference || !floating) return;\n    const pos = await (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_2__.computePosition)(reference, floating, {\n      placement,\n      middleware,\n      strategy\n    });\n    onComplete?.(pos);\n    onPositioned?.({ placed: true });\n    const win = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.getWindow)(floating);\n    const x = roundByDpr(win, pos.x);\n    const y = roundByDpr(win, pos.y);\n    floating.style.setProperty(\"--x\", `${x}px`);\n    floating.style.setProperty(\"--y\", `${y}px`);\n    const contentEl = floating.firstElementChild;\n    if (contentEl) {\n      const zIndex = win.getComputedStyle(contentEl).zIndex;\n      floating.style.setProperty(\"--z-index\", zIndex);\n    }\n  };\n  const update = async () => {\n    if (opts.updatePosition) {\n      await opts.updatePosition({ updatePosition });\n      onPositioned?.({ placed: true });\n    } else {\n      await updatePosition();\n    }\n  };\n  const autoUpdateOptions = getAutoUpdateOptions(options.listeners);\n  const cancelAutoUpdate = options.listeners ? (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_2__.autoUpdate)(reference, floating, update, autoUpdateOptions) : _zag_js_utils__WEBPACK_IMPORTED_MODULE_1__.noop;\n  update();\n  return () => {\n    cancelAutoUpdate?.();\n    onPositioned?.({ placed: false });\n  };\n}\nfunction getPlacement(referenceOrFn, floatingOrFn, opts = {}) {\n  const { defer, ...options } = opts;\n  const func = defer ? _zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.raf : (v) => v();\n  const cleanups = [];\n  cleanups.push(\n    func(() => {\n      const reference = typeof referenceOrFn === \"function\" ? referenceOrFn() : referenceOrFn;\n      const floating = typeof floatingOrFn === \"function\" ? floatingOrFn() : floatingOrFn;\n      cleanups.push(getPlacementImpl(reference, floating, options));\n    })\n  );\n  return () => {\n    cleanups.forEach((fn) => fn?.());\n  };\n}\n\n// src/get-styles.ts\nvar ARROW_FLOATING_STYLE = {\n  bottom: \"rotate(45deg)\",\n  left: \"rotate(135deg)\",\n  top: \"rotate(225deg)\",\n  right: \"rotate(315deg)\"\n};\nfunction getPlacementStyles(options = {}) {\n  const { placement, sameWidth, fitViewport, strategy = \"absolute\" } = options;\n  return {\n    arrow: {\n      position: \"absolute\",\n      width: cssVars.arrowSize.reference,\n      height: cssVars.arrowSize.reference,\n      [cssVars.arrowSizeHalf.variable]: `calc(${cssVars.arrowSize.reference} / 2)`,\n      [cssVars.arrowOffset.variable]: `calc(${cssVars.arrowSizeHalf.reference} * -1)`\n    },\n    arrowTip: {\n      // @ts-expect-error - Fix this\n      transform: placement ? ARROW_FLOATING_STYLE[placement.split(\"-\")[0]] : void 0,\n      background: cssVars.arrowBg.reference,\n      top: \"0\",\n      left: \"0\",\n      width: \"100%\",\n      height: \"100%\",\n      position: \"absolute\",\n      zIndex: \"inherit\"\n    },\n    floating: {\n      position: strategy,\n      isolation: \"isolate\",\n      minWidth: sameWidth ? void 0 : \"max-content\",\n      width: sameWidth ? \"var(--reference-width)\" : void 0,\n      maxWidth: fitViewport ? \"var(--available-width)\" : void 0,\n      maxHeight: fitViewport ? \"var(--available-height)\" : void 0,\n      top: \"0px\",\n      left: \"0px\",\n      // move off-screen if placement is not defined\n      transform: placement ? \"translate3d(var(--x), var(--y), 0)\" : \"translate3d(0, -100vh, 0)\",\n      zIndex: \"var(--z-index)\"\n    }\n  };\n}\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHphZy1qcy9wb3BwZXIvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQzZHO0FBQzFEO0FBQ1k7O0FBRS9EO0FBQ2tEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsVUFBVSxzQkFBc0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0VBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEIsbUNBQW1DLE1BQU0sSUFBSTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsU0FBUztBQUNwQyx5QkFBeUIsU0FBUztBQUNsQztBQUNBLDhCQUE4QixTQUFTO0FBQ3ZDLDRCQUE0QixTQUFTO0FBQ3JDO0FBQ0Esa0NBQWtDLFNBQVM7QUFDM0MsZ0NBQWdDLFNBQVM7QUFDekM7QUFDQSxrQ0FBa0MsU0FBUztBQUMzQyxnQ0FBZ0MsU0FBUztBQUN6QyxDQUFDO0FBQ0Q7QUFDQTtBQUNBLE9BQU8scUNBQXFDO0FBQzVDLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0EsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sT0FBTztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsMkJBQTJCO0FBQ3BDO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQSw2QkFBNkIsRUFBRTtBQUMvQiw0QkFBNEIsRUFBRTtBQUM5Qiw4QkFBOEIsOEJBQThCO0FBQzVELE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHNEQUFPO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLFNBQVMsdURBQUs7QUFDZDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxNQUFNLHFEQUFNO0FBQ1osU0FBUyx3REFBTSxJQUFJLFdBQVc7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQSxXQUFXLHNEQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsU0FBUyxzREFBSTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxTQUFTLHVEQUFLO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDREQUFVO0FBQ3ZCLEdBQUc7QUFDSDtBQUNBO0FBQ0EsU0FBUyxzREFBSTtBQUNiO0FBQ0EsWUFBWSxrREFBa0Q7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsZUFBZTtBQUN4RSx5REFBeUQsZUFBZTtBQUN4RSwwREFBMEQsZ0JBQWdCO0FBQzFFO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGdEQUFnRDtBQUMxRDtBQUNBO0FBQ0Esc0JBQXNCLGlFQUFlO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHFCQUFxQixjQUFjO0FBQ25DLGdCQUFnQiw0REFBUztBQUN6QjtBQUNBO0FBQ0EseUNBQXlDLEVBQUU7QUFDM0MseUNBQXlDLEVBQUU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxnQkFBZ0I7QUFDbEQsdUJBQXVCLGNBQWM7QUFDckMsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLDREQUFVLG1EQUFtRCwrQ0FBSTtBQUNoSDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsZUFBZTtBQUNwQztBQUNBO0FBQ0EsNERBQTREO0FBQzVELFVBQVUsb0JBQW9CO0FBQzlCLHVCQUF1QixrREFBRztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QyxVQUFVLDJEQUEyRDtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELDZCQUE2QjtBQUM3RSw4Q0FBOEMsaUNBQWlDO0FBQy9FLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2l0ZXMvLi9ub2RlX21vZHVsZXMvQHphZy1qcy9wb3BwZXIvZGlzdC9pbmRleC5tanM/YTFkMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvZ2V0LXBsYWNlbWVudC50c1xuaW1wb3J0IHsgYXJyb3csIGF1dG9VcGRhdGUsIGNvbXB1dGVQb3NpdGlvbiwgZmxpcCwgbGltaXRTaGlmdCwgb2Zmc2V0LCBzaGlmdCwgc2l6ZSB9IGZyb20gXCJAZmxvYXRpbmctdWkvZG9tXCI7XG5pbXBvcnQgeyBnZXRXaW5kb3csIHJhZiB9IGZyb20gXCJAemFnLWpzL2RvbS1xdWVyeVwiO1xuaW1wb3J0IHsgY29tcGFjdCwgaXNOdWxsLCBub29wLCBydW5JZkZuIH0gZnJvbSBcIkB6YWctanMvdXRpbHNcIjtcblxuLy8gc3JjL2dldC1hbmNob3IudHNcbmltcG9ydCB7IGlzSFRNTEVsZW1lbnQgfSBmcm9tIFwiQHphZy1qcy9kb20tcXVlcnlcIjtcbmZ1bmN0aW9uIGNyZWF0ZURPTVJlY3QoeCA9IDAsIHkgPSAwLCB3aWR0aCA9IDAsIGhlaWdodCA9IDApIHtcbiAgaWYgKHR5cGVvZiBET01SZWN0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gbmV3IERPTVJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gIH1cbiAgY29uc3QgcmVjdCA9IHtcbiAgICB4LFxuICAgIHksXG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIHRvcDogeSxcbiAgICByaWdodDogeCArIHdpZHRoLFxuICAgIGJvdHRvbTogeSArIGhlaWdodCxcbiAgICBsZWZ0OiB4XG4gIH07XG4gIHJldHVybiB7IC4uLnJlY3QsIHRvSlNPTjogKCkgPT4gcmVjdCB9O1xufVxuZnVuY3Rpb24gZ2V0RE9NUmVjdChhbmNob3JSZWN0KSB7XG4gIGlmICghYW5jaG9yUmVjdCkgcmV0dXJuIGNyZWF0ZURPTVJlY3QoKTtcbiAgY29uc3QgeyB4LCB5LCB3aWR0aCwgaGVpZ2h0IH0gPSBhbmNob3JSZWN0O1xuICByZXR1cm4gY3JlYXRlRE9NUmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbn1cbmZ1bmN0aW9uIGdldEFuY2hvckVsZW1lbnQoYW5jaG9yRWxlbWVudCwgZ2V0QW5jaG9yUmVjdCkge1xuICByZXR1cm4ge1xuICAgIGNvbnRleHRFbGVtZW50OiBpc0hUTUxFbGVtZW50KGFuY2hvckVsZW1lbnQpID8gYW5jaG9yRWxlbWVudCA6IHZvaWQgMCxcbiAgICBnZXRCb3VuZGluZ0NsaWVudFJlY3Q6ICgpID0+IHtcbiAgICAgIGNvbnN0IGFuY2hvciA9IGFuY2hvckVsZW1lbnQ7XG4gICAgICBjb25zdCBhbmNob3JSZWN0ID0gZ2V0QW5jaG9yUmVjdD8uKGFuY2hvcik7XG4gICAgICBpZiAoYW5jaG9yUmVjdCB8fCAhYW5jaG9yKSB7XG4gICAgICAgIHJldHVybiBnZXRET01SZWN0KGFuY2hvclJlY3QpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFuY2hvci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9taWRkbGV3YXJlLnRzXG52YXIgdG9WYXIgPSAodmFsdWUpID0+ICh7IHZhcmlhYmxlOiB2YWx1ZSwgcmVmZXJlbmNlOiBgdmFyKCR7dmFsdWV9KWAgfSk7XG52YXIgY3NzVmFycyA9IHtcbiAgYXJyb3dTaXplOiB0b1ZhcihcIi0tYXJyb3ctc2l6ZVwiKSxcbiAgYXJyb3dTaXplSGFsZjogdG9WYXIoXCItLWFycm93LXNpemUtaGFsZlwiKSxcbiAgYXJyb3dCZzogdG9WYXIoXCItLWFycm93LWJhY2tncm91bmRcIiksXG4gIHRyYW5zZm9ybU9yaWdpbjogdG9WYXIoXCItLXRyYW5zZm9ybS1vcmlnaW5cIiksXG4gIGFycm93T2Zmc2V0OiB0b1ZhcihcIi0tYXJyb3ctb2Zmc2V0XCIpXG59O1xudmFyIGdldFRyYW5zZm9ybU9yaWdpbiA9IChhcnJvdzIpID0+ICh7XG4gIHRvcDogXCJib3R0b20gY2VudGVyXCIsXG4gIFwidG9wLXN0YXJ0XCI6IGFycm93MiA/IGAke2Fycm93Mi54fXB4IGJvdHRvbWAgOiBcImxlZnQgYm90dG9tXCIsXG4gIFwidG9wLWVuZFwiOiBhcnJvdzIgPyBgJHthcnJvdzIueH1weCBib3R0b21gIDogXCJyaWdodCBib3R0b21cIixcbiAgYm90dG9tOiBcInRvcCBjZW50ZXJcIixcbiAgXCJib3R0b20tc3RhcnRcIjogYXJyb3cyID8gYCR7YXJyb3cyLnh9cHggdG9wYCA6IFwidG9wIGxlZnRcIixcbiAgXCJib3R0b20tZW5kXCI6IGFycm93MiA/IGAke2Fycm93Mi54fXB4IHRvcGAgOiBcInRvcCByaWdodFwiLFxuICBsZWZ0OiBcInJpZ2h0IGNlbnRlclwiLFxuICBcImxlZnQtc3RhcnRcIjogYXJyb3cyID8gYHJpZ2h0ICR7YXJyb3cyLnl9cHhgIDogXCJyaWdodCB0b3BcIixcbiAgXCJsZWZ0LWVuZFwiOiBhcnJvdzIgPyBgcmlnaHQgJHthcnJvdzIueX1weGAgOiBcInJpZ2h0IGJvdHRvbVwiLFxuICByaWdodDogXCJsZWZ0IGNlbnRlclwiLFxuICBcInJpZ2h0LXN0YXJ0XCI6IGFycm93MiA/IGBsZWZ0ICR7YXJyb3cyLnl9cHhgIDogXCJsZWZ0IHRvcFwiLFxuICBcInJpZ2h0LWVuZFwiOiBhcnJvdzIgPyBgbGVmdCAke2Fycm93Mi55fXB4YCA6IFwibGVmdCBib3R0b21cIlxufSk7XG52YXIgdHJhbnNmb3JtT3JpZ2luTWlkZGxld2FyZSA9IHtcbiAgbmFtZTogXCJ0cmFuc2Zvcm1PcmlnaW5cIixcbiAgZm4oeyBwbGFjZW1lbnQsIGVsZW1lbnRzLCBtaWRkbGV3YXJlRGF0YSB9KSB7XG4gICAgY29uc3QgeyBhcnJvdzogYXJyb3cyIH0gPSBtaWRkbGV3YXJlRGF0YTtcbiAgICBjb25zdCB0cmFuc2Zvcm1PcmlnaW4gPSBnZXRUcmFuc2Zvcm1PcmlnaW4oYXJyb3cyKVtwbGFjZW1lbnRdO1xuICAgIGNvbnN0IHsgZmxvYXRpbmcgfSA9IGVsZW1lbnRzO1xuICAgIGZsb2F0aW5nLnN0eWxlLnNldFByb3BlcnR5KGNzc1ZhcnMudHJhbnNmb3JtT3JpZ2luLnZhcmlhYmxlLCB0cmFuc2Zvcm1PcmlnaW4pO1xuICAgIHJldHVybiB7XG4gICAgICBkYXRhOiB7IHRyYW5zZm9ybU9yaWdpbiB9XG4gICAgfTtcbiAgfVxufTtcbnZhciByZWN0TWlkZGxld2FyZSA9IHtcbiAgbmFtZTogXCJyZWN0c1wiLFxuICBmbih7IHJlY3RzIH0pIHtcbiAgICByZXR1cm4ge1xuICAgICAgZGF0YTogcmVjdHNcbiAgICB9O1xuICB9XG59O1xudmFyIHNoaWZ0QXJyb3dNaWRkbGV3YXJlID0gKGFycm93RWwpID0+IHtcbiAgaWYgKCFhcnJvd0VsKSByZXR1cm47XG4gIHJldHVybiB7XG4gICAgbmFtZTogXCJzaGlmdEFycm93XCIsXG4gICAgZm4oeyBwbGFjZW1lbnQsIG1pZGRsZXdhcmVEYXRhIH0pIHtcbiAgICAgIGlmICghbWlkZGxld2FyZURhdGEuYXJyb3cpIHJldHVybiB7fTtcbiAgICAgIGNvbnN0IHsgeCwgeSB9ID0gbWlkZGxld2FyZURhdGEuYXJyb3c7XG4gICAgICBjb25zdCBkaXIgPSBwbGFjZW1lbnQuc3BsaXQoXCItXCIpWzBdO1xuICAgICAgT2JqZWN0LmFzc2lnbihhcnJvd0VsLnN0eWxlLCB7XG4gICAgICAgIGxlZnQ6IHggIT0gbnVsbCA/IGAke3h9cHhgIDogXCJcIixcbiAgICAgICAgdG9wOiB5ICE9IG51bGwgPyBgJHt5fXB4YCA6IFwiXCIsXG4gICAgICAgIFtkaXJdOiBgY2FsYygxMDAlICsgJHtjc3NWYXJzLmFycm93T2Zmc2V0LnJlZmVyZW5jZX0pYFxuICAgICAgfSk7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICB9O1xufTtcblxuLy8gc3JjL3BsYWNlbWVudC50c1xuZnVuY3Rpb24gaXNWYWxpZFBsYWNlbWVudCh2KSB7XG4gIHJldHVybiAvXig/OnRvcHxib3R0b218bGVmdHxyaWdodCkoPzotKD86c3RhcnR8ZW5kKSk/JC8udGVzdCh2KTtcbn1cbmZ1bmN0aW9uIGdldFBsYWNlbWVudERldGFpbHMocGxhY2VtZW50KSB7XG4gIGNvbnN0IFtzaWRlLCBhbGlnbl0gPSBwbGFjZW1lbnQuc3BsaXQoXCItXCIpO1xuICByZXR1cm4geyBzaWRlLCBhbGlnbiwgaGFzQWxpZ246IGFsaWduICE9IG51bGwgfTtcbn1cbmZ1bmN0aW9uIGdldFBsYWNlbWVudFNpZGUocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQuc3BsaXQoXCItXCIpWzBdO1xufVxuXG4vLyBzcmMvZ2V0LXBsYWNlbWVudC50c1xudmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICBzdHJhdGVneTogXCJhYnNvbHV0ZVwiLFxuICBwbGFjZW1lbnQ6IFwiYm90dG9tXCIsXG4gIGxpc3RlbmVyczogdHJ1ZSxcbiAgZ3V0dGVyOiA4LFxuICBmbGlwOiB0cnVlLFxuICBzbGlkZTogdHJ1ZSxcbiAgb3ZlcmxhcDogZmFsc2UsXG4gIHNhbWVXaWR0aDogZmFsc2UsXG4gIGZpdFZpZXdwb3J0OiBmYWxzZSxcbiAgb3ZlcmZsb3dQYWRkaW5nOiA4LFxuICBhcnJvd1BhZGRpbmc6IDRcbn07XG5mdW5jdGlvbiByb3VuZEJ5RHByKHdpbiwgdmFsdWUpIHtcbiAgY29uc3QgZHByID0gd2luLmRldmljZVBpeGVsUmF0aW8gfHwgMTtcbiAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUgKiBkcHIpIC8gZHByO1xufVxuZnVuY3Rpb24gZ2V0Qm91bmRhcnlNaWRkbGV3YXJlKG9wdHMpIHtcbiAgcmV0dXJuIHJ1bklmRm4ob3B0cy5ib3VuZGFyeSk7XG59XG5mdW5jdGlvbiBnZXRBcnJvd01pZGRsZXdhcmUoYXJyb3dFbGVtZW50LCBvcHRzKSB7XG4gIGlmICghYXJyb3dFbGVtZW50KSByZXR1cm47XG4gIHJldHVybiBhcnJvdyh7XG4gICAgZWxlbWVudDogYXJyb3dFbGVtZW50LFxuICAgIHBhZGRpbmc6IG9wdHMuYXJyb3dQYWRkaW5nXG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0T2Zmc2V0TWlkZGxld2FyZShhcnJvd0VsZW1lbnQsIG9wdHMpIHtcbiAgaWYgKGlzTnVsbChvcHRzLm9mZnNldCA/PyBvcHRzLmd1dHRlcikpIHJldHVybjtcbiAgcmV0dXJuIG9mZnNldCgoeyBwbGFjZW1lbnQgfSkgPT4ge1xuICAgIGNvbnN0IGFycm93T2Zmc2V0ID0gKGFycm93RWxlbWVudD8uY2xpZW50SGVpZ2h0IHx8IDApIC8gMjtcbiAgICBjb25zdCBndXR0ZXIgPSBvcHRzLm9mZnNldD8ubWFpbkF4aXMgPz8gb3B0cy5ndXR0ZXI7XG4gICAgY29uc3QgbWFpbkF4aXMgPSB0eXBlb2YgZ3V0dGVyID09PSBcIm51bWJlclwiID8gZ3V0dGVyICsgYXJyb3dPZmZzZXQgOiBndXR0ZXIgPz8gYXJyb3dPZmZzZXQ7XG4gICAgY29uc3QgeyBoYXNBbGlnbiB9ID0gZ2V0UGxhY2VtZW50RGV0YWlscyhwbGFjZW1lbnQpO1xuICAgIGNvbnN0IHNoaWZ0MiA9ICFoYXNBbGlnbiA/IG9wdHMuc2hpZnQgOiB2b2lkIDA7XG4gICAgY29uc3QgY3Jvc3NBeGlzID0gb3B0cy5vZmZzZXQ/LmNyb3NzQXhpcyA/PyBzaGlmdDI7XG4gICAgcmV0dXJuIGNvbXBhY3Qoe1xuICAgICAgY3Jvc3NBeGlzLFxuICAgICAgbWFpbkF4aXMsXG4gICAgICBhbGlnbm1lbnRBeGlzOiBvcHRzLnNoaWZ0XG4gICAgfSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0RmxpcE1pZGRsZXdhcmUob3B0cykge1xuICBpZiAoIW9wdHMuZmxpcCkgcmV0dXJuO1xuICByZXR1cm4gZmxpcCh7XG4gICAgYm91bmRhcnk6IGdldEJvdW5kYXJ5TWlkZGxld2FyZShvcHRzKSxcbiAgICBwYWRkaW5nOiBvcHRzLm92ZXJmbG93UGFkZGluZyxcbiAgICBmYWxsYmFja1BsYWNlbWVudHM6IG9wdHMuZmxpcCA9PT0gdHJ1ZSA/IHZvaWQgMCA6IG9wdHMuZmxpcFxuICB9KTtcbn1cbmZ1bmN0aW9uIGdldFNoaWZ0TWlkZGxld2FyZShvcHRzKSB7XG4gIGlmICghb3B0cy5zbGlkZSAmJiAhb3B0cy5vdmVybGFwKSByZXR1cm47XG4gIHJldHVybiBzaGlmdCh7XG4gICAgYm91bmRhcnk6IGdldEJvdW5kYXJ5TWlkZGxld2FyZShvcHRzKSxcbiAgICBtYWluQXhpczogb3B0cy5zbGlkZSxcbiAgICBjcm9zc0F4aXM6IG9wdHMub3ZlcmxhcCxcbiAgICBwYWRkaW5nOiBvcHRzLm92ZXJmbG93UGFkZGluZyxcbiAgICBsaW1pdGVyOiBsaW1pdFNoaWZ0KClcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRTaXplTWlkZGxld2FyZShvcHRzKSB7XG4gIHJldHVybiBzaXplKHtcbiAgICBwYWRkaW5nOiBvcHRzLm92ZXJmbG93UGFkZGluZyxcbiAgICBhcHBseSh7IGVsZW1lbnRzLCByZWN0cywgYXZhaWxhYmxlSGVpZ2h0LCBhdmFpbGFibGVXaWR0aCB9KSB7XG4gICAgICBjb25zdCBmbG9hdGluZyA9IGVsZW1lbnRzLmZsb2F0aW5nO1xuICAgICAgY29uc3QgcmVmZXJlbmNlV2lkdGggPSBNYXRoLnJvdW5kKHJlY3RzLnJlZmVyZW5jZS53aWR0aCk7XG4gICAgICBhdmFpbGFibGVXaWR0aCA9IE1hdGguZmxvb3IoYXZhaWxhYmxlV2lkdGgpO1xuICAgICAgYXZhaWxhYmxlSGVpZ2h0ID0gTWF0aC5mbG9vcihhdmFpbGFibGVIZWlnaHQpO1xuICAgICAgZmxvYXRpbmcuc3R5bGUuc2V0UHJvcGVydHkoXCItLXJlZmVyZW5jZS13aWR0aFwiLCBgJHtyZWZlcmVuY2VXaWR0aH1weGApO1xuICAgICAgZmxvYXRpbmcuc3R5bGUuc2V0UHJvcGVydHkoXCItLWF2YWlsYWJsZS13aWR0aFwiLCBgJHthdmFpbGFibGVXaWR0aH1weGApO1xuICAgICAgZmxvYXRpbmcuc3R5bGUuc2V0UHJvcGVydHkoXCItLWF2YWlsYWJsZS1oZWlnaHRcIiwgYCR7YXZhaWxhYmxlSGVpZ2h0fXB4YCk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGdldEF1dG9VcGRhdGVPcHRpb25zKG9wdHMpIHtcbiAgaWYgKCFvcHRzKSByZXR1cm4ge307XG4gIGlmIChvcHRzID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIHsgYW5jZXN0b3JSZXNpemU6IHRydWUsIGFuY2VzdG9yU2Nyb2xsOiB0cnVlLCBlbGVtZW50UmVzaXplOiB0cnVlLCBsYXlvdXRTaGlmdDogdHJ1ZSB9O1xuICB9XG4gIHJldHVybiBvcHRzO1xufVxuZnVuY3Rpb24gZ2V0UGxhY2VtZW50SW1wbChyZWZlcmVuY2VPclZpcnR1YWwsIGZsb2F0aW5nLCBvcHRzID0ge30pIHtcbiAgY29uc3QgcmVmZXJlbmNlID0gZ2V0QW5jaG9yRWxlbWVudChyZWZlcmVuY2VPclZpcnR1YWwsIG9wdHMuZ2V0QW5jaG9yUmVjdCk7XG4gIGlmICghZmxvYXRpbmcgfHwgIXJlZmVyZW5jZSkgcmV0dXJuO1xuICBjb25zdCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMsIG9wdHMpO1xuICBjb25zdCBhcnJvd0VsID0gZmxvYXRpbmcucXVlcnlTZWxlY3RvcihcIltkYXRhLXBhcnQ9YXJyb3ddXCIpO1xuICBjb25zdCBtaWRkbGV3YXJlID0gW1xuICAgIGdldE9mZnNldE1pZGRsZXdhcmUoYXJyb3dFbCwgb3B0aW9ucyksXG4gICAgZ2V0RmxpcE1pZGRsZXdhcmUob3B0aW9ucyksXG4gICAgZ2V0U2hpZnRNaWRkbGV3YXJlKG9wdGlvbnMpLFxuICAgIGdldEFycm93TWlkZGxld2FyZShhcnJvd0VsLCBvcHRpb25zKSxcbiAgICBzaGlmdEFycm93TWlkZGxld2FyZShhcnJvd0VsKSxcbiAgICB0cmFuc2Zvcm1PcmlnaW5NaWRkbGV3YXJlLFxuICAgIGdldFNpemVNaWRkbGV3YXJlKG9wdGlvbnMpLFxuICAgIHJlY3RNaWRkbGV3YXJlXG4gIF07XG4gIGNvbnN0IHsgcGxhY2VtZW50LCBzdHJhdGVneSwgb25Db21wbGV0ZSwgb25Qb3NpdGlvbmVkIH0gPSBvcHRpb25zO1xuICBjb25zdCB1cGRhdGVQb3NpdGlvbiA9IGFzeW5jICgpID0+IHtcbiAgICBpZiAoIXJlZmVyZW5jZSB8fCAhZmxvYXRpbmcpIHJldHVybjtcbiAgICBjb25zdCBwb3MgPSBhd2FpdCBjb21wdXRlUG9zaXRpb24ocmVmZXJlbmNlLCBmbG9hdGluZywge1xuICAgICAgcGxhY2VtZW50LFxuICAgICAgbWlkZGxld2FyZSxcbiAgICAgIHN0cmF0ZWd5XG4gICAgfSk7XG4gICAgb25Db21wbGV0ZT8uKHBvcyk7XG4gICAgb25Qb3NpdGlvbmVkPy4oeyBwbGFjZWQ6IHRydWUgfSk7XG4gICAgY29uc3Qgd2luID0gZ2V0V2luZG93KGZsb2F0aW5nKTtcbiAgICBjb25zdCB4ID0gcm91bmRCeURwcih3aW4sIHBvcy54KTtcbiAgICBjb25zdCB5ID0gcm91bmRCeURwcih3aW4sIHBvcy55KTtcbiAgICBmbG9hdGluZy5zdHlsZS5zZXRQcm9wZXJ0eShcIi0teFwiLCBgJHt4fXB4YCk7XG4gICAgZmxvYXRpbmcuc3R5bGUuc2V0UHJvcGVydHkoXCItLXlcIiwgYCR7eX1weGApO1xuICAgIGNvbnN0IGNvbnRlbnRFbCA9IGZsb2F0aW5nLmZpcnN0RWxlbWVudENoaWxkO1xuICAgIGlmIChjb250ZW50RWwpIHtcbiAgICAgIGNvbnN0IHpJbmRleCA9IHdpbi5nZXRDb21wdXRlZFN0eWxlKGNvbnRlbnRFbCkuekluZGV4O1xuICAgICAgZmxvYXRpbmcuc3R5bGUuc2V0UHJvcGVydHkoXCItLXotaW5kZXhcIiwgekluZGV4KTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHVwZGF0ZSA9IGFzeW5jICgpID0+IHtcbiAgICBpZiAob3B0cy51cGRhdGVQb3NpdGlvbikge1xuICAgICAgYXdhaXQgb3B0cy51cGRhdGVQb3NpdGlvbih7IHVwZGF0ZVBvc2l0aW9uIH0pO1xuICAgICAgb25Qb3NpdGlvbmVkPy4oeyBwbGFjZWQ6IHRydWUgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGF3YWl0IHVwZGF0ZVBvc2l0aW9uKCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBhdXRvVXBkYXRlT3B0aW9ucyA9IGdldEF1dG9VcGRhdGVPcHRpb25zKG9wdGlvbnMubGlzdGVuZXJzKTtcbiAgY29uc3QgY2FuY2VsQXV0b1VwZGF0ZSA9IG9wdGlvbnMubGlzdGVuZXJzID8gYXV0b1VwZGF0ZShyZWZlcmVuY2UsIGZsb2F0aW5nLCB1cGRhdGUsIGF1dG9VcGRhdGVPcHRpb25zKSA6IG5vb3A7XG4gIHVwZGF0ZSgpO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGNhbmNlbEF1dG9VcGRhdGU/LigpO1xuICAgIG9uUG9zaXRpb25lZD8uKHsgcGxhY2VkOiBmYWxzZSB9KTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFBsYWNlbWVudChyZWZlcmVuY2VPckZuLCBmbG9hdGluZ09yRm4sIG9wdHMgPSB7fSkge1xuICBjb25zdCB7IGRlZmVyLCAuLi5vcHRpb25zIH0gPSBvcHRzO1xuICBjb25zdCBmdW5jID0gZGVmZXIgPyByYWYgOiAodikgPT4gdigpO1xuICBjb25zdCBjbGVhbnVwcyA9IFtdO1xuICBjbGVhbnVwcy5wdXNoKFxuICAgIGZ1bmMoKCkgPT4ge1xuICAgICAgY29uc3QgcmVmZXJlbmNlID0gdHlwZW9mIHJlZmVyZW5jZU9yRm4gPT09IFwiZnVuY3Rpb25cIiA/IHJlZmVyZW5jZU9yRm4oKSA6IHJlZmVyZW5jZU9yRm47XG4gICAgICBjb25zdCBmbG9hdGluZyA9IHR5cGVvZiBmbG9hdGluZ09yRm4gPT09IFwiZnVuY3Rpb25cIiA/IGZsb2F0aW5nT3JGbigpIDogZmxvYXRpbmdPckZuO1xuICAgICAgY2xlYW51cHMucHVzaChnZXRQbGFjZW1lbnRJbXBsKHJlZmVyZW5jZSwgZmxvYXRpbmcsIG9wdGlvbnMpKTtcbiAgICB9KVxuICApO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGNsZWFudXBzLmZvckVhY2goKGZuKSA9PiBmbj8uKCkpO1xuICB9O1xufVxuXG4vLyBzcmMvZ2V0LXN0eWxlcy50c1xudmFyIEFSUk9XX0ZMT0FUSU5HX1NUWUxFID0ge1xuICBib3R0b206IFwicm90YXRlKDQ1ZGVnKVwiLFxuICBsZWZ0OiBcInJvdGF0ZSgxMzVkZWcpXCIsXG4gIHRvcDogXCJyb3RhdGUoMjI1ZGVnKVwiLFxuICByaWdodDogXCJyb3RhdGUoMzE1ZGVnKVwiXG59O1xuZnVuY3Rpb24gZ2V0UGxhY2VtZW50U3R5bGVzKG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7IHBsYWNlbWVudCwgc2FtZVdpZHRoLCBmaXRWaWV3cG9ydCwgc3RyYXRlZ3kgPSBcImFic29sdXRlXCIgfSA9IG9wdGlvbnM7XG4gIHJldHVybiB7XG4gICAgYXJyb3c6IHtcbiAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICB3aWR0aDogY3NzVmFycy5hcnJvd1NpemUucmVmZXJlbmNlLFxuICAgICAgaGVpZ2h0OiBjc3NWYXJzLmFycm93U2l6ZS5yZWZlcmVuY2UsXG4gICAgICBbY3NzVmFycy5hcnJvd1NpemVIYWxmLnZhcmlhYmxlXTogYGNhbGMoJHtjc3NWYXJzLmFycm93U2l6ZS5yZWZlcmVuY2V9IC8gMilgLFxuICAgICAgW2Nzc1ZhcnMuYXJyb3dPZmZzZXQudmFyaWFibGVdOiBgY2FsYygke2Nzc1ZhcnMuYXJyb3dTaXplSGFsZi5yZWZlcmVuY2V9ICogLTEpYFxuICAgIH0sXG4gICAgYXJyb3dUaXA6IHtcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLSBGaXggdGhpc1xuICAgICAgdHJhbnNmb3JtOiBwbGFjZW1lbnQgPyBBUlJPV19GTE9BVElOR19TVFlMRVtwbGFjZW1lbnQuc3BsaXQoXCItXCIpWzBdXSA6IHZvaWQgMCxcbiAgICAgIGJhY2tncm91bmQ6IGNzc1ZhcnMuYXJyb3dCZy5yZWZlcmVuY2UsXG4gICAgICB0b3A6IFwiMFwiLFxuICAgICAgbGVmdDogXCIwXCIsXG4gICAgICB3aWR0aDogXCIxMDAlXCIsXG4gICAgICBoZWlnaHQ6IFwiMTAwJVwiLFxuICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgIHpJbmRleDogXCJpbmhlcml0XCJcbiAgICB9LFxuICAgIGZsb2F0aW5nOiB7XG4gICAgICBwb3NpdGlvbjogc3RyYXRlZ3ksXG4gICAgICBpc29sYXRpb246IFwiaXNvbGF0ZVwiLFxuICAgICAgbWluV2lkdGg6IHNhbWVXaWR0aCA/IHZvaWQgMCA6IFwibWF4LWNvbnRlbnRcIixcbiAgICAgIHdpZHRoOiBzYW1lV2lkdGggPyBcInZhcigtLXJlZmVyZW5jZS13aWR0aClcIiA6IHZvaWQgMCxcbiAgICAgIG1heFdpZHRoOiBmaXRWaWV3cG9ydCA/IFwidmFyKC0tYXZhaWxhYmxlLXdpZHRoKVwiIDogdm9pZCAwLFxuICAgICAgbWF4SGVpZ2h0OiBmaXRWaWV3cG9ydCA/IFwidmFyKC0tYXZhaWxhYmxlLWhlaWdodClcIiA6IHZvaWQgMCxcbiAgICAgIHRvcDogXCIwcHhcIixcbiAgICAgIGxlZnQ6IFwiMHB4XCIsXG4gICAgICAvLyBtb3ZlIG9mZi1zY3JlZW4gaWYgcGxhY2VtZW50IGlzIG5vdCBkZWZpbmVkXG4gICAgICB0cmFuc2Zvcm06IHBsYWNlbWVudCA/IFwidHJhbnNsYXRlM2QodmFyKC0teCksIHZhcigtLXkpLCAwKVwiIDogXCJ0cmFuc2xhdGUzZCgwLCAtMTAwdmgsIDApXCIsXG4gICAgICB6SW5kZXg6IFwidmFyKC0tei1pbmRleClcIlxuICAgIH1cbiAgfTtcbn1cbmV4cG9ydCB7XG4gIGdldFBsYWNlbWVudCxcbiAgZ2V0UGxhY2VtZW50U2lkZSxcbiAgZ2V0UGxhY2VtZW50U3R5bGVzLFxuICBpc1ZhbGlkUGxhY2VtZW50XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@zag-js/popper/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@zag-js/presence/dist/index.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@zag-js/presence/dist/index.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   connect: () => (/* binding */ connect),\n/* harmony export */   machine: () => (/* binding */ machine),\n/* harmony export */   props: () => (/* binding */ props)\n/* harmony export */ });\n/* harmony import */ var _zag_js_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @zag-js/core */ \"(ssr)/./node_modules/@zag-js/core/dist/index.mjs\");\n/* harmony import */ var _zag_js_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @zag-js/core */ \"(ssr)/./node_modules/@zag-js/store/dist/index.mjs\");\n/* harmony import */ var _zag_js_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @zag-js/types */ \"(ssr)/./node_modules/@zag-js/types/dist/index.mjs\");\n// src/presence.connect.ts\nfunction connect(state, send, _normalize) {\n  const present = state.matches(\"mounted\", \"unmountSuspended\");\n  return {\n    skip: !state.context.initial && present,\n    present,\n    setNode(node) {\n      if (!node) return;\n      send({ type: \"NODE.SET\", node });\n    },\n    unmount() {\n      send({ type: \"UNMOUNT\" });\n    }\n  };\n}\n\n// src/presence.machine.ts\n\nfunction getAnimationName(styles) {\n  return styles?.animationName || \"none\";\n}\nfunction machine(ctx) {\n  return (0,_zag_js_core__WEBPACK_IMPORTED_MODULE_0__.createMachine)(\n    {\n      initial: ctx.present ? \"mounted\" : \"unmounted\",\n      context: {\n        node: null,\n        styles: null,\n        unmountAnimationName: null,\n        prevAnimationName: null,\n        present: false,\n        initial: false,\n        ...ctx\n      },\n      exit: [\"clearInitial\"],\n      watch: {\n        present: [\"setInitial\", \"syncPresence\"]\n      },\n      on: {\n        \"NODE.SET\": {\n          actions: [\"setNode\", \"setStyles\"]\n        }\n      },\n      states: {\n        mounted: {\n          on: {\n            UNMOUNT: {\n              target: \"unmounted\",\n              actions: [\"invokeOnExitComplete\"]\n            },\n            \"UNMOUNT.SUSPEND\": \"unmountSuspended\"\n          }\n        },\n        unmountSuspended: {\n          activities: [\"trackAnimationEvents\"],\n          on: {\n            MOUNT: {\n              target: \"mounted\",\n              actions: [\"setPrevAnimationName\"]\n            },\n            \"ANIMATION.END\": {\n              target: \"unmounted\",\n              actions: [\"invokeOnExitComplete\"]\n            },\n            UNMOUNT: {\n              target: \"unmounted\",\n              actions: [\"invokeOnExitComplete\"]\n            }\n          }\n        },\n        unmounted: {\n          entry: [\"clearPrevAnimationName\"],\n          on: {\n            MOUNT: {\n              target: \"mounted\",\n              actions: [\"setPrevAnimationName\"]\n            }\n          }\n        }\n      }\n    },\n    {\n      actions: {\n        setInitial(ctx2) {\n          ctx2.initial = true;\n        },\n        clearInitial(ctx2) {\n          ctx2.initial = false;\n        },\n        invokeOnExitComplete(ctx2) {\n          ctx2.onExitComplete?.();\n        },\n        setNode(ctx2, evt) {\n          ctx2.node = (0,_zag_js_core__WEBPACK_IMPORTED_MODULE_1__.ref)(evt.node);\n        },\n        setStyles(ctx2, evt) {\n          const win = evt.node.ownerDocument.defaultView || window;\n          ctx2.styles = (0,_zag_js_core__WEBPACK_IMPORTED_MODULE_1__.ref)(win.getComputedStyle(evt.node));\n        },\n        syncPresence(ctx2, _evt, { send }) {\n          if (ctx2.present) {\n            send({ type: \"MOUNT\", src: \"presence.changed\" });\n            return;\n          }\n          const animationName = getAnimationName(ctx2.styles);\n          const exec = ctx2.immediate ? queueMicrotask : requestAnimationFrame;\n          exec(() => {\n            ctx2.unmountAnimationName = animationName;\n            if (animationName === \"none\" || animationName === ctx2.prevAnimationName || ctx2.styles?.display === \"none\" || ctx2.styles?.animationDuration === \"0s\") {\n              send({ type: \"UNMOUNT\", src: \"presence.changed\" });\n            } else {\n              send({ type: \"UNMOUNT.SUSPEND\" });\n            }\n          });\n        },\n        setPrevAnimationName(ctx2) {\n          const exec = ctx2.immediate ? queueMicrotask : requestAnimationFrame;\n          exec(() => {\n            ctx2.prevAnimationName = getAnimationName(ctx2.styles);\n          });\n        },\n        clearPrevAnimationName(ctx2) {\n          ctx2.prevAnimationName = null;\n        }\n      },\n      activities: {\n        trackAnimationEvents(ctx2, _evt, { send }) {\n          const node = ctx2.node;\n          if (!node) return;\n          const onStart = (event) => {\n            if (event.target === node) {\n              ctx2.prevAnimationName = getAnimationName(ctx2.styles);\n            }\n          };\n          const onEnd = (event) => {\n            const animationName = getAnimationName(ctx2.styles);\n            if (event.target === node && animationName === ctx2.unmountAnimationName) {\n              send({ type: \"UNMOUNT\", src: \"animationend\" });\n            }\n          };\n          node.addEventListener(\"animationstart\", onStart);\n          node.addEventListener(\"animationcancel\", onEnd);\n          node.addEventListener(\"animationend\", onEnd);\n          return () => {\n            node.removeEventListener(\"animationstart\", onStart);\n            node.removeEventListener(\"animationcancel\", onEnd);\n            node.removeEventListener(\"animationend\", onEnd);\n          };\n        }\n      }\n    }\n  );\n}\n\n// src/presence.props.ts\n\nvar props = (0,_zag_js_types__WEBPACK_IMPORTED_MODULE_2__.createProps)()([\"onExitComplete\", \"present\", \"immediate\"]);\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHphZy1qcy9wcmVzZW5jZS9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx3QkFBd0I7QUFDckMsS0FBSztBQUNMO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBOztBQUVBO0FBQ2tEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUywyREFBYTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHNCQUFzQixpREFBRztBQUN6QixTQUFTO0FBQ1Q7QUFDQTtBQUNBLHdCQUF3QixpREFBRztBQUMzQixTQUFTO0FBQ1QsbUNBQW1DLE1BQU07QUFDekM7QUFDQSxtQkFBbUIsd0NBQXdDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDBDQUEwQztBQUMvRCxjQUFjO0FBQ2QscUJBQXFCLHlCQUF5QjtBQUM5QztBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLDJDQUEyQyxNQUFNO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHNDQUFzQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDNEM7QUFDNUMsWUFBWSwwREFBVztBQUtyQjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2l0ZXMvLi9ub2RlX21vZHVsZXMvQHphZy1qcy9wcmVzZW5jZS9kaXN0L2luZGV4Lm1qcz83NmVlIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9wcmVzZW5jZS5jb25uZWN0LnRzXG5mdW5jdGlvbiBjb25uZWN0KHN0YXRlLCBzZW5kLCBfbm9ybWFsaXplKSB7XG4gIGNvbnN0IHByZXNlbnQgPSBzdGF0ZS5tYXRjaGVzKFwibW91bnRlZFwiLCBcInVubW91bnRTdXNwZW5kZWRcIik7XG4gIHJldHVybiB7XG4gICAgc2tpcDogIXN0YXRlLmNvbnRleHQuaW5pdGlhbCAmJiBwcmVzZW50LFxuICAgIHByZXNlbnQsXG4gICAgc2V0Tm9kZShub2RlKSB7XG4gICAgICBpZiAoIW5vZGUpIHJldHVybjtcbiAgICAgIHNlbmQoeyB0eXBlOiBcIk5PREUuU0VUXCIsIG5vZGUgfSk7XG4gICAgfSxcbiAgICB1bm1vdW50KCkge1xuICAgICAgc2VuZCh7IHR5cGU6IFwiVU5NT1VOVFwiIH0pO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3ByZXNlbmNlLm1hY2hpbmUudHNcbmltcG9ydCB7IGNyZWF0ZU1hY2hpbmUsIHJlZiB9IGZyb20gXCJAemFnLWpzL2NvcmVcIjtcbmZ1bmN0aW9uIGdldEFuaW1hdGlvbk5hbWUoc3R5bGVzKSB7XG4gIHJldHVybiBzdHlsZXM/LmFuaW1hdGlvbk5hbWUgfHwgXCJub25lXCI7XG59XG5mdW5jdGlvbiBtYWNoaW5lKGN0eCkge1xuICByZXR1cm4gY3JlYXRlTWFjaGluZShcbiAgICB7XG4gICAgICBpbml0aWFsOiBjdHgucHJlc2VudCA/IFwibW91bnRlZFwiIDogXCJ1bm1vdW50ZWRcIixcbiAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgbm9kZTogbnVsbCxcbiAgICAgICAgc3R5bGVzOiBudWxsLFxuICAgICAgICB1bm1vdW50QW5pbWF0aW9uTmFtZTogbnVsbCxcbiAgICAgICAgcHJldkFuaW1hdGlvbk5hbWU6IG51bGwsXG4gICAgICAgIHByZXNlbnQ6IGZhbHNlLFxuICAgICAgICBpbml0aWFsOiBmYWxzZSxcbiAgICAgICAgLi4uY3R4XG4gICAgICB9LFxuICAgICAgZXhpdDogW1wiY2xlYXJJbml0aWFsXCJdLFxuICAgICAgd2F0Y2g6IHtcbiAgICAgICAgcHJlc2VudDogW1wic2V0SW5pdGlhbFwiLCBcInN5bmNQcmVzZW5jZVwiXVxuICAgICAgfSxcbiAgICAgIG9uOiB7XG4gICAgICAgIFwiTk9ERS5TRVRcIjoge1xuICAgICAgICAgIGFjdGlvbnM6IFtcInNldE5vZGVcIiwgXCJzZXRTdHlsZXNcIl1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHN0YXRlczoge1xuICAgICAgICBtb3VudGVkOiB7XG4gICAgICAgICAgb246IHtcbiAgICAgICAgICAgIFVOTU9VTlQ6IHtcbiAgICAgICAgICAgICAgdGFyZ2V0OiBcInVubW91bnRlZFwiLFxuICAgICAgICAgICAgICBhY3Rpb25zOiBbXCJpbnZva2VPbkV4aXRDb21wbGV0ZVwiXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiVU5NT1VOVC5TVVNQRU5EXCI6IFwidW5tb3VudFN1c3BlbmRlZFwiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB1bm1vdW50U3VzcGVuZGVkOiB7XG4gICAgICAgICAgYWN0aXZpdGllczogW1widHJhY2tBbmltYXRpb25FdmVudHNcIl0sXG4gICAgICAgICAgb246IHtcbiAgICAgICAgICAgIE1PVU5UOiB7XG4gICAgICAgICAgICAgIHRhcmdldDogXCJtb3VudGVkXCIsXG4gICAgICAgICAgICAgIGFjdGlvbnM6IFtcInNldFByZXZBbmltYXRpb25OYW1lXCJdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJBTklNQVRJT04uRU5EXCI6IHtcbiAgICAgICAgICAgICAgdGFyZ2V0OiBcInVubW91bnRlZFwiLFxuICAgICAgICAgICAgICBhY3Rpb25zOiBbXCJpbnZva2VPbkV4aXRDb21wbGV0ZVwiXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFVOTU9VTlQ6IHtcbiAgICAgICAgICAgICAgdGFyZ2V0OiBcInVubW91bnRlZFwiLFxuICAgICAgICAgICAgICBhY3Rpb25zOiBbXCJpbnZva2VPbkV4aXRDb21wbGV0ZVwiXVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdW5tb3VudGVkOiB7XG4gICAgICAgICAgZW50cnk6IFtcImNsZWFyUHJldkFuaW1hdGlvbk5hbWVcIl0sXG4gICAgICAgICAgb246IHtcbiAgICAgICAgICAgIE1PVU5UOiB7XG4gICAgICAgICAgICAgIHRhcmdldDogXCJtb3VudGVkXCIsXG4gICAgICAgICAgICAgIGFjdGlvbnM6IFtcInNldFByZXZBbmltYXRpb25OYW1lXCJdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBhY3Rpb25zOiB7XG4gICAgICAgIHNldEluaXRpYWwoY3R4Mikge1xuICAgICAgICAgIGN0eDIuaW5pdGlhbCA9IHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIGNsZWFySW5pdGlhbChjdHgyKSB7XG4gICAgICAgICAgY3R4Mi5pbml0aWFsID0gZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIGludm9rZU9uRXhpdENvbXBsZXRlKGN0eDIpIHtcbiAgICAgICAgICBjdHgyLm9uRXhpdENvbXBsZXRlPy4oKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0Tm9kZShjdHgyLCBldnQpIHtcbiAgICAgICAgICBjdHgyLm5vZGUgPSByZWYoZXZ0Lm5vZGUpO1xuICAgICAgICB9LFxuICAgICAgICBzZXRTdHlsZXMoY3R4MiwgZXZ0KSB7XG4gICAgICAgICAgY29uc3Qgd2luID0gZXZ0Lm5vZGUub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyB8fCB3aW5kb3c7XG4gICAgICAgICAgY3R4Mi5zdHlsZXMgPSByZWYod2luLmdldENvbXB1dGVkU3R5bGUoZXZ0Lm5vZGUpKTtcbiAgICAgICAgfSxcbiAgICAgICAgc3luY1ByZXNlbmNlKGN0eDIsIF9ldnQsIHsgc2VuZCB9KSB7XG4gICAgICAgICAgaWYgKGN0eDIucHJlc2VudCkge1xuICAgICAgICAgICAgc2VuZCh7IHR5cGU6IFwiTU9VTlRcIiwgc3JjOiBcInByZXNlbmNlLmNoYW5nZWRcIiB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgYW5pbWF0aW9uTmFtZSA9IGdldEFuaW1hdGlvbk5hbWUoY3R4Mi5zdHlsZXMpO1xuICAgICAgICAgIGNvbnN0IGV4ZWMgPSBjdHgyLmltbWVkaWF0ZSA/IHF1ZXVlTWljcm90YXNrIDogcmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xuICAgICAgICAgIGV4ZWMoKCkgPT4ge1xuICAgICAgICAgICAgY3R4Mi51bm1vdW50QW5pbWF0aW9uTmFtZSA9IGFuaW1hdGlvbk5hbWU7XG4gICAgICAgICAgICBpZiAoYW5pbWF0aW9uTmFtZSA9PT0gXCJub25lXCIgfHwgYW5pbWF0aW9uTmFtZSA9PT0gY3R4Mi5wcmV2QW5pbWF0aW9uTmFtZSB8fCBjdHgyLnN0eWxlcz8uZGlzcGxheSA9PT0gXCJub25lXCIgfHwgY3R4Mi5zdHlsZXM/LmFuaW1hdGlvbkR1cmF0aW9uID09PSBcIjBzXCIpIHtcbiAgICAgICAgICAgICAgc2VuZCh7IHR5cGU6IFwiVU5NT1VOVFwiLCBzcmM6IFwicHJlc2VuY2UuY2hhbmdlZFwiIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2VuZCh7IHR5cGU6IFwiVU5NT1VOVC5TVVNQRU5EXCIgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldFByZXZBbmltYXRpb25OYW1lKGN0eDIpIHtcbiAgICAgICAgICBjb25zdCBleGVjID0gY3R4Mi5pbW1lZGlhdGUgPyBxdWV1ZU1pY3JvdGFzayA6IHJlcXVlc3RBbmltYXRpb25GcmFtZTtcbiAgICAgICAgICBleGVjKCgpID0+IHtcbiAgICAgICAgICAgIGN0eDIucHJldkFuaW1hdGlvbk5hbWUgPSBnZXRBbmltYXRpb25OYW1lKGN0eDIuc3R5bGVzKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgY2xlYXJQcmV2QW5pbWF0aW9uTmFtZShjdHgyKSB7XG4gICAgICAgICAgY3R4Mi5wcmV2QW5pbWF0aW9uTmFtZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBhY3Rpdml0aWVzOiB7XG4gICAgICAgIHRyYWNrQW5pbWF0aW9uRXZlbnRzKGN0eDIsIF9ldnQsIHsgc2VuZCB9KSB7XG4gICAgICAgICAgY29uc3Qgbm9kZSA9IGN0eDIubm9kZTtcbiAgICAgICAgICBpZiAoIW5vZGUpIHJldHVybjtcbiAgICAgICAgICBjb25zdCBvblN0YXJ0ID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXZlbnQudGFyZ2V0ID09PSBub2RlKSB7XG4gICAgICAgICAgICAgIGN0eDIucHJldkFuaW1hdGlvbk5hbWUgPSBnZXRBbmltYXRpb25OYW1lKGN0eDIuc3R5bGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIGNvbnN0IG9uRW5kID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhbmltYXRpb25OYW1lID0gZ2V0QW5pbWF0aW9uTmFtZShjdHgyLnN0eWxlcyk7XG4gICAgICAgICAgICBpZiAoZXZlbnQudGFyZ2V0ID09PSBub2RlICYmIGFuaW1hdGlvbk5hbWUgPT09IGN0eDIudW5tb3VudEFuaW1hdGlvbk5hbWUpIHtcbiAgICAgICAgICAgICAgc2VuZCh7IHR5cGU6IFwiVU5NT1VOVFwiLCBzcmM6IFwiYW5pbWF0aW9uZW5kXCIgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJhbmltYXRpb25zdGFydFwiLCBvblN0YXJ0KTtcbiAgICAgICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJhbmltYXRpb25jYW5jZWxcIiwgb25FbmQpO1xuICAgICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcImFuaW1hdGlvbmVuZFwiLCBvbkVuZCk7XG4gICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFuaW1hdGlvbnN0YXJ0XCIsIG9uU3RhcnQpO1xuICAgICAgICAgICAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiYW5pbWF0aW9uY2FuY2VsXCIsIG9uRW5kKTtcbiAgICAgICAgICAgIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFuaW1hdGlvbmVuZFwiLCBvbkVuZCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgKTtcbn1cblxuLy8gc3JjL3ByZXNlbmNlLnByb3BzLnRzXG5pbXBvcnQgeyBjcmVhdGVQcm9wcyB9IGZyb20gXCJAemFnLWpzL3R5cGVzXCI7XG52YXIgcHJvcHMgPSBjcmVhdGVQcm9wcygpKFtcIm9uRXhpdENvbXBsZXRlXCIsIFwicHJlc2VudFwiLCBcImltbWVkaWF0ZVwiXSk7XG5leHBvcnQge1xuICBjb25uZWN0LFxuICBtYWNoaW5lLFxuICBwcm9wc1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@zag-js/presence/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@zag-js/react/dist/index.mjs":
/*!***************************************************!*\
  !*** ./node_modules/@zag-js/react/dist/index.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Portal: () => (/* binding */ Portal),\n/* harmony export */   mergeProps: () => (/* reexport safe */ _zag_js_core__WEBPACK_IMPORTED_MODULE_6__.mergeProps),\n/* harmony export */   normalizeProps: () => (/* binding */ normalizeProps),\n/* harmony export */   useActor: () => (/* binding */ useActor),\n/* harmony export */   useMachine: () => (/* binding */ useMachine)\n/* harmony export */ });\n/* harmony import */ var _zag_js_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @zag-js/core */ \"(ssr)/./node_modules/@zag-js/core/dist/index.mjs\");\n/* harmony import */ var _zag_js_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @zag-js/types */ \"(ssr)/./node_modules/@zag-js/types/dist/index.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var _zag_js_store__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @zag-js/store */ \"(ssr)/./node_modules/@zag-js/store/dist/index.mjs\");\n/* harmony import */ var proxy_compare__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! proxy-compare */ \"(ssr)/./node_modules/proxy-compare/dist/index.js\");\n/* __next_internal_client_entry_do_not_use__ Portal,mergeProps,normalizeProps,useActor,useMachine auto */ // src/index.ts\n\n// src/normalize-props.ts\n\nvar normalizeProps = (0,_zag_js_types__WEBPACK_IMPORTED_MODULE_0__.createNormalizer)((v)=>v);\n// src/portal.tsx\n\n\n\nvar Portal = (props)=>{\n    const { children, container, disabled, getRootNode } = props;\n    const isServer = \"undefined\" === \"undefined\";\n    if (isServer || disabled) return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.Fragment, {\n        children\n    });\n    const doc = getRootNode?.().ownerDocument ?? document;\n    const mountNode = container?.current ?? doc.body;\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.Fragment, {\n        children: react__WEBPACK_IMPORTED_MODULE_1__.Children.map(children, (child)=>/*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_2__.createPortal)(child, mountNode))\n    });\n};\n// src/use-snapshot.ts\n\n// ../../utilities/core/src/equal.ts\nvar isArrayLike = (value)=>value?.constructor.name === \"Array\";\nvar isArrayEqual = (a, b)=>{\n    if (a.length !== b.length) return false;\n    for(let i = 0; i < a.length; i++){\n        if (!isEqual(a[i], b[i])) return false;\n    }\n    return true;\n};\nvar isEqual = (a, b)=>{\n    if (Object.is(a, b)) return true;\n    if (a == null && b != null || a != null && b == null) return false;\n    if (typeof a?.isEqual === \"function\" && typeof b?.isEqual === \"function\") {\n        return a.isEqual(b);\n    }\n    if (typeof a === \"function\" && typeof b === \"function\") {\n        return a.toString() === b.toString();\n    }\n    if (isArrayLike(a) && isArrayLike(b)) {\n        return isArrayEqual(Array.from(a), Array.from(b));\n    }\n    if (!(typeof a === \"object\") || !(typeof b === \"object\")) return false;\n    const keys = Object.keys(b ?? /* @__PURE__ */ Object.create(null));\n    const length = keys.length;\n    for(let i = 0; i < length; i++){\n        const hasKey = Reflect.has(a, keys[i]);\n        if (!hasKey) return false;\n    }\n    for(let i = 0; i < length; i++){\n        const key = keys[i];\n        if (!isEqual(a[key], b[key])) return false;\n    }\n    return true;\n};\n// ../../utilities/core/src/guard.ts\nvar isDev = ()=>\"development\" !== \"production\";\n// ../../utilities/core/src/object.ts\nfunction compact(obj) {\n    if (!isPlainObject(obj) || obj === void 0) {\n        return obj;\n    }\n    const keys = Reflect.ownKeys(obj).filter((key)=>typeof key === \"string\");\n    const filtered = {};\n    for (const key of keys){\n        const value = obj[key];\n        if (value !== void 0) {\n            filtered[key] = compact(value);\n        }\n    }\n    return filtered;\n}\nvar isPlainObject = (value)=>{\n    return value && typeof value === \"object\" && value.constructor === Object;\n};\n// src/use-snapshot.ts\n\n\n// src/use-update-effect.ts\n\nfunction useUpdateEffect(callback, deps) {\n    const render = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    const effect = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const mounted = render.current;\n        const run = mounted && effect.current;\n        if (run) {\n            return callback();\n        }\n        effect.current = true;\n    }, deps);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        render.current = true;\n        return ()=>{\n            render.current = false;\n        };\n    }, []);\n}\n// src/use-snapshot.ts\nvar { use } = react__WEBPACK_IMPORTED_MODULE_1__;\nvar targetCache = (0,_zag_js_store__WEBPACK_IMPORTED_MODULE_4__.makeGlobal)(\"__zag__targetCache\", ()=>/* @__PURE__ */ new WeakMap());\nfunction useSnapshot(service, options) {\n    const { actions, context, sync: notifyInSync } = options ?? {};\n    const lastSnapshot = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    const lastAffected = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    const currSnapshot = (0,react__WEBPACK_IMPORTED_MODULE_1__.useSyncExternalStore)((0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((callback)=>(0,_zag_js_store__WEBPACK_IMPORTED_MODULE_4__.subscribe)(service.state, callback, notifyInSync), [\n        notifyInSync\n    ]), ()=>{\n        const nextSnapshot = (0,_zag_js_store__WEBPACK_IMPORTED_MODULE_4__.snapshot)(service.state, use);\n        try {\n            if (lastSnapshot.current && lastAffected.current && !(0,proxy_compare__WEBPACK_IMPORTED_MODULE_5__.isChanged)(lastSnapshot.current, nextSnapshot, lastAffected.current, /* @__PURE__ */ new WeakMap())) {\n                return lastSnapshot.current;\n            }\n        } catch  {}\n        return nextSnapshot;\n    }, ()=>(0,_zag_js_store__WEBPACK_IMPORTED_MODULE_4__.snapshot)(service.state, use));\n    service.setOptions({\n        actions\n    });\n    const ctx = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>compact(context ?? {}), [\n        context\n    ]);\n    useUpdateEffect(()=>{\n        const entries = Object.entries(ctx);\n        const previousCtx = service.contextSnapshot ?? {};\n        const equality = entries.map(([key, value])=>({\n                key,\n                curr: value,\n                prev: previousCtx[key],\n                equal: isEqual(previousCtx[key], value)\n            }));\n        const allEqual = equality.every(({ equal })=>equal);\n        if (!allEqual) {\n            service.setContext(ctx);\n        }\n    }, [\n        ctx\n    ]);\n    const currAffected = /* @__PURE__ */ new WeakMap();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        lastSnapshot.current = currSnapshot;\n        lastAffected.current = currAffected;\n    });\n    const proxyCache = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>/* @__PURE__ */ new WeakMap(), []);\n    return (0,proxy_compare__WEBPACK_IMPORTED_MODULE_5__.createProxy)(currSnapshot, currAffected, proxyCache, targetCache);\n}\n// src/use-actor.ts\nfunction useActor(service) {\n    const state = useSnapshot(service);\n    return [\n        state,\n        service.send\n    ];\n}\n// src/use-service.ts\n\n// src/use-constant.ts\n\nfunction useConstant(fn) {\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    if (!ref.current) ref.current = {\n        v: fn()\n    };\n    return ref.current.v;\n}\n// src/use-layout-effect.ts\n\nvar useSafeLayoutEffect = typeof document !== \"undefined\" ? react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_1__.useEffect;\n// src/use-service.ts\nfunction useService(machine, options) {\n    const { state: hydratedState, context } = options ?? {};\n    const service = useConstant(()=>{\n        const instance = typeof machine === \"function\" ? machine() : machine;\n        if (context) instance.setContext(context);\n        instance._created();\n        return instance;\n    });\n    const snapshotRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    useSafeLayoutEffect(()=>{\n        const stateInit = hydratedState ?? snapshotRef.current;\n        service.start(stateInit);\n        return ()=>{\n            if (isDev()) {\n                snapshotRef.current = service.getHydrationState();\n            }\n            service.stop();\n        };\n    }, []);\n    return service;\n}\n// src/use-machine.ts\nfunction useMachine(machine, options) {\n    const service = useService(machine, options);\n    const state = useSnapshot(service, options);\n    return [\n        state,\n        service.send,\n        service\n    ];\n}\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHphZy1qcy9yZWFjdC9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQTJCOztBQ0FNO0FBYzFCLElBQU1FLGlCQUFpQkQsK0RBQWdCQSxDQUFZLENBQUNFLElBQU1BOztBQ2J4QztBQUNJO0FBWU07QUFKNUIsSUFBTUssU0FBUyxDQUFDQztJQUNyQixNQUFNLEVBQUVDLFFBQUEsRUFBVUMsU0FBQSxFQUFXQyxRQUFBLEVBQVVDLFdBQUEsRUFBWSxHQUFJSjtJQUV2RCxNQUFNSyxXQUFXLGdCQUFrQjtJQUNuQyxJQUFJQSxZQUFZRixVQUFVLE9BQU8sZ0JBQUFMLHNEQUFBQSxDQUFBRCx1REFBQUEsRUFBQTtRQUFHSTtJQUFBO0lBRXBDLE1BQU1LLE1BQU1GLGdCQUFnQkcsaUJBQWlCQztJQUM3QyxNQUFNQyxZQUFZUCxXQUFXUSxXQUFXSixJQUFJSyxJQUFBO0lBRTVDLE9BQU8sZ0JBQUFiLHNEQUFBQSxDQUFBRCx1REFBQUEsRUFBQTtRQUFHSSxVQUFBTiwyQ0FBUUEsQ0FBQ2lCLEdBQUEsQ0FBSVgsVUFBVSxDQUFDWSxzQkFBVWpCLHVEQUFZQSxDQUFDaUIsT0FBT0o7SUFBVTtBQUM1RTs7QUNqQitEOztBQ0gvRCxJQUFNUSxjQUFjLENBQUNDLFFBQWVBLE9BQU9DLFlBQVlDLFNBQVM7QUFFaEUsSUFBTUMsZUFBZSxDQUFDQyxHQUFVQztJQUM5QixJQUFJRCxFQUFFRSxNQUFBLEtBQVdELEVBQUVDLE1BQUEsRUFBUSxPQUFPO0lBQ2xDLFFBQVNDLElBQUksR0FBR0EsSUFBSUgsRUFBRUUsTUFBQSxFQUFRQyxJQUFLO1FBQ2pDLElBQUksQ0FBQ0MsUUFBUUosQ0FBQSxDQUFFRyxFQUFDLEVBQUdGLENBQUEsQ0FBRUUsRUFBRSxHQUFHLE9BQU87SUFDbkM7SUFDQSxPQUFPO0FBQ1Q7QUFFTyxJQUFNQyxVQUFVLENBQUNKLEdBQVFDO0lBQzlCLElBQUlJLE9BQU9DLEVBQUEsQ0FBR04sR0FB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QVlKLGlCQUFpQkcsWUFBWTdGLE9BQUE7UUFDL0N3RCxRQUFRdUMsS0FBQSxDQUFNRDtRQUNkLE9BQU87WUFFTCxJQUFJbEUsU0FBUztnQkFDWGlFLFlBQVk3RixPQUFBLEdBQVV3RCxRQUFRd0MsaUJBQUE7WUFDaEM7WUFDQXhDLFFBQVF5QyxJQUFBO1FBQ1Y7SUFDRixHQUFHLEVBQUU7SUFFTCxPQUFPekM7QUFDVDs7QUcvQk8sU0FBUzBDLFdBSWRULE9BQUEsRUFBK0NoQyxPQUFBO0lBQy9DLE1BQU1ELFVBQVVnQyxXQUFXQyxTQUFTaEM7SUFDcEMsTUFBTVEsUUFBUVYsWUFBWUMsU0FBU0M7SUFDbkMsT0FBTztRQUFDUTtRQUFPVCxRQUFRMEIsSUFBQTtRQUFNMUI7S0FBTztBQUN0QyIsInNvdXJjZXMiOlsid2VicGFjazovL3NpdGVzLy4uL3NyYy9pbmRleC50cz81MmQ1Iiwid2VicGFjazovL3NpdGVzLy4uL3NyYy9ub3JtYWxpemUtcHJvcHMudHM/NDcyMiIsIndlYnBhY2s6Ly9zaXRlcy8uLi9zcmMvcG9ydGFsLnRzeD9mYmEwIiwid2VicGFjazovL3NpdGVzLy4uL3NyYy91c2Utc25hcHNob3QudHM/NGRhNCIsIndlYnBhY2s6Ly9zaXRlcy8uLi8uLi8uLi91dGlsaXRpZXMvY29yZS9zcmMvZXF1YWwudHM/NGNiYyIsIndlYnBhY2s6Ly9zaXRlcy8uLi8uLi8uLi91dGlsaXRpZXMvY29yZS9zcmMvZ3VhcmQudHM/ODliMyIsIndlYnBhY2s6Ly9zaXRlcy8uLi8uLi8uLi91dGlsaXRpZXMvY29yZS9zcmMvb2JqZWN0LnRzPzc5ZGMiLCJ3ZWJwYWNrOi8vc2l0ZXMvLi4vc3JjL3VzZS11cGRhdGUtZWZmZWN0LnRzP2Y4MDciLCJ3ZWJwYWNrOi8vc2l0ZXMvLi4vc3JjL3VzZS1hY3Rvci50cz9iMTRlIiwid2VicGFjazovL3NpdGVzLy4uL3NyYy91c2Utc2VydmljZS50cz83NjI5Iiwid2VicGFjazovL3NpdGVzLy4uL3NyYy91c2UtY29uc3RhbnQudHM/ZDM4ZiIsIndlYnBhY2s6Ly9zaXRlcy8uLi9zcmMvdXNlLWxheW91dC1lZmZlY3QudHM/ODIzOCIsIndlYnBhY2s6Ly9zaXRlcy8uLi9zcmMvdXNlLW1hY2hpbmUudHM/YTY2MCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgeyBtZXJnZVByb3BzIH0gZnJvbSBcIkB6YWctanMvY29yZVwiXG5leHBvcnQgdHlwZSB7IENvbnRleHRGcm9tLCBFdmVudEZyb20sIFN0YXRlRnJvbSB9IGZyb20gXCJAemFnLWpzL2NvcmVcIlxuZXhwb3J0ICogZnJvbSBcIi4vbm9ybWFsaXplLXByb3BzXCJcbmV4cG9ydCB7IFBvcnRhbCB9IGZyb20gXCIuL3BvcnRhbFwiXG5leHBvcnQgdHlwZSB7IFBvcnRhbFByb3BzIH0gZnJvbSBcIi4vcG9ydGFsXCJcbmV4cG9ydCAqIGZyb20gXCIuL3VzZS1hY3RvclwiXG5leHBvcnQgKiBmcm9tIFwiLi91c2UtbWFjaGluZVwiXG4iLCJpbXBvcnQgeyBjcmVhdGVOb3JtYWxpemVyIH0gZnJvbSBcIkB6YWctanMvdHlwZXNcIlxuaW1wb3J0IHR5cGUgeyBIVE1MQXR0cmlidXRlcywgQ1NTUHJvcGVydGllcywgSlNYIH0gZnJvbSBcInJlYWN0XCJcblxudHlwZSBXaXRob3V0UmVmPFQ+ID0gT21pdDxULCBcInJlZlwiPlxuXG50eXBlIEVsZW1lbnRzV2l0aG91dFJlZiA9IHtcbiAgW0sgaW4ga2V5b2YgSlNYLkludHJpbnNpY0VsZW1lbnRzXTogV2l0aG91dFJlZjxKU1guSW50cmluc2ljRWxlbWVudHNbS10+XG59XG5cbmV4cG9ydCB0eXBlIFByb3BUeXBlcyA9IEVsZW1lbnRzV2l0aG91dFJlZiAmIHtcbiAgZWxlbWVudDogV2l0aG91dFJlZjxIVE1MQXR0cmlidXRlczxIVE1MRWxlbWVudD4+XG4gIHN0eWxlOiBDU1NQcm9wZXJ0aWVzXG59XG5cbmV4cG9ydCBjb25zdCBub3JtYWxpemVQcm9wcyA9IGNyZWF0ZU5vcm1hbGl6ZXI8UHJvcFR5cGVzPigodikgPT4gdilcbiIsImltcG9ydCB0eXBlIHsgSlNYLCBQcm9wc1dpdGhDaGlsZHJlbiwgUmVmT2JqZWN0IH0gZnJvbSBcInJlYWN0XCJcbmltcG9ydCB7IENoaWxkcmVuIH0gZnJvbSBcInJlYWN0XCJcbmltcG9ydCB7IGNyZWF0ZVBvcnRhbCB9IGZyb20gXCJyZWFjdC1kb21cIlxuXG5leHBvcnQgaW50ZXJmYWNlIFBvcnRhbFByb3BzIHtcbiAgZGlzYWJsZWQ/OiBib29sZWFuXG4gIGNvbnRhaW5lcj86IFJlZk9iamVjdDxIVE1MRWxlbWVudD5cbiAgZ2V0Um9vdE5vZGU/OiAoKSA9PiBTaGFkb3dSb290IHwgRG9jdW1lbnQgfCBOb2RlXG59XG5cbmV4cG9ydCBjb25zdCBQb3J0YWwgPSAocHJvcHM6IFByb3BzV2l0aENoaWxkcmVuPFBvcnRhbFByb3BzPik6IEpTWC5FbGVtZW50ID0+IHtcbiAgY29uc3QgeyBjaGlsZHJlbiwgY29udGFpbmVyLCBkaXNhYmxlZCwgZ2V0Um9vdE5vZGUgfSA9IHByb3BzXG5cbiAgY29uc3QgaXNTZXJ2ZXIgPSB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiXG4gIGlmIChpc1NlcnZlciB8fCBkaXNhYmxlZCkgcmV0dXJuIDw+e2NoaWxkcmVufTwvPlxuXG4gIGNvbnN0IGRvYyA9IGdldFJvb3ROb2RlPy4oKS5vd25lckRvY3VtZW50ID8/IGRvY3VtZW50XG4gIGNvbnN0IG1vdW50Tm9kZSA9IGNvbnRhaW5lcj8uY3VycmVudCA/PyBkb2MuYm9keVxuXG4gIHJldHVybiA8PntDaGlsZHJlbi5tYXAoY2hpbGRyZW4sIChjaGlsZCkgPT4gY3JlYXRlUG9ydGFsKGNoaWxkLCBtb3VudE5vZGUpKX08Lz5cbn1cbiIsIi8vLyA8cmVmZXJlbmNlIHR5cGVzPVwicmVhY3QvZXhwZXJpbWVudGFsXCIgLz5cblxuaW1wb3J0IHR5cGUgeyBNYWNoaW5lLCBTdGF0ZU1hY2hpbmUgYXMgUyB9IGZyb20gXCJAemFnLWpzL2NvcmVcIlxuaW1wb3J0IHsgc25hcHNob3QsIHN1YnNjcmliZSwgdHlwZSBTbmFwc2hvdCwgbWFrZUdsb2JhbCB9IGZyb20gXCJAemFnLWpzL3N0b3JlXCJcbmltcG9ydCB7IGNvbXBhY3QsIGlzRXF1YWwgfSBmcm9tIFwiQHphZy1qcy91dGlsc1wiXG5pbXBvcnQgeyBjcmVhdGVQcm94eSBhcyBjcmVhdGVQcm94eVRvQ29tcGFyZSwgaXNDaGFuZ2VkIH0gZnJvbSBcInByb3h5LWNvbXBhcmVcIlxuaW1wb3J0IFJlYWN0RXhwb3J0LCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZU1lbW8sIHVzZVJlZiwgdXNlU3luY0V4dGVybmFsU3RvcmUgfSBmcm9tIFwicmVhY3RcIlxuaW1wb3J0IHsgdXNlVXBkYXRlRWZmZWN0IH0gZnJvbSBcIi4vdXNlLXVwZGF0ZS1lZmZlY3RcIlxuXG4vL0B0cy1pZ25vcmVcbmNvbnN0IHsgdXNlIH0gPSBSZWFjdEV4cG9ydFxuXG5jb25zdCB0YXJnZXRDYWNoZSA9IG1ha2VHbG9iYWwoXCJfX3phZ19fdGFyZ2V0Q2FjaGVcIiwgKCkgPT4gbmV3IFdlYWtNYXAoKSlcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVNuYXBzaG90PFxuICBUQ29udGV4dCBleHRlbmRzIFJlY29yZDxzdHJpbmcsIGFueT4sXG4gIFRTdGF0ZSBleHRlbmRzIFMuU3RhdGVTY2hlbWEsXG4gIFRFdmVudCBleHRlbmRzIFMuRXZlbnRPYmplY3QgPSBTLkFueUV2ZW50T2JqZWN0LFxuPihcbiAgc2VydmljZTogTWFjaGluZTxUQ29udGV4dCwgVFN0YXRlLCBURXZlbnQ+LFxuICBvcHRpb25zPzogUy5Ib29rT3B0aW9uczxUQ29udGV4dCwgVFN0YXRlLCBURXZlbnQ+ICYgeyBzeW5jPzogYm9vbGVhbiB9LFxuKTogUy5TdGF0ZTxUQ29udGV4dCwgVFN0YXRlLCBURXZlbnQ+IHtcbiAgLy9cbiAgdHlwZSBTdGF0ZSA9IFMuU3RhdGU8VENvbnRleHQsIFRTdGF0ZSwgVEV2ZW50PlxuXG4gIGNvbnN0IHsgYWN0aW9ucywgY29udGV4dCwgc3luYzogbm90aWZ5SW5TeW5jIH0gPSBvcHRpb25zID8/IHt9XG5cbiAgLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogU3Vic2NyaWJlIHRvIHRoZSBzZXJ2aWNlIHN0YXRlIGFuZCBjcmVhdGUgYSBzbmFwc2hvdCBvZiBpdFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgY29uc3QgbGFzdFNuYXBzaG90ID0gdXNlUmVmPFNuYXBzaG90PFN0YXRlPj4oKVxuICBjb25zdCBsYXN0QWZmZWN0ZWQgPSB1c2VSZWY8V2Vha01hcDxvYmplY3QsIHVua25vd24+PigpXG5cbiAgY29uc3QgY3VyclNuYXBzaG90ID0gdXNlU3luY0V4dGVybmFsU3RvcmUoXG4gICAgdXNlQ2FsbGJhY2soKGNhbGxiYWNrKSA9PiBzdWJzY3JpYmUoc2VydmljZS5zdGF0ZSwgY2FsbGJhY2ssIG5vdGlmeUluU3luYyksIFtub3RpZnlJblN5bmNdKSxcbiAgICAoKSA9PiB7XG4gICAgICBjb25zdCBuZXh0U25hcHNob3QgPSBzbmFwc2hvdChzZXJ2aWNlLnN0YXRlLCB1c2UpXG4gICAgICB0cnkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgbGFzdFNuYXBzaG90LmN1cnJlbnQgJiZcbiAgICAgICAgICBsYXN0QWZmZWN0ZWQuY3VycmVudCAmJlxuICAgICAgICAgICFpc0NoYW5nZWQobGFzdFNuYXBzaG90LmN1cnJlbnQsIG5leHRTbmFwc2hvdCwgbGFzdEFmZmVjdGVkLmN1cnJlbnQsIG5ldyBXZWFrTWFwKCkpXG4gICAgICAgICkge1xuICAgICAgICAgIHJldHVybiBsYXN0U25hcHNob3QuY3VycmVudFxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgLy8gaWdub3JlIGlmIGEgcHJvbWlzZSBvciBzb21ldGhpbmcgaXMgdGhyb3duXG4gICAgICB9XG4gICAgICByZXR1cm4gbmV4dFNuYXBzaG90XG4gICAgfSxcbiAgICAoKSA9PiBzbmFwc2hvdChzZXJ2aWNlLnN0YXRlLCB1c2UpLFxuICApXG5cbiAgLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogU3luYyBhY3Rpb25zXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICBzZXJ2aWNlLnNldE9wdGlvbnMoeyBhY3Rpb25zIH0pXG5cbiAgLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogU3luYyBjb250ZXh0IChpZiBjaGFuZ2VkKSB0byBhdm9pZCB1bm5lY2Vzc2FyeSByZW5kZXJzXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICBjb25zdCBjdHggPSB1c2VNZW1vKCgpID0+IGNvbXBhY3QoY29udGV4dCA/PyB7fSksIFtjb250ZXh0XSlcblxuICB1c2VVcGRhdGVFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGVudHJpZXMgPSBPYmplY3QuZW50cmllcyhjdHgpXG5cbiAgICBjb25zdCBwcmV2aW91c0N0eCA9IHNlcnZpY2UuY29udGV4dFNuYXBzaG90ID8/IHt9XG5cbiAgICBjb25zdCBlcXVhbGl0eSA9IGVudHJpZXMubWFwKChba2V5LCB2YWx1ZV0pID0+ICh7XG4gICAgICBrZXksXG4gICAgICBjdXJyOiB2YWx1ZSxcbiAgICAgIHByZXY6IHByZXZpb3VzQ3R4W2tleV0sXG4gICAgICBlcXVhbDogaXNFcXVhbChwcmV2aW91c0N0eFtrZXldLCB2YWx1ZSksXG4gICAgfSkpXG5cbiAgICBjb25zdCBhbGxFcXVhbCA9IGVxdWFsaXR5LmV2ZXJ5KCh7IGVxdWFsIH0pID0+IGVxdWFsKVxuXG4gICAgaWYgKCFhbGxFcXVhbCkge1xuICAgICAgLy8gY29uc29sZS5sb2coZXF1YWxpdHkuZmlsdGVyKCh7IGVxdWFsIH0pID0+ICFlcXVhbCkpXG4gICAgICBzZXJ2aWNlLnNldENvbnRleHQoY3R4KVxuICAgIH1cbiAgfSwgW2N0eF0pXG5cbiAgY29uc3QgY3VyckFmZmVjdGVkID0gbmV3IFdlYWtNYXAoKVxuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbGFzdFNuYXBzaG90LmN1cnJlbnQgPSBjdXJyU25hcHNob3RcbiAgICBsYXN0QWZmZWN0ZWQuY3VycmVudCA9IGN1cnJBZmZlY3RlZFxuICB9KVxuXG4gIGNvbnN0IHByb3h5Q2FjaGUgPSB1c2VNZW1vKCgpID0+IG5ldyBXZWFrTWFwKCksIFtdKSAvLyBwZXItaG9vayBwcm94eUNhY2hlXG5cbiAgcmV0dXJuIGNyZWF0ZVByb3h5VG9Db21wYXJlKGN1cnJTbmFwc2hvdCwgY3VyckFmZmVjdGVkLCBwcm94eUNhY2hlLCB0YXJnZXRDYWNoZSkgYXMgYW55XG59XG4iLCJjb25zdCBpc0FycmF5TGlrZSA9ICh2YWx1ZTogYW55KSA9PiB2YWx1ZT8uY29uc3RydWN0b3IubmFtZSA9PT0gXCJBcnJheVwiXG5cbmNvbnN0IGlzQXJyYXlFcXVhbCA9IChhOiBhbnlbXSwgYjogYW55W10pOiBib29sZWFuID0+IHtcbiAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgIGlmICghaXNFcXVhbChhW2ldLCBiW2ldKSkgcmV0dXJuIGZhbHNlXG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuZXhwb3J0IGNvbnN0IGlzRXF1YWwgPSAoYTogYW55LCBiOiBhbnkpOiBib29sZWFuID0+IHtcbiAgaWYgKE9iamVjdC5pcyhhLCBiKSkgcmV0dXJuIHRydWVcblxuICBpZiAoKGEgPT0gbnVsbCAmJiBiICE9IG51bGwpIHx8IChhICE9IG51bGwgJiYgYiA9PSBudWxsKSkgcmV0dXJuIGZhbHNlXG5cbiAgaWYgKHR5cGVvZiBhPy5pc0VxdWFsID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIGI/LmlzRXF1YWwgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiBhLmlzRXF1YWwoYilcbiAgfVxuXG4gIGlmICh0eXBlb2YgYSA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBiID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gYS50b1N0cmluZygpID09PSBiLnRvU3RyaW5nKClcbiAgfVxuXG4gIGlmIChpc0FycmF5TGlrZShhKSAmJiBpc0FycmF5TGlrZShiKSkge1xuICAgIHJldHVybiBpc0FycmF5RXF1YWwoQXJyYXkuZnJvbShhKSwgQXJyYXkuZnJvbShiKSlcbiAgfVxuXG4gIGlmICghKHR5cGVvZiBhID09PSBcIm9iamVjdFwiKSB8fCAhKHR5cGVvZiBiID09PSBcIm9iamVjdFwiKSkgcmV0dXJuIGZhbHNlXG5cbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGIgPz8gT2JqZWN0LmNyZWF0ZShudWxsKSlcbiAgY29uc3QgbGVuZ3RoID0ga2V5cy5sZW5ndGhcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgaGFzS2V5ID0gUmVmbGVjdC5oYXMoYSwga2V5c1tpXSlcbiAgICBpZiAoIWhhc0tleSkgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qga2V5ID0ga2V5c1tpXVxuICAgIGlmICghaXNFcXVhbChhW2tleV0sIGJba2V5XSkpIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cbiIsImV4cG9ydCBjb25zdCBpc0RldiA9ICgpID0+IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIlxuZXhwb3J0IGNvbnN0IGlzQXJyYXkgPSAodjogYW55KTogdiBpcyBhbnlbXSA9PiBBcnJheS5pc0FycmF5KHYpXG5leHBvcnQgY29uc3QgaXNCb29sZWFuID0gKHY6IGFueSk6IHYgaXMgYm9vbGVhbiA9PiB2ID09PSB0cnVlIHx8IHYgPT09IGZhbHNlXG5leHBvcnQgY29uc3QgaXNPYmplY3QgPSAodjogYW55KTogdiBpcyBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0+ICEodiA9PSBudWxsIHx8IHR5cGVvZiB2ICE9PSBcIm9iamVjdFwiIHx8IGlzQXJyYXkodikpXG5leHBvcnQgY29uc3QgaXNOdW1iZXIgPSAodjogYW55KTogdiBpcyBudW1iZXIgPT4gdHlwZW9mIHYgPT09IFwibnVtYmVyXCIgJiYgIU51bWJlci5pc05hTih2KVxuZXhwb3J0IGNvbnN0IGlzU3RyaW5nID0gKHY6IGFueSk6IHYgaXMgc3RyaW5nID0+IHR5cGVvZiB2ID09PSBcInN0cmluZ1wiXG5leHBvcnQgY29uc3QgaXNGdW5jdGlvbiA9ICh2OiBhbnkpOiB2IGlzIEZ1bmN0aW9uID0+IHR5cGVvZiB2ID09PSBcImZ1bmN0aW9uXCJcbmV4cG9ydCBjb25zdCBpc051bGwgPSAodjogYW55KTogdiBpcyBudWxsIHwgdW5kZWZpbmVkID0+IHYgPT0gbnVsbFxuXG5leHBvcnQgY29uc3QgaGFzUHJvcCA9IDxUIGV4dGVuZHMgc3RyaW5nPihvYmo6IGFueSwgcHJvcDogVCk6IG9iaiBpcyBSZWNvcmQ8VCwgYW55PiA9PlxuICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKVxuIiwiaW1wb3J0IHsgY3JlYXRlU3BsaXRQcm9wcyB9IGZyb20gXCIuL3NwbGl0LXByb3BzXCJcblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXBhY3Q8VCBleHRlbmRzIFJlY29yZDxzdHJpbmcsIHVua25vd24+IHwgdW5kZWZpbmVkPihvYmo6IFQpOiBUIHtcbiAgaWYgKCFpc1BsYWluT2JqZWN0KG9iaikgfHwgb2JqID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gb2JqXG4gIH1cblxuICBjb25zdCBrZXlzID0gUmVmbGVjdC5vd25LZXlzKG9iaikuZmlsdGVyKChrZXkpID0+IHR5cGVvZiBrZXkgPT09IFwic3RyaW5nXCIpXG4gIGNvbnN0IGZpbHRlcmVkOiBQYXJ0aWFsPFQ+ID0ge31cbiAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgIGNvbnN0IHZhbHVlID0gKG9iaiBhcyBhbnkpW2tleV1cbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZmlsdGVyZWRba2V5IGFzIGtleW9mIFRdID0gY29tcGFjdCh2YWx1ZSlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZpbHRlcmVkIGFzIFRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGpzb24odmFsdWU6IGFueSkge1xuICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh2YWx1ZSkpXG59XG5cbmNvbnN0IGlzUGxhaW5PYmplY3QgPSAodmFsdWU6IGFueSkgPT4ge1xuICByZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlLmNvbnN0cnVjdG9yID09PSBPYmplY3Rcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBpY2s8VCBleHRlbmRzIFJlY29yZDxzdHJpbmcsIGFueT4sIEsgZXh0ZW5kcyBrZXlvZiBUPihvYmo6IFQsIGtleXM6IEtbXSk6IFBpY2s8VCwgSz4ge1xuICBjb25zdCBmaWx0ZXJlZDogUGFydGlhbDxUPiA9IHt9XG5cbiAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgIGNvbnN0IHZhbHVlID0gb2JqW2tleV1cbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZmlsdGVyZWRba2V5XSA9IHZhbHVlXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZpbHRlcmVkIGFzIGFueVxufVxuXG5leHBvcnQgZnVuY3Rpb24gb21pdDxUIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgYW55Pj4ob2JqOiBULCBrZXlzOiBzdHJpbmdbXSkge1xuICByZXR1cm4gY3JlYXRlU3BsaXRQcm9wcyhrZXlzKShvYmopWzFdXG59XG4iLCJpbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJyZWFjdFwiXG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VVcGRhdGVFZmZlY3QoY2FsbGJhY2s6IFJlYWN0LkVmZmVjdENhbGxiYWNrLCBkZXBzOiBSZWFjdC5EZXBlbmRlbmN5TGlzdCkge1xuICBjb25zdCByZW5kZXIgPSB1c2VSZWYoZmFsc2UpXG4gIGNvbnN0IGVmZmVjdCA9IHVzZVJlZihmYWxzZSlcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IG1vdW50ZWQgPSByZW5kZXIuY3VycmVudFxuICAgIGNvbnN0IHJ1biA9IG1vdW50ZWQgJiYgZWZmZWN0LmN1cnJlbnRcbiAgICBpZiAocnVuKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soKVxuICAgIH1cbiAgICBlZmZlY3QuY3VycmVudCA9IHRydWVcbiAgfSwgZGVwcylcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJlbmRlci5jdXJyZW50ID0gdHJ1ZVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICByZW5kZXIuY3VycmVudCA9IGZhbHNlXG4gICAgfVxuICB9LCBbXSlcbn1cbiIsImltcG9ydCB0eXBlIHsgTWFjaGluZSwgU3RhdGVNYWNoaW5lIGFzIFMgfSBmcm9tIFwiQHphZy1qcy9jb3JlXCJcbmltcG9ydCB7IHVzZVNuYXBzaG90IH0gZnJvbSBcIi4vdXNlLXNuYXBzaG90XCJcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUFjdG9yPFxuICBUQ29udGV4dCBleHRlbmRzIFJlY29yZDxzdHJpbmcsIGFueT4sXG4gIFRTdGF0ZSBleHRlbmRzIFMuU3RhdGVTY2hlbWEsXG4gIFRFdmVudCBleHRlbmRzIFMuRXZlbnRPYmplY3QgPSBTLkFueUV2ZW50T2JqZWN0LFxuPihzZXJ2aWNlOiBNYWNoaW5lPFRDb250ZXh0LCBUU3RhdGUsIFRFdmVudD4pIHtcbiAgY29uc3Qgc3RhdGUgPSB1c2VTbmFwc2hvdChzZXJ2aWNlKVxuICByZXR1cm4gW3N0YXRlLCBzZXJ2aWNlLnNlbmRdIGFzIGNvbnN0XG59XG4iLCJpbXBvcnQgdHlwZSB7IE1hY2hpbmVTcmMsIFN0YXRlTWFjaGluZSBhcyBTIH0gZnJvbSBcIkB6YWctanMvY29yZVwiXG5pbXBvcnQgeyB1c2VSZWYgfSBmcm9tIFwicmVhY3RcIlxuaW1wb3J0IHsgdXNlQ29uc3RhbnQgfSBmcm9tIFwiLi91c2UtY29uc3RhbnRcIlxuaW1wb3J0IHsgdXNlU2FmZUxheW91dEVmZmVjdCB9IGZyb20gXCIuL3VzZS1sYXlvdXQtZWZmZWN0XCJcbmltcG9ydCB7IGlzRGV2IH0gZnJvbSBcIkB6YWctanMvdXRpbHNcIlxuXG5leHBvcnQgZnVuY3Rpb24gdXNlU2VydmljZTxcbiAgVENvbnRleHQgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxuICBUU3RhdGUgZXh0ZW5kcyBTLlN0YXRlU2NoZW1hLFxuICBURXZlbnQgZXh0ZW5kcyBTLkV2ZW50T2JqZWN0ID0gUy5BbnlFdmVudE9iamVjdCxcbj4obWFjaGluZTogTWFjaGluZVNyYzxUQ29udGV4dCwgVFN0YXRlLCBURXZlbnQ+LCBvcHRpb25zPzogUy5Ib29rT3B0aW9uczxUQ29udGV4dCwgVFN0YXRlLCBURXZlbnQ+KSB7XG4gIGNvbnN0IHsgc3RhdGU6IGh5ZHJhdGVkU3RhdGUsIGNvbnRleHQgfSA9IG9wdGlvbnMgPz8ge31cblxuICBjb25zdCBzZXJ2aWNlID0gdXNlQ29uc3RhbnQoKCkgPT4ge1xuICAgIGNvbnN0IGluc3RhbmNlID0gdHlwZW9mIG1hY2hpbmUgPT09IFwiZnVuY3Rpb25cIiA/IG1hY2hpbmUoKSA6IG1hY2hpbmVcbiAgICBpZiAoY29udGV4dCkgaW5zdGFuY2Uuc2V0Q29udGV4dChjb250ZXh0KVxuICAgIGluc3RhbmNlLl9jcmVhdGVkKClcbiAgICByZXR1cm4gaW5zdGFuY2VcbiAgfSlcblxuICBjb25zdCBzbmFwc2hvdFJlZiA9IHVzZVJlZjxTLlN0YXRlSW5pdDxUQ29udGV4dCwgVFN0YXRlPj4oKVxuXG4gIHVzZVNhZmVMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHN0YXRlSW5pdCA9IGh5ZHJhdGVkU3RhdGUgPz8gc25hcHNob3RSZWYuY3VycmVudFxuICAgIHNlcnZpY2Uuc3RhcnQoc3RhdGVJbml0KVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAvLyBITVIgaW1wcm92ZW1lbnRzIGZvciBkZXZcbiAgICAgIGlmIChpc0RldigpKSB7XG4gICAgICAgIHNuYXBzaG90UmVmLmN1cnJlbnQgPSBzZXJ2aWNlLmdldEh5ZHJhdGlvblN0YXRlKClcbiAgICAgIH1cbiAgICAgIHNlcnZpY2Uuc3RvcCgpXG4gICAgfVxuICB9LCBbXSlcblxuICByZXR1cm4gc2VydmljZVxufVxuIiwiaW1wb3J0IHsgdXNlUmVmIH0gZnJvbSBcInJlYWN0XCJcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUNvbnN0YW50PFQ+KGZuOiAoKSA9PiBUKTogVCB7XG4gIGNvbnN0IHJlZiA9IHVzZVJlZjx7IHY6IFQgfT4oKVxuICBpZiAoIXJlZi5jdXJyZW50KSByZWYuY3VycmVudCA9IHsgdjogZm4oKSB9XG4gIHJldHVybiByZWYuY3VycmVudC52XG59XG4iLCJpbXBvcnQgeyB1c2VFZmZlY3QsIHVzZUxheW91dEVmZmVjdCB9IGZyb20gXCJyZWFjdFwiXG5cbmV4cG9ydCBjb25zdCB1c2VTYWZlTGF5b3V0RWZmZWN0ID0gdHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiID8gdXNlTGF5b3V0RWZmZWN0IDogdXNlRWZmZWN0XG4iLCJpbXBvcnQgdHlwZSB7IE1hY2hpbmVTcmMsIFN0YXRlTWFjaGluZSBhcyBTIH0gZnJvbSBcIkB6YWctanMvY29yZVwiXG5pbXBvcnQgeyB1c2VTZXJ2aWNlIH0gZnJvbSBcIi4vdXNlLXNlcnZpY2VcIlxuaW1wb3J0IHsgdXNlU25hcHNob3QgfSBmcm9tIFwiLi91c2Utc25hcHNob3RcIlxuXG5leHBvcnQgZnVuY3Rpb24gdXNlTWFjaGluZTxcbiAgVENvbnRleHQgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxuICBUU3RhdGUgZXh0ZW5kcyBTLlN0YXRlU2NoZW1hLFxuICBURXZlbnQgZXh0ZW5kcyBTLkV2ZW50T2JqZWN0ID0gUy5BbnlFdmVudE9iamVjdCxcbj4obWFjaGluZTogTWFjaGluZVNyYzxUQ29udGV4dCwgVFN0YXRlLCBURXZlbnQ+LCBvcHRpb25zPzogUy5Ib29rT3B0aW9uczxUQ29udGV4dCwgVFN0YXRlLCBURXZlbnQ+KSB7XG4gIGNvbnN0IHNlcnZpY2UgPSB1c2VTZXJ2aWNlKG1hY2hpbmUsIG9wdGlvbnMpXG4gIGNvbnN0IHN0YXRlID0gdXNlU25hcHNob3Qoc2VydmljZSwgb3B0aW9ucylcbiAgcmV0dXJuIFtzdGF0ZSwgc2VydmljZS5zZW5kLCBzZXJ2aWNlXSBhcyBjb25zdFxufVxuIl0sIm5hbWVzIjpbIm1lcmdlUHJvcHMiLCJjcmVhdGVOb3JtYWxpemVyIiwibm9ybWFsaXplUHJvcHMiLCJ2IiwiQ2hpbGRyZW4iLCJjcmVhdGVQb3J0YWwiLCJGcmFnbWVudCIsImpzeCIsIlBvcnRhbCIsInByb3BzIiwiY2hpbGRyZW4iLCJjb250YWluZXIiLCJkaXNhYmxlZCIsImdldFJvb3ROb2RlIiwiaXNTZXJ2ZXIiLCJkb2MiLCJvd25lckRvY3VtZW50IiwiZG9jdW1lbnQiLCJtb3VudE5vZGUiLCJjdXJyZW50IiwiYm9keSIsIm1hcCIsImNoaWxkIiwic25hcHNob3QiLCJzdWJzY3JpYmUiLCJtYWtlR2xvYmFsIiwiaXNBcnJheUxpa2UiLCJ2YWx1ZSIsImNvbnN0cnVjdG9yIiwibmFtZSIsImlzQXJyYXlFcXVhbCIsImEiLCJiIiwibGVuZ3RoIiwiaSIsImlzRXF1YWwiLCJPYmplY3QiLCJpcyIsInRvU3RyaW5nIiwiQXJyYXkiLCJmcm9tIiwia2V5cyIsImNyZWF0ZSIsImhhc0tleSIsIlJlZmxlY3QiLCJoYXMiLCJrZXkiLCJpc0RldiIsInByb2Nlc3MiLCJjb21wYWN0Iiwib2JqIiwiaXNQbGFpbk9iamVjdCIsIm93bktleXMiLCJmaWx0ZXIiLCJmaWx0ZXJlZCIsImNyZWF0ZVByb3h5IiwiY3JlYXRlUHJveHlUb0NvbXBhcmUiLCJpc0NoYW5nZWQiLCJSZWFjdEV4cG9ydCIsInVzZUNhbGxiYWNrIiwidXNlRWZmZWN0IiwidXNlTWVtbyIsInVzZVJlZiIsInVzZVN5bmNFeHRlcm5hbFN0b3JlIiwidXNlVXBkYXRlRWZmZWN0IiwiY2FsbGJhY2siLCJkZXBzIiwicmVuZGVyIiwiZWZmZWN0IiwibW91bnRlZCIsInJ1biIsInVzZSIsInRhcmdldENhY2hlIiwiV2Vha01hcCIsInVzZVNuYXBzaG90Iiwic2VydmljZSIsIm9wdGlvbnMiLCJhY3Rpb25zIiwiY29udGV4dCIsInN5bmMiLCJub3RpZnlJblN5bmMiLCJsYXN0U25hcHNob3QiLCJsYXN0QWZmZWN0ZWQiLCJjdXJyU25hcHNob3QiLCJzdGF0ZSIsIm5leHRTbmFwc2hvdCIsInNldE9wdGlvbnMiLCJjdHgiLCJlbnRyaWVzIiwicHJldmlvdXNDdHgiLCJjb250ZXh0U25hcHNob3QiLCJlcXVhbGl0eSIsImN1cnIiLCJwcmV2IiwiZXF1YWwiLCJhbGxFcXVhbCIsImV2ZXJ5Iiwic2V0Q29udGV4dCIsImN1cnJBZmZlY3RlZCIsInByb3h5Q2FjaGUiLCJ1c2VBY3RvciIsInNlbmQiLCJ1c2VDb25zdGFudCIsImZuIiwicmVmIiwidXNlTGF5b3V0RWZmZWN0IiwidXNlU2FmZUxheW91dEVmZmVjdCIsInVzZVNlcnZpY2UiLCJtYWNoaW5lIiwiaHlkcmF0ZWRTdGF0ZSIsImluc3RhbmNlIiwiX2NyZWF0ZWQiLCJzbmFwc2hvdFJlZiIsInN0YXRlSW5pdCIsInN0YXJ0IiwiZ2V0SHlkcmF0aW9uU3RhdGUiLCJzdG9wIiwidXNlTWFjaGluZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@zag-js/react/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@zag-js/store/dist/index.mjs":
/*!***************************************************!*\
  !*** ./node_modules/@zag-js/store/dist/index.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   makeGlobal: () => (/* binding */ makeGlobal),\n/* harmony export */   proxy: () => (/* binding */ proxy),\n/* harmony export */   proxyWithComputed: () => (/* binding */ proxyWithComputed),\n/* harmony export */   ref: () => (/* binding */ ref),\n/* harmony export */   snapshot: () => (/* binding */ snapshot),\n/* harmony export */   subscribe: () => (/* binding */ subscribe)\n/* harmony export */ });\n/* harmony import */ var proxy_compare__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! proxy-compare */ \"(ssr)/./node_modules/proxy-compare/dist/index.js\");\n// src/global.ts\nfunction getGlobal() {\n  if (typeof globalThis !== \"undefined\") return globalThis;\n  if (typeof self !== \"undefined\") return self;\n  if (typeof window !== \"undefined\") return window;\n  if (typeof global !== \"undefined\") return global;\n}\nfunction makeGlobal(key, value) {\n  const g = getGlobal();\n  if (!g) return value();\n  g[key] || (g[key] = value());\n  return g[key];\n}\n\n// src/proxy.ts\n\nvar isDev = () => \"development\" !== \"production\";\nvar isObject = (x) => typeof x === \"object\" && x !== null;\nvar proxyStateMap = makeGlobal(\"__zag__proxyStateMap\", () => /* @__PURE__ */ new WeakMap());\nvar refSet = makeGlobal(\"__zag__refSet\", () => /* @__PURE__ */ new WeakSet());\nvar buildProxyFunction = (objectIs = Object.is, newProxy = (target, handler) => new Proxy(target, handler), canProxy = (x) => isObject(x) && !refSet.has(x) && (Array.isArray(x) || !(Symbol.iterator in x)) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer), defaultHandlePromise = (promise) => {\n  switch (promise.status) {\n    case \"fulfilled\":\n      return promise.value;\n    case \"rejected\":\n      throw promise.reason;\n    default:\n      throw promise;\n  }\n}, snapCache = /* @__PURE__ */ new WeakMap(), createSnapshot = (target, version, handlePromise = defaultHandlePromise) => {\n  const cache = snapCache.get(target);\n  if (cache?.[0] === version) {\n    return cache[1];\n  }\n  const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));\n  (0,proxy_compare__WEBPACK_IMPORTED_MODULE_0__.markToTrack)(snap, true);\n  snapCache.set(target, [version, snap]);\n  Reflect.ownKeys(target).forEach((key) => {\n    const value = Reflect.get(target, key);\n    if (refSet.has(value)) {\n      (0,proxy_compare__WEBPACK_IMPORTED_MODULE_0__.markToTrack)(value, false);\n      snap[key] = value;\n    } else if (value instanceof Promise) {\n      Object.defineProperty(snap, key, {\n        get() {\n          return handlePromise(value);\n        }\n      });\n    } else if (proxyStateMap.has(value)) {\n      snap[key] = snapshot(value, handlePromise);\n    } else {\n      snap[key] = value;\n    }\n  });\n  return Object.freeze(snap);\n}, proxyCache = /* @__PURE__ */ new WeakMap(), versionHolder = [1, 1], proxyFunction2 = (initialObject) => {\n  if (!isObject(initialObject)) {\n    throw new Error(\"object required\");\n  }\n  const found = proxyCache.get(initialObject);\n  if (found) {\n    return found;\n  }\n  let version = versionHolder[0];\n  const listeners = /* @__PURE__ */ new Set();\n  const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {\n    if (version !== nextVersion) {\n      version = nextVersion;\n      listeners.forEach((listener) => listener(op, nextVersion));\n    }\n  };\n  let checkVersion = versionHolder[1];\n  const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {\n    if (checkVersion !== nextCheckVersion && !listeners.size) {\n      checkVersion = nextCheckVersion;\n      propProxyStates.forEach(([propProxyState]) => {\n        const propVersion = propProxyState[1](nextCheckVersion);\n        if (propVersion > version) {\n          version = propVersion;\n        }\n      });\n    }\n    return version;\n  };\n  const createPropListener = (prop) => (op, nextVersion) => {\n    const newOp = [...op];\n    newOp[1] = [prop, ...newOp[1]];\n    notifyUpdate(newOp, nextVersion);\n  };\n  const propProxyStates = /* @__PURE__ */ new Map();\n  const addPropListener = (prop, propProxyState) => {\n    if (isDev() && propProxyStates.has(prop)) {\n      throw new Error(\"prop listener already exists\");\n    }\n    if (listeners.size) {\n      const remove = propProxyState[3](createPropListener(prop));\n      propProxyStates.set(prop, [propProxyState, remove]);\n    } else {\n      propProxyStates.set(prop, [propProxyState]);\n    }\n  };\n  const removePropListener = (prop) => {\n    const entry = propProxyStates.get(prop);\n    if (entry) {\n      propProxyStates.delete(prop);\n      entry[1]?.();\n    }\n  };\n  const addListener = (listener) => {\n    listeners.add(listener);\n    if (listeners.size === 1) {\n      propProxyStates.forEach(([propProxyState, prevRemove], prop) => {\n        if (isDev() && prevRemove) {\n          throw new Error(\"remove already exists\");\n        }\n        const remove = propProxyState[3](createPropListener(prop));\n        propProxyStates.set(prop, [propProxyState, remove]);\n      });\n    }\n    const removeListener = () => {\n      listeners.delete(listener);\n      if (listeners.size === 0) {\n        propProxyStates.forEach(([propProxyState, remove], prop) => {\n          if (remove) {\n            remove();\n            propProxyStates.set(prop, [propProxyState]);\n          }\n        });\n      }\n    };\n    return removeListener;\n  };\n  const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));\n  const handler = {\n    deleteProperty(target, prop) {\n      const prevValue = Reflect.get(target, prop);\n      removePropListener(prop);\n      const deleted = Reflect.deleteProperty(target, prop);\n      if (deleted) {\n        notifyUpdate([\"delete\", [prop], prevValue]);\n      }\n      return deleted;\n    },\n    set(target, prop, value, receiver) {\n      const hasPrevValue = Reflect.has(target, prop);\n      const prevValue = Reflect.get(target, prop, receiver);\n      if (hasPrevValue && (objectIs(prevValue, value) || proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value)))) {\n        return true;\n      }\n      removePropListener(prop);\n      if (isObject(value)) {\n        value = (0,proxy_compare__WEBPACK_IMPORTED_MODULE_0__.getUntracked)(value) || value;\n      }\n      let nextValue = value;\n      if (Object.getOwnPropertyDescriptor(target, prop)?.set) {\n      } else if (value instanceof Promise) {\n        value.then((v) => {\n          Object.assign(value, { status: \"fulfilled\", value: v });\n          notifyUpdate([\"resolve\", [prop], v]);\n        }).catch((e) => {\n          Object.assign(value, { status: \"rejected\", reason: e });\n          notifyUpdate([\"reject\", [prop], e]);\n        });\n      } else {\n        if (!proxyStateMap.has(value) && canProxy(value)) {\n          nextValue = proxy(value);\n        }\n        const childProxyState = !refSet.has(nextValue) && proxyStateMap.get(nextValue);\n        if (childProxyState) {\n          addPropListener(prop, childProxyState);\n        }\n      }\n      Reflect.set(target, prop, nextValue, receiver);\n      notifyUpdate([\"set\", [prop], value, prevValue]);\n      return true;\n    }\n  };\n  const proxyObject = newProxy(baseObject, handler);\n  proxyCache.set(initialObject, proxyObject);\n  const proxyState = [baseObject, ensureVersion, createSnapshot, addListener];\n  proxyStateMap.set(proxyObject, proxyState);\n  Reflect.ownKeys(initialObject).forEach((key) => {\n    const desc = Object.getOwnPropertyDescriptor(initialObject, key);\n    if (desc.get || desc.set) {\n      Object.defineProperty(baseObject, key, desc);\n    } else {\n      proxyObject[key] = initialObject[key];\n    }\n  });\n  return proxyObject;\n}) => [\n  // public functions\n  proxyFunction2,\n  // shared state\n  proxyStateMap,\n  refSet,\n  // internal things\n  objectIs,\n  newProxy,\n  canProxy,\n  defaultHandlePromise,\n  snapCache,\n  createSnapshot,\n  proxyCache,\n  versionHolder\n];\nvar [proxyFunction] = buildProxyFunction();\nfunction proxy(initialObject = {}) {\n  return proxyFunction(initialObject);\n}\nfunction subscribe(proxyObject, callback, notifyInSync) {\n  const proxyState = proxyStateMap.get(proxyObject);\n  if (isDev() && !proxyState) {\n    console.warn(\"Please use proxy object\");\n  }\n  let promise;\n  const ops = [];\n  const addListener = proxyState[3];\n  let isListenerActive = false;\n  const listener = (op) => {\n    ops.push(op);\n    if (notifyInSync) {\n      callback(ops.splice(0));\n      return;\n    }\n    if (!promise) {\n      promise = Promise.resolve().then(() => {\n        promise = void 0;\n        if (isListenerActive) {\n          callback(ops.splice(0));\n        }\n      });\n    }\n  };\n  const removeListener = addListener(listener);\n  isListenerActive = true;\n  return () => {\n    isListenerActive = false;\n    removeListener();\n  };\n}\nfunction snapshot(proxyObject, handlePromise) {\n  const proxyState = proxyStateMap.get(proxyObject);\n  if (isDev() && !proxyState) {\n    console.warn(\"Please use proxy object\");\n  }\n  const [target, ensureVersion, createSnapshot] = proxyState;\n  return createSnapshot(target, ensureVersion(), handlePromise);\n}\nfunction ref(obj) {\n  refSet.add(obj);\n  return obj;\n}\n\n// src/proxy-computed.ts\nfunction proxyWithComputed(initialObject, computedFns) {\n  const keys = Object.keys(computedFns);\n  keys.forEach((key) => {\n    if (Object.getOwnPropertyDescriptor(initialObject, key)) {\n      throw new Error(\"object property already defined\");\n    }\n    const computedFn = computedFns[key];\n    const { get, set } = typeof computedFn === \"function\" ? { get: computedFn } : computedFn;\n    const desc = {};\n    desc.get = () => get(snapshot(proxyObject));\n    if (set) {\n      desc.set = (newValue) => set(proxyObject, newValue);\n    }\n    Object.defineProperty(initialObject, key, desc);\n  });\n  const proxyObject = proxy(initialObject);\n  return proxyObject;\n}\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHphZy1qcy9zdG9yZS9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDMEQ7QUFDMUQsa0JBQWtCLGFBQW9CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSwwREFBVztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSwwREFBVztBQUNqQjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwyREFBWTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxpQ0FBaUMsK0JBQStCO0FBQ2hFO0FBQ0EsU0FBUztBQUNULGlDQUFpQywrQkFBK0I7QUFDaEU7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVcsdUNBQXVDLGtCQUFrQjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBUUU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3NpdGVzLy4vbm9kZV9tb2R1bGVzL0B6YWctanMvc3RvcmUvZGlzdC9pbmRleC5tanM/MDM2MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvZ2xvYmFsLnRzXG5mdW5jdGlvbiBnZXRHbG9iYWwoKSB7XG4gIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIGdsb2JhbFRoaXM7XG4gIGlmICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIHNlbGY7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gd2luZG93O1xuICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIGdsb2JhbDtcbn1cbmZ1bmN0aW9uIG1ha2VHbG9iYWwoa2V5LCB2YWx1ZSkge1xuICBjb25zdCBnID0gZ2V0R2xvYmFsKCk7XG4gIGlmICghZykgcmV0dXJuIHZhbHVlKCk7XG4gIGdba2V5XSB8fCAoZ1trZXldID0gdmFsdWUoKSk7XG4gIHJldHVybiBnW2tleV07XG59XG5cbi8vIHNyYy9wcm94eS50c1xuaW1wb3J0IHsgZ2V0VW50cmFja2VkLCBtYXJrVG9UcmFjayB9IGZyb20gXCJwcm94eS1jb21wYXJlXCI7XG52YXIgaXNEZXYgPSAoKSA9PiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCI7XG52YXIgaXNPYmplY3QgPSAoeCkgPT4gdHlwZW9mIHggPT09IFwib2JqZWN0XCIgJiYgeCAhPT0gbnVsbDtcbnZhciBwcm94eVN0YXRlTWFwID0gbWFrZUdsb2JhbChcIl9femFnX19wcm94eVN0YXRlTWFwXCIsICgpID0+IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpKTtcbnZhciByZWZTZXQgPSBtYWtlR2xvYmFsKFwiX196YWdfX3JlZlNldFwiLCAoKSA9PiAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtTZXQoKSk7XG52YXIgYnVpbGRQcm94eUZ1bmN0aW9uID0gKG9iamVjdElzID0gT2JqZWN0LmlzLCBuZXdQcm94eSA9ICh0YXJnZXQsIGhhbmRsZXIpID0+IG5ldyBQcm94eSh0YXJnZXQsIGhhbmRsZXIpLCBjYW5Qcm94eSA9ICh4KSA9PiBpc09iamVjdCh4KSAmJiAhcmVmU2V0Lmhhcyh4KSAmJiAoQXJyYXkuaXNBcnJheSh4KSB8fCAhKFN5bWJvbC5pdGVyYXRvciBpbiB4KSkgJiYgISh4IGluc3RhbmNlb2YgV2Vha01hcCkgJiYgISh4IGluc3RhbmNlb2YgV2Vha1NldCkgJiYgISh4IGluc3RhbmNlb2YgRXJyb3IpICYmICEoeCBpbnN0YW5jZW9mIE51bWJlcikgJiYgISh4IGluc3RhbmNlb2YgRGF0ZSkgJiYgISh4IGluc3RhbmNlb2YgU3RyaW5nKSAmJiAhKHggaW5zdGFuY2VvZiBSZWdFeHApICYmICEoeCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSwgZGVmYXVsdEhhbmRsZVByb21pc2UgPSAocHJvbWlzZSkgPT4ge1xuICBzd2l0Y2ggKHByb21pc2Uuc3RhdHVzKSB7XG4gICAgY2FzZSBcImZ1bGZpbGxlZFwiOlxuICAgICAgcmV0dXJuIHByb21pc2UudmFsdWU7XG4gICAgY2FzZSBcInJlamVjdGVkXCI6XG4gICAgICB0aHJvdyBwcm9taXNlLnJlYXNvbjtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgcHJvbWlzZTtcbiAgfVxufSwgc25hcENhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIGNyZWF0ZVNuYXBzaG90ID0gKHRhcmdldCwgdmVyc2lvbiwgaGFuZGxlUHJvbWlzZSA9IGRlZmF1bHRIYW5kbGVQcm9taXNlKSA9PiB7XG4gIGNvbnN0IGNhY2hlID0gc25hcENhY2hlLmdldCh0YXJnZXQpO1xuICBpZiAoY2FjaGU/LlswXSA9PT0gdmVyc2lvbikge1xuICAgIHJldHVybiBjYWNoZVsxXTtcbiAgfVxuICBjb25zdCBzbmFwID0gQXJyYXkuaXNBcnJheSh0YXJnZXQpID8gW10gOiBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZih0YXJnZXQpKTtcbiAgbWFya1RvVHJhY2soc25hcCwgdHJ1ZSk7XG4gIHNuYXBDYWNoZS5zZXQodGFyZ2V0LCBbdmVyc2lvbiwgc25hcF0pO1xuICBSZWZsZWN0Lm93bktleXModGFyZ2V0KS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IFJlZmxlY3QuZ2V0KHRhcmdldCwga2V5KTtcbiAgICBpZiAocmVmU2V0Lmhhcyh2YWx1ZSkpIHtcbiAgICAgIG1hcmtUb1RyYWNrKHZhbHVlLCBmYWxzZSk7XG4gICAgICBzbmFwW2tleV0gPSB2YWx1ZTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNuYXAsIGtleSwge1xuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIGhhbmRsZVByb21pc2UodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHByb3h5U3RhdGVNYXAuaGFzKHZhbHVlKSkge1xuICAgICAgc25hcFtrZXldID0gc25hcHNob3QodmFsdWUsIGhhbmRsZVByb21pc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzbmFwW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShzbmFwKTtcbn0sIHByb3h5Q2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgdmVyc2lvbkhvbGRlciA9IFsxLCAxXSwgcHJveHlGdW5jdGlvbjIgPSAoaW5pdGlhbE9iamVjdCkgPT4ge1xuICBpZiAoIWlzT2JqZWN0KGluaXRpYWxPYmplY3QpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwib2JqZWN0IHJlcXVpcmVkXCIpO1xuICB9XG4gIGNvbnN0IGZvdW5kID0gcHJveHlDYWNoZS5nZXQoaW5pdGlhbE9iamVjdCk7XG4gIGlmIChmb3VuZCkge1xuICAgIHJldHVybiBmb3VuZDtcbiAgfVxuICBsZXQgdmVyc2lvbiA9IHZlcnNpb25Ib2xkZXJbMF07XG4gIGNvbnN0IGxpc3RlbmVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGNvbnN0IG5vdGlmeVVwZGF0ZSA9IChvcCwgbmV4dFZlcnNpb24gPSArK3ZlcnNpb25Ib2xkZXJbMF0pID0+IHtcbiAgICBpZiAodmVyc2lvbiAhPT0gbmV4dFZlcnNpb24pIHtcbiAgICAgIHZlcnNpb24gPSBuZXh0VmVyc2lvbjtcbiAgICAgIGxpc3RlbmVycy5mb3JFYWNoKChsaXN0ZW5lcikgPT4gbGlzdGVuZXIob3AsIG5leHRWZXJzaW9uKSk7XG4gICAgfVxuICB9O1xuICBsZXQgY2hlY2tWZXJzaW9uID0gdmVyc2lvbkhvbGRlclsxXTtcbiAgY29uc3QgZW5zdXJlVmVyc2lvbiA9IChuZXh0Q2hlY2tWZXJzaW9uID0gKyt2ZXJzaW9uSG9sZGVyWzFdKSA9PiB7XG4gICAgaWYgKGNoZWNrVmVyc2lvbiAhPT0gbmV4dENoZWNrVmVyc2lvbiAmJiAhbGlzdGVuZXJzLnNpemUpIHtcbiAgICAgIGNoZWNrVmVyc2lvbiA9IG5leHRDaGVja1ZlcnNpb247XG4gICAgICBwcm9wUHJveHlTdGF0ZXMuZm9yRWFjaCgoW3Byb3BQcm94eVN0YXRlXSkgPT4ge1xuICAgICAgICBjb25zdCBwcm9wVmVyc2lvbiA9IHByb3BQcm94eVN0YXRlWzFdKG5leHRDaGVja1ZlcnNpb24pO1xuICAgICAgICBpZiAocHJvcFZlcnNpb24gPiB2ZXJzaW9uKSB7XG4gICAgICAgICAgdmVyc2lvbiA9IHByb3BWZXJzaW9uO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHZlcnNpb247XG4gIH07XG4gIGNvbnN0IGNyZWF0ZVByb3BMaXN0ZW5lciA9IChwcm9wKSA9PiAob3AsIG5leHRWZXJzaW9uKSA9PiB7XG4gICAgY29uc3QgbmV3T3AgPSBbLi4ub3BdO1xuICAgIG5ld09wWzFdID0gW3Byb3AsIC4uLm5ld09wWzFdXTtcbiAgICBub3RpZnlVcGRhdGUobmV3T3AsIG5leHRWZXJzaW9uKTtcbiAgfTtcbiAgY29uc3QgcHJvcFByb3h5U3RhdGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3QgYWRkUHJvcExpc3RlbmVyID0gKHByb3AsIHByb3BQcm94eVN0YXRlKSA9PiB7XG4gICAgaWYgKGlzRGV2KCkgJiYgcHJvcFByb3h5U3RhdGVzLmhhcyhwcm9wKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwicHJvcCBsaXN0ZW5lciBhbHJlYWR5IGV4aXN0c1wiKTtcbiAgICB9XG4gICAgaWYgKGxpc3RlbmVycy5zaXplKSB7XG4gICAgICBjb25zdCByZW1vdmUgPSBwcm9wUHJveHlTdGF0ZVszXShjcmVhdGVQcm9wTGlzdGVuZXIocHJvcCkpO1xuICAgICAgcHJvcFByb3h5U3RhdGVzLnNldChwcm9wLCBbcHJvcFByb3h5U3RhdGUsIHJlbW92ZV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9wUHJveHlTdGF0ZXMuc2V0KHByb3AsIFtwcm9wUHJveHlTdGF0ZV0pO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgcmVtb3ZlUHJvcExpc3RlbmVyID0gKHByb3ApID0+IHtcbiAgICBjb25zdCBlbnRyeSA9IHByb3BQcm94eVN0YXRlcy5nZXQocHJvcCk7XG4gICAgaWYgKGVudHJ5KSB7XG4gICAgICBwcm9wUHJveHlTdGF0ZXMuZGVsZXRlKHByb3ApO1xuICAgICAgZW50cnlbMV0/LigpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgYWRkTGlzdGVuZXIgPSAobGlzdGVuZXIpID0+IHtcbiAgICBsaXN0ZW5lcnMuYWRkKGxpc3RlbmVyKTtcbiAgICBpZiAobGlzdGVuZXJzLnNpemUgPT09IDEpIHtcbiAgICAgIHByb3BQcm94eVN0YXRlcy5mb3JFYWNoKChbcHJvcFByb3h5U3RhdGUsIHByZXZSZW1vdmVdLCBwcm9wKSA9PiB7XG4gICAgICAgIGlmIChpc0RldigpICYmIHByZXZSZW1vdmUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyZW1vdmUgYWxyZWFkeSBleGlzdHNcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVtb3ZlID0gcHJvcFByb3h5U3RhdGVbM10oY3JlYXRlUHJvcExpc3RlbmVyKHByb3ApKTtcbiAgICAgICAgcHJvcFByb3h5U3RhdGVzLnNldChwcm9wLCBbcHJvcFByb3h5U3RhdGUsIHJlbW92ZV0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHJlbW92ZUxpc3RlbmVyID0gKCkgPT4ge1xuICAgICAgbGlzdGVuZXJzLmRlbGV0ZShsaXN0ZW5lcik7XG4gICAgICBpZiAobGlzdGVuZXJzLnNpemUgPT09IDApIHtcbiAgICAgICAgcHJvcFByb3h5U3RhdGVzLmZvckVhY2goKFtwcm9wUHJveHlTdGF0ZSwgcmVtb3ZlXSwgcHJvcCkgPT4ge1xuICAgICAgICAgIGlmIChyZW1vdmUpIHtcbiAgICAgICAgICAgIHJlbW92ZSgpO1xuICAgICAgICAgICAgcHJvcFByb3h5U3RhdGVzLnNldChwcm9wLCBbcHJvcFByb3h5U3RhdGVdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHJlbW92ZUxpc3RlbmVyO1xuICB9O1xuICBjb25zdCBiYXNlT2JqZWN0ID0gQXJyYXkuaXNBcnJheShpbml0aWFsT2JqZWN0KSA/IFtdIDogT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YoaW5pdGlhbE9iamVjdCkpO1xuICBjb25zdCBoYW5kbGVyID0ge1xuICAgIGRlbGV0ZVByb3BlcnR5KHRhcmdldCwgcHJvcCkge1xuICAgICAgY29uc3QgcHJldlZhbHVlID0gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wKTtcbiAgICAgIHJlbW92ZVByb3BMaXN0ZW5lcihwcm9wKTtcbiAgICAgIGNvbnN0IGRlbGV0ZWQgPSBSZWZsZWN0LmRlbGV0ZVByb3BlcnR5KHRhcmdldCwgcHJvcCk7XG4gICAgICBpZiAoZGVsZXRlZCkge1xuICAgICAgICBub3RpZnlVcGRhdGUoW1wiZGVsZXRlXCIsIFtwcm9wXSwgcHJldlZhbHVlXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVsZXRlZDtcbiAgICB9LFxuICAgIHNldCh0YXJnZXQsIHByb3AsIHZhbHVlLCByZWNlaXZlcikge1xuICAgICAgY29uc3QgaGFzUHJldlZhbHVlID0gUmVmbGVjdC5oYXModGFyZ2V0LCBwcm9wKTtcbiAgICAgIGNvbnN0IHByZXZWYWx1ZSA9IFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpO1xuICAgICAgaWYgKGhhc1ByZXZWYWx1ZSAmJiAob2JqZWN0SXMocHJldlZhbHVlLCB2YWx1ZSkgfHwgcHJveHlDYWNoZS5oYXModmFsdWUpICYmIG9iamVjdElzKHByZXZWYWx1ZSwgcHJveHlDYWNoZS5nZXQodmFsdWUpKSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZW1vdmVQcm9wTGlzdGVuZXIocHJvcCk7XG4gICAgICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gZ2V0VW50cmFja2VkKHZhbHVlKSB8fCB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGxldCBuZXh0VmFsdWUgPSB2YWx1ZTtcbiAgICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgcHJvcCk/LnNldCkge1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgdmFsdWUudGhlbigodikgPT4ge1xuICAgICAgICAgIE9iamVjdC5hc3NpZ24odmFsdWUsIHsgc3RhdHVzOiBcImZ1bGZpbGxlZFwiLCB2YWx1ZTogdiB9KTtcbiAgICAgICAgICBub3RpZnlVcGRhdGUoW1wicmVzb2x2ZVwiLCBbcHJvcF0sIHZdKTtcbiAgICAgICAgfSkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICBPYmplY3QuYXNzaWduKHZhbHVlLCB7IHN0YXR1czogXCJyZWplY3RlZFwiLCByZWFzb246IGUgfSk7XG4gICAgICAgICAgbm90aWZ5VXBkYXRlKFtcInJlamVjdFwiLCBbcHJvcF0sIGVdKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIXByb3h5U3RhdGVNYXAuaGFzKHZhbHVlKSAmJiBjYW5Qcm94eSh2YWx1ZSkpIHtcbiAgICAgICAgICBuZXh0VmFsdWUgPSBwcm94eSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2hpbGRQcm94eVN0YXRlID0gIXJlZlNldC5oYXMobmV4dFZhbHVlKSAmJiBwcm94eVN0YXRlTWFwLmdldChuZXh0VmFsdWUpO1xuICAgICAgICBpZiAoY2hpbGRQcm94eVN0YXRlKSB7XG4gICAgICAgICAgYWRkUHJvcExpc3RlbmVyKHByb3AsIGNoaWxkUHJveHlTdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFJlZmxlY3Quc2V0KHRhcmdldCwgcHJvcCwgbmV4dFZhbHVlLCByZWNlaXZlcik7XG4gICAgICBub3RpZnlVcGRhdGUoW1wic2V0XCIsIFtwcm9wXSwgdmFsdWUsIHByZXZWYWx1ZV0pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9O1xuICBjb25zdCBwcm94eU9iamVjdCA9IG5ld1Byb3h5KGJhc2VPYmplY3QsIGhhbmRsZXIpO1xuICBwcm94eUNhY2hlLnNldChpbml0aWFsT2JqZWN0LCBwcm94eU9iamVjdCk7XG4gIGNvbnN0IHByb3h5U3RhdGUgPSBbYmFzZU9iamVjdCwgZW5zdXJlVmVyc2lvbiwgY3JlYXRlU25hcHNob3QsIGFkZExpc3RlbmVyXTtcbiAgcHJveHlTdGF0ZU1hcC5zZXQocHJveHlPYmplY3QsIHByb3h5U3RhdGUpO1xuICBSZWZsZWN0Lm93bktleXMoaW5pdGlhbE9iamVjdCkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgY29uc3QgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaW5pdGlhbE9iamVjdCwga2V5KTtcbiAgICBpZiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShiYXNlT2JqZWN0LCBrZXksIGRlc2MpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm94eU9iamVjdFtrZXldID0gaW5pdGlhbE9iamVjdFtrZXldO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBwcm94eU9iamVjdDtcbn0pID0+IFtcbiAgLy8gcHVibGljIGZ1bmN0aW9uc1xuICBwcm94eUZ1bmN0aW9uMixcbiAgLy8gc2hhcmVkIHN0YXRlXG4gIHByb3h5U3RhdGVNYXAsXG4gIHJlZlNldCxcbiAgLy8gaW50ZXJuYWwgdGhpbmdzXG4gIG9iamVjdElzLFxuICBuZXdQcm94eSxcbiAgY2FuUHJveHksXG4gIGRlZmF1bHRIYW5kbGVQcm9taXNlLFxuICBzbmFwQ2FjaGUsXG4gIGNyZWF0ZVNuYXBzaG90LFxuICBwcm94eUNhY2hlLFxuICB2ZXJzaW9uSG9sZGVyXG5dO1xudmFyIFtwcm94eUZ1bmN0aW9uXSA9IGJ1aWxkUHJveHlGdW5jdGlvbigpO1xuZnVuY3Rpb24gcHJveHkoaW5pdGlhbE9iamVjdCA9IHt9KSB7XG4gIHJldHVybiBwcm94eUZ1bmN0aW9uKGluaXRpYWxPYmplY3QpO1xufVxuZnVuY3Rpb24gc3Vic2NyaWJlKHByb3h5T2JqZWN0LCBjYWxsYmFjaywgbm90aWZ5SW5TeW5jKSB7XG4gIGNvbnN0IHByb3h5U3RhdGUgPSBwcm94eVN0YXRlTWFwLmdldChwcm94eU9iamVjdCk7XG4gIGlmIChpc0RldigpICYmICFwcm94eVN0YXRlKSB7XG4gICAgY29uc29sZS53YXJuKFwiUGxlYXNlIHVzZSBwcm94eSBvYmplY3RcIik7XG4gIH1cbiAgbGV0IHByb21pc2U7XG4gIGNvbnN0IG9wcyA9IFtdO1xuICBjb25zdCBhZGRMaXN0ZW5lciA9IHByb3h5U3RhdGVbM107XG4gIGxldCBpc0xpc3RlbmVyQWN0aXZlID0gZmFsc2U7XG4gIGNvbnN0IGxpc3RlbmVyID0gKG9wKSA9PiB7XG4gICAgb3BzLnB1c2gob3ApO1xuICAgIGlmIChub3RpZnlJblN5bmMpIHtcbiAgICAgIGNhbGxiYWNrKG9wcy5zcGxpY2UoMCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXByb21pc2UpIHtcbiAgICAgIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgcHJvbWlzZSA9IHZvaWQgMDtcbiAgICAgICAgaWYgKGlzTGlzdGVuZXJBY3RpdmUpIHtcbiAgICAgICAgICBjYWxsYmFjayhvcHMuc3BsaWNlKDApKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICBjb25zdCByZW1vdmVMaXN0ZW5lciA9IGFkZExpc3RlbmVyKGxpc3RlbmVyKTtcbiAgaXNMaXN0ZW5lckFjdGl2ZSA9IHRydWU7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgaXNMaXN0ZW5lckFjdGl2ZSA9IGZhbHNlO1xuICAgIHJlbW92ZUxpc3RlbmVyKCk7XG4gIH07XG59XG5mdW5jdGlvbiBzbmFwc2hvdChwcm94eU9iamVjdCwgaGFuZGxlUHJvbWlzZSkge1xuICBjb25zdCBwcm94eVN0YXRlID0gcHJveHlTdGF0ZU1hcC5nZXQocHJveHlPYmplY3QpO1xuICBpZiAoaXNEZXYoKSAmJiAhcHJveHlTdGF0ZSkge1xuICAgIGNvbnNvbGUud2FybihcIlBsZWFzZSB1c2UgcHJveHkgb2JqZWN0XCIpO1xuICB9XG4gIGNvbnN0IFt0YXJnZXQsIGVuc3VyZVZlcnNpb24sIGNyZWF0ZVNuYXBzaG90XSA9IHByb3h5U3RhdGU7XG4gIHJldHVybiBjcmVhdGVTbmFwc2hvdCh0YXJnZXQsIGVuc3VyZVZlcnNpb24oKSwgaGFuZGxlUHJvbWlzZSk7XG59XG5mdW5jdGlvbiByZWYob2JqKSB7XG4gIHJlZlNldC5hZGQob2JqKTtcbiAgcmV0dXJuIG9iajtcbn1cblxuLy8gc3JjL3Byb3h5LWNvbXB1dGVkLnRzXG5mdW5jdGlvbiBwcm94eVdpdGhDb21wdXRlZChpbml0aWFsT2JqZWN0LCBjb21wdXRlZEZucykge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoY29tcHV0ZWRGbnMpO1xuICBrZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGluaXRpYWxPYmplY3QsIGtleSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIm9iamVjdCBwcm9wZXJ0eSBhbHJlYWR5IGRlZmluZWRcIik7XG4gICAgfVxuICAgIGNvbnN0IGNvbXB1dGVkRm4gPSBjb21wdXRlZEZuc1trZXldO1xuICAgIGNvbnN0IHsgZ2V0LCBzZXQgfSA9IHR5cGVvZiBjb21wdXRlZEZuID09PSBcImZ1bmN0aW9uXCIgPyB7IGdldDogY29tcHV0ZWRGbiB9IDogY29tcHV0ZWRGbjtcbiAgICBjb25zdCBkZXNjID0ge307XG4gICAgZGVzYy5nZXQgPSAoKSA9PiBnZXQoc25hcHNob3QocHJveHlPYmplY3QpKTtcbiAgICBpZiAoc2V0KSB7XG4gICAgICBkZXNjLnNldCA9IChuZXdWYWx1ZSkgPT4gc2V0KHByb3h5T2JqZWN0LCBuZXdWYWx1ZSk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpbml0aWFsT2JqZWN0LCBrZXksIGRlc2MpO1xuICB9KTtcbiAgY29uc3QgcHJveHlPYmplY3QgPSBwcm94eShpbml0aWFsT2JqZWN0KTtcbiAgcmV0dXJuIHByb3h5T2JqZWN0O1xufVxuZXhwb3J0IHtcbiAgbWFrZUdsb2JhbCxcbiAgcHJveHksXG4gIHByb3h5V2l0aENvbXB1dGVkLFxuICByZWYsXG4gIHNuYXBzaG90LFxuICBzdWJzY3JpYmVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@zag-js/store/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@zag-js/text-selection/dist/index.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@zag-js/text-selection/dist/index.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   disableTextSelection: () => (/* binding */ disableTextSelection),\n/* harmony export */   restoreTextSelection: () => (/* binding */ restoreTextSelection)\n/* harmony export */ });\n/* harmony import */ var _zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @zag-js/dom-query */ \"(ssr)/./node_modules/@zag-js/dom-query/dist/index.mjs\");\n// src/index.ts\n\nvar state = \"default\";\nvar userSelect = \"\";\nvar elementMap = /* @__PURE__ */ new WeakMap();\nfunction disableTextSelectionImpl(options = {}) {\n  const { target, doc } = options;\n  const docNode = doc ?? document;\n  const rootEl = docNode.documentElement;\n  if ((0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.isIos)()) {\n    if (state === \"default\") {\n      userSelect = rootEl.style.webkitUserSelect;\n      rootEl.style.webkitUserSelect = \"none\";\n    }\n    state = \"disabled\";\n  } else if (target) {\n    elementMap.set(target, target.style.userSelect);\n    target.style.userSelect = \"none\";\n  }\n  return () => restoreTextSelection({ target, doc: docNode });\n}\nfunction restoreTextSelection(options = {}) {\n  const { target, doc } = options;\n  const docNode = doc ?? document;\n  const rootEl = docNode.documentElement;\n  if ((0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.isIos)()) {\n    if (state !== \"disabled\") return;\n    state = \"restoring\";\n    setTimeout(() => {\n      (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.nextTick)(() => {\n        if (state === \"restoring\") {\n          if (rootEl.style.webkitUserSelect === \"none\") {\n            rootEl.style.webkitUserSelect = userSelect || \"\";\n          }\n          userSelect = \"\";\n          state = \"default\";\n        }\n      });\n    }, 300);\n  } else {\n    if (target && elementMap.has(target)) {\n      const prevUserSelect = elementMap.get(target);\n      if (target.style.userSelect === \"none\") {\n        target.style.userSelect = prevUserSelect ?? \"\";\n      }\n      if (target.getAttribute(\"style\") === \"\") {\n        target.removeAttribute(\"style\");\n      }\n      elementMap.delete(target);\n    }\n  }\n}\nfunction disableTextSelection(options = {}) {\n  const { defer, target, ...restOptions } = options;\n  const func = defer ? _zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.raf : (v) => v();\n  const cleanups = [];\n  cleanups.push(\n    func(() => {\n      const node = typeof target === \"function\" ? target() : target;\n      cleanups.push(disableTextSelectionImpl({ ...restOptions, target: node }));\n    })\n  );\n  return () => {\n    cleanups.forEach((fn) => fn?.());\n  };\n}\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHphZy1qcy90ZXh0LXNlbGVjdGlvbi9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUN5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUMsVUFBVSxjQUFjO0FBQ3hCO0FBQ0E7QUFDQSxNQUFNLHdEQUFLO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msc0JBQXNCO0FBQzVEO0FBQ0EsMENBQTBDO0FBQzFDLFVBQVUsY0FBYztBQUN4QjtBQUNBO0FBQ0EsTUFBTSx3REFBSztBQUNYO0FBQ0E7QUFDQTtBQUNBLE1BQU0sMkRBQVE7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQyxVQUFVLGdDQUFnQztBQUMxQyx1QkFBdUIsa0RBQUc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsOEJBQThCO0FBQzdFLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3NpdGVzLy4vbm9kZV9tb2R1bGVzL0B6YWctanMvdGV4dC1zZWxlY3Rpb24vZGlzdC9pbmRleC5tanM/ZWI4OSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvaW5kZXgudHNcbmltcG9ydCB7IGlzSW9zLCBuZXh0VGljaywgcmFmIH0gZnJvbSBcIkB6YWctanMvZG9tLXF1ZXJ5XCI7XG52YXIgc3RhdGUgPSBcImRlZmF1bHRcIjtcbnZhciB1c2VyU2VsZWN0ID0gXCJcIjtcbnZhciBlbGVtZW50TWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiBkaXNhYmxlVGV4dFNlbGVjdGlvbkltcGwob3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHsgdGFyZ2V0LCBkb2MgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGRvY05vZGUgPSBkb2MgPz8gZG9jdW1lbnQ7XG4gIGNvbnN0IHJvb3RFbCA9IGRvY05vZGUuZG9jdW1lbnRFbGVtZW50O1xuICBpZiAoaXNJb3MoKSkge1xuICAgIGlmIChzdGF0ZSA9PT0gXCJkZWZhdWx0XCIpIHtcbiAgICAgIHVzZXJTZWxlY3QgPSByb290RWwuc3R5bGUud2Via2l0VXNlclNlbGVjdDtcbiAgICAgIHJvb3RFbC5zdHlsZS53ZWJraXRVc2VyU2VsZWN0ID0gXCJub25lXCI7XG4gICAgfVxuICAgIHN0YXRlID0gXCJkaXNhYmxlZFwiO1xuICB9IGVsc2UgaWYgKHRhcmdldCkge1xuICAgIGVsZW1lbnRNYXAuc2V0KHRhcmdldCwgdGFyZ2V0LnN0eWxlLnVzZXJTZWxlY3QpO1xuICAgIHRhcmdldC5zdHlsZS51c2VyU2VsZWN0ID0gXCJub25lXCI7XG4gIH1cbiAgcmV0dXJuICgpID0+IHJlc3RvcmVUZXh0U2VsZWN0aW9uKHsgdGFyZ2V0LCBkb2M6IGRvY05vZGUgfSk7XG59XG5mdW5jdGlvbiByZXN0b3JlVGV4dFNlbGVjdGlvbihvcHRpb25zID0ge30pIHtcbiAgY29uc3QgeyB0YXJnZXQsIGRvYyB9ID0gb3B0aW9ucztcbiAgY29uc3QgZG9jTm9kZSA9IGRvYyA/PyBkb2N1bWVudDtcbiAgY29uc3Qgcm9vdEVsID0gZG9jTm9kZS5kb2N1bWVudEVsZW1lbnQ7XG4gIGlmIChpc0lvcygpKSB7XG4gICAgaWYgKHN0YXRlICE9PSBcImRpc2FibGVkXCIpIHJldHVybjtcbiAgICBzdGF0ZSA9IFwicmVzdG9yaW5nXCI7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBuZXh0VGljaygoKSA9PiB7XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gXCJyZXN0b3JpbmdcIikge1xuICAgICAgICAgIGlmIChyb290RWwuc3R5bGUud2Via2l0VXNlclNlbGVjdCA9PT0gXCJub25lXCIpIHtcbiAgICAgICAgICAgIHJvb3RFbC5zdHlsZS53ZWJraXRVc2VyU2VsZWN0ID0gdXNlclNlbGVjdCB8fCBcIlwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICB1c2VyU2VsZWN0ID0gXCJcIjtcbiAgICAgICAgICBzdGF0ZSA9IFwiZGVmYXVsdFwiO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LCAzMDApO1xuICB9IGVsc2Uge1xuICAgIGlmICh0YXJnZXQgJiYgZWxlbWVudE1hcC5oYXModGFyZ2V0KSkge1xuICAgICAgY29uc3QgcHJldlVzZXJTZWxlY3QgPSBlbGVtZW50TWFwLmdldCh0YXJnZXQpO1xuICAgICAgaWYgKHRhcmdldC5zdHlsZS51c2VyU2VsZWN0ID09PSBcIm5vbmVcIikge1xuICAgICAgICB0YXJnZXQuc3R5bGUudXNlclNlbGVjdCA9IHByZXZVc2VyU2VsZWN0ID8/IFwiXCI7XG4gICAgICB9XG4gICAgICBpZiAodGFyZ2V0LmdldEF0dHJpYnV0ZShcInN0eWxlXCIpID09PSBcIlwiKSB7XG4gICAgICAgIHRhcmdldC5yZW1vdmVBdHRyaWJ1dGUoXCJzdHlsZVwiKTtcbiAgICAgIH1cbiAgICAgIGVsZW1lbnRNYXAuZGVsZXRlKHRhcmdldCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBkaXNhYmxlVGV4dFNlbGVjdGlvbihvcHRpb25zID0ge30pIHtcbiAgY29uc3QgeyBkZWZlciwgdGFyZ2V0LCAuLi5yZXN0T3B0aW9ucyB9ID0gb3B0aW9ucztcbiAgY29uc3QgZnVuYyA9IGRlZmVyID8gcmFmIDogKHYpID0+IHYoKTtcbiAgY29uc3QgY2xlYW51cHMgPSBbXTtcbiAgY2xlYW51cHMucHVzaChcbiAgICBmdW5jKCgpID0+IHtcbiAgICAgIGNvbnN0IG5vZGUgPSB0eXBlb2YgdGFyZ2V0ID09PSBcImZ1bmN0aW9uXCIgPyB0YXJnZXQoKSA6IHRhcmdldDtcbiAgICAgIGNsZWFudXBzLnB1c2goZGlzYWJsZVRleHRTZWxlY3Rpb25JbXBsKHsgLi4ucmVzdE9wdGlvbnMsIHRhcmdldDogbm9kZSB9KSk7XG4gICAgfSlcbiAgKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBjbGVhbnVwcy5mb3JFYWNoKChmbikgPT4gZm4/LigpKTtcbiAgfTtcbn1cbmV4cG9ydCB7XG4gIGRpc2FibGVUZXh0U2VsZWN0aW9uLFxuICByZXN0b3JlVGV4dFNlbGVjdGlvblxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@zag-js/text-selection/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@zag-js/tooltip/dist/index.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/@zag-js/tooltip/dist/index.mjs ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   anatomy: () => (/* binding */ anatomy),\n/* harmony export */   connect: () => (/* binding */ connect),\n/* harmony export */   machine: () => (/* binding */ machine),\n/* harmony export */   props: () => (/* binding */ props),\n/* harmony export */   splitProps: () => (/* binding */ splitProps)\n/* harmony export */ });\n/* harmony import */ var _zag_js_anatomy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @zag-js/anatomy */ \"(ssr)/./node_modules/@zag-js/anatomy/dist/index.mjs\");\n/* harmony import */ var _zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @zag-js/dom-query */ \"(ssr)/./node_modules/@zag-js/dom-query/dist/index.mjs\");\n/* harmony import */ var _zag_js_popper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @zag-js/popper */ \"(ssr)/./node_modules/@zag-js/popper/dist/index.mjs\");\n/* harmony import */ var _zag_js_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @zag-js/core */ \"(ssr)/./node_modules/@zag-js/store/dist/index.mjs\");\n/* harmony import */ var _zag_js_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @zag-js/core */ \"(ssr)/./node_modules/@zag-js/core/dist/index.mjs\");\n/* harmony import */ var _zag_js_dom_event__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @zag-js/dom-event */ \"(ssr)/./node_modules/@zag-js/dom-event/dist/index.mjs\");\n/* harmony import */ var _zag_js_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @zag-js/utils */ \"(ssr)/./node_modules/@zag-js/utils/dist/index.mjs\");\n/* harmony import */ var _zag_js_types__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @zag-js/types */ \"(ssr)/./node_modules/@zag-js/types/dist/index.mjs\");\n// src/tooltip.anatomy.ts\n\nvar anatomy = (0,_zag_js_anatomy__WEBPACK_IMPORTED_MODULE_0__.createAnatomy)(\"tooltip\").parts(\"trigger\", \"arrow\", \"arrowTip\", \"positioner\", \"content\");\nvar parts = anatomy.build();\n\n// src/tooltip.connect.ts\n\n\n\n// src/tooltip.dom.ts\n\nvar dom = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.createScope)({\n  getTriggerId: (ctx) => ctx.ids?.trigger ?? `tooltip:${ctx.id}:trigger`,\n  getContentId: (ctx) => ctx.ids?.content ?? `tooltip:${ctx.id}:content`,\n  getArrowId: (ctx) => ctx.ids?.arrow ?? `tooltip:${ctx.id}:arrow`,\n  getPositionerId: (ctx) => ctx.ids?.positioner ?? `tooltip:${ctx.id}:popper`,\n  getTriggerEl: (ctx) => dom.getById(ctx, dom.getTriggerId(ctx)),\n  getContentEl: (ctx) => dom.getById(ctx, dom.getContentId(ctx)),\n  getPositionerEl: (ctx) => dom.getById(ctx, dom.getPositionerId(ctx)),\n  getArrowEl: (ctx) => dom.getById(ctx, dom.getArrowId(ctx))\n});\n\n// src/tooltip.store.ts\n\nvar store = (0,_zag_js_core__WEBPACK_IMPORTED_MODULE_2__.proxy)({\n  id: null,\n  prevId: null,\n  setId(val) {\n    this.prevId = this.id;\n    this.id = val;\n  }\n});\n\n// src/tooltip.connect.ts\nfunction connect(state, send, normalize) {\n  const id = state.context.id;\n  const hasAriaLabel = state.context.hasAriaLabel;\n  const open = state.hasTag(\"open\");\n  const triggerId = dom.getTriggerId(state.context);\n  const contentId = dom.getContentId(state.context);\n  const disabled = state.context.disabled;\n  const popperStyles = (0,_zag_js_popper__WEBPACK_IMPORTED_MODULE_3__.getPlacementStyles)({\n    ...state.context.positioning,\n    placement: state.context.currentPlacement\n  });\n  return {\n    open,\n    setOpen(nextOpen) {\n      if (nextOpen === open) return;\n      send(nextOpen ? \"OPEN\" : \"CLOSE\");\n    },\n    reposition(options = {}) {\n      send({ type: \"POSITIONING.SET\", options });\n    },\n    getTriggerProps() {\n      return normalize.button({\n        ...parts.trigger.attrs,\n        id: triggerId,\n        dir: state.context.dir,\n        \"data-expanded\": (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.dataAttr)(open),\n        \"data-state\": open ? \"open\" : \"closed\",\n        \"aria-describedby\": open ? contentId : void 0,\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          if (disabled) return;\n          if (!state.context.closeOnClick) return;\n          send({ type: \"CLOSE\", src: \"trigger.click\" });\n        },\n        onFocus(event) {\n          if (event.defaultPrevented) return;\n          if (disabled) return;\n          if (state.event.src === \"trigger.pointerdown\") return;\n          send({ type: \"OPEN\", src: \"trigger.focus\" });\n        },\n        onBlur(event) {\n          if (event.defaultPrevented) return;\n          if (disabled) return;\n          if (id === store.id) {\n            send({ type: \"CLOSE\", src: \"trigger.blur\" });\n          }\n        },\n        onPointerDown(event) {\n          if (event.defaultPrevented) return;\n          if (disabled) return;\n          if (!state.context.closeOnPointerDown) return;\n          if (id === store.id) {\n            send({ type: \"CLOSE\", src: \"trigger.pointerdown\" });\n          }\n        },\n        onPointerMove(event) {\n          if (event.defaultPrevented) return;\n          if (disabled) return;\n          if (event.pointerType === \"touch\") return;\n          send(\"POINTER_MOVE\");\n        },\n        onPointerLeave() {\n          if (disabled) return;\n          send(\"POINTER_LEAVE\");\n        },\n        onPointerCancel() {\n          if (disabled) return;\n          send(\"POINTER_LEAVE\");\n        }\n      });\n    },\n    getArrowProps() {\n      return normalize.element({\n        id: dom.getArrowId(state.context),\n        ...parts.arrow.attrs,\n        dir: state.context.dir,\n        style: popperStyles.arrow\n      });\n    },\n    getArrowTipProps() {\n      return normalize.element({\n        ...parts.arrowTip.attrs,\n        dir: state.context.dir,\n        style: popperStyles.arrowTip\n      });\n    },\n    getPositionerProps() {\n      return normalize.element({\n        id: dom.getPositionerId(state.context),\n        ...parts.positioner.attrs,\n        dir: state.context.dir,\n        style: popperStyles.floating\n      });\n    },\n    getContentProps() {\n      return normalize.element({\n        ...parts.content.attrs,\n        dir: state.context.dir,\n        hidden: !open,\n        \"data-state\": open ? \"open\" : \"closed\",\n        role: hasAriaLabel ? void 0 : \"tooltip\",\n        id: hasAriaLabel ? void 0 : contentId,\n        \"data-placement\": state.context.currentPlacement,\n        onPointerEnter() {\n          send(\"CONTENT.POINTER_MOVE\");\n        },\n        onPointerLeave() {\n          send(\"CONTENT.POINTER_LEAVE\");\n        },\n        style: {\n          pointerEvents: state.context.interactive ? \"auto\" : \"none\"\n        }\n      });\n    }\n  };\n}\n\n// src/tooltip.machine.ts\n\n\n\n\n\nvar { and, not } = _zag_js_core__WEBPACK_IMPORTED_MODULE_4__.guards;\nfunction machine(userContext) {\n  const ctx = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_5__.compact)(userContext);\n  return (0,_zag_js_core__WEBPACK_IMPORTED_MODULE_4__.createMachine)(\n    {\n      id: \"tooltip\",\n      initial: ctx.open ? \"open\" : \"closed\",\n      context: {\n        openDelay: 1e3,\n        closeDelay: 500,\n        closeOnPointerDown: true,\n        closeOnEscape: true,\n        interactive: false,\n        closeOnScroll: true,\n        closeOnClick: true,\n        ...ctx,\n        currentPlacement: void 0,\n        hasPointerMoveOpened: false,\n        positioning: {\n          placement: \"bottom\",\n          ...ctx.positioning\n        }\n      },\n      computed: {\n        hasAriaLabel: (ctx2) => !!ctx2[\"aria-label\"]\n      },\n      watch: {\n        disabled: [\"closeIfDisabled\"],\n        open: [\"toggleVisibility\"]\n      },\n      states: {\n        closed: {\n          tags: [\"closed\"],\n          entry: [\"clearGlobalId\"],\n          on: {\n            \"CONTROLLED.OPEN\": \"open\",\n            OPEN: {\n              target: \"open\",\n              actions: [\"invokeOnOpen\"]\n            },\n            POINTER_LEAVE: {\n              actions: [\"clearPointerMoveOpened\"]\n            },\n            POINTER_MOVE: [\n              {\n                guard: and(\"noVisibleTooltip\", not(\"hasPointerMoveOpened\")),\n                target: \"opening\"\n              },\n              {\n                guard: not(\"hasPointerMoveOpened\"),\n                target: \"open\",\n                actions: [\"setPointerMoveOpened\", \"invokeOnOpen\"]\n              }\n            ]\n          }\n        },\n        opening: {\n          tags: [\"closed\"],\n          activities: [\"trackScroll\", \"trackPointerlockChange\"],\n          after: {\n            OPEN_DELAY: [\n              {\n                guard: \"isOpenControlled\",\n                actions: [\"setPointerMoveOpened\", \"invokeOnOpen\"]\n              },\n              {\n                target: \"open\",\n                actions: [\"setPointerMoveOpened\", \"invokeOnOpen\"]\n              }\n            ]\n          },\n          on: {\n            \"CONTROLLED.OPEN\": \"open\",\n            \"CONTROLLED.CLOSE\": \"closed\",\n            OPEN: [\n              {\n                guard: \"isOpenControlled\",\n                actions: [\"invokeOnOpen\"]\n              },\n              {\n                target: \"open\",\n                actions: [\"invokeOnOpen\"]\n              }\n            ],\n            POINTER_LEAVE: [\n              {\n                guard: \"isOpenControlled\",\n                actions: [\"clearPointerMoveOpened\", \"invokeOnClose\"]\n              },\n              {\n                target: \"closed\",\n                actions: [\"clearPointerMoveOpened\", \"invokeOnClose\"]\n              }\n            ],\n            CLOSE: {\n              target: \"closed\",\n              actions: [\"invokeOnClose\"]\n            }\n          }\n        },\n        open: {\n          tags: [\"open\"],\n          activities: [\"trackEscapeKey\", \"trackScroll\", \"trackPointerlockChange\", \"trackPositioning\"],\n          entry: [\"setGlobalId\"],\n          on: {\n            \"CONTROLLED.CLOSE\": \"closed\",\n            CLOSE: {\n              target: \"closed\",\n              actions: [\"invokeOnClose\"]\n            },\n            POINTER_LEAVE: [\n              {\n                guard: \"isVisible\",\n                target: \"closing\",\n                actions: [\"clearPointerMoveOpened\"]\n              },\n              // == group ==\n              {\n                guard: \"isOpenControlled\",\n                actions: [\"clearPointerMoveOpened\", \"invokeOnClose\"]\n              },\n              {\n                target: \"closed\",\n                actions: [\"clearPointerMoveOpened\", \"invokeOnClose\"]\n              }\n            ],\n            \"CONTENT.POINTER_LEAVE\": {\n              guard: \"isInteractive\",\n              target: \"closing\"\n            },\n            \"POSITIONING.SET\": {\n              actions: \"reposition\"\n            }\n          }\n        },\n        closing: {\n          tags: [\"open\"],\n          activities: [\"trackStore\", \"trackPositioning\"],\n          after: {\n            CLOSE_DELAY: [\n              {\n                guard: \"isOpenControlled\",\n                actions: [\"invokeOnClose\"]\n              },\n              {\n                target: \"closed\",\n                actions: [\"invokeOnClose\"]\n              }\n            ]\n          },\n          on: {\n            \"CONTROLLED.CLOSE\": \"closed\",\n            \"CONTROLLED.OPEN\": \"open\",\n            CLOSE: [\n              {\n                guard: \"isOpenControlled\",\n                actions: [\"invokeOnClose\"]\n              },\n              {\n                target: \"closed\",\n                actions: [\"invokeOnClose\"]\n              }\n            ],\n            POINTER_MOVE: [\n              {\n                guard: \"isOpenControlled\",\n                actions: [\"setPointerMoveOpened\", \"invokeOnOpen\"]\n              },\n              {\n                target: \"open\",\n                actions: [\"setPointerMoveOpened\", \"invokeOnOpen\"]\n              }\n            ],\n            \"CONTENT.POINTER_MOVE\": {\n              guard: \"isInteractive\",\n              target: \"open\"\n            },\n            \"POSITIONING.SET\": {\n              actions: \"reposition\"\n            }\n          }\n        }\n      }\n    },\n    {\n      activities: {\n        trackPositioning(ctx2) {\n          ctx2.currentPlacement = ctx2.positioning.placement;\n          const getPositionerEl = () => dom.getPositionerEl(ctx2);\n          return (0,_zag_js_popper__WEBPACK_IMPORTED_MODULE_3__.getPlacement)(dom.getTriggerEl(ctx2), getPositionerEl, {\n            ...ctx2.positioning,\n            defer: true,\n            onComplete(data) {\n              ctx2.currentPlacement = data.placement;\n            }\n          });\n        },\n        trackPointerlockChange(ctx2, _evt, { send }) {\n          const onChange = () => send({ type: \"CLOSE\", src: \"pointerlock:change\" });\n          return (0,_zag_js_dom_event__WEBPACK_IMPORTED_MODULE_6__.addDomEvent)(dom.getDoc(ctx2), \"pointerlockchange\", onChange, false);\n        },\n        trackScroll(ctx2, _evt, { send }) {\n          if (!ctx2.closeOnScroll) return;\n          const triggerEl = dom.getTriggerEl(ctx2);\n          if (!triggerEl) return;\n          const overflowParents = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_1__.getOverflowAncestors)(triggerEl);\n          const cleanups = overflowParents.map((overflowParent) => {\n            const onScroll = () => {\n              send({ type: \"CLOSE\", src: \"scroll\" });\n            };\n            return (0,_zag_js_dom_event__WEBPACK_IMPORTED_MODULE_6__.addDomEvent)(overflowParent, \"scroll\", onScroll, { passive: true, capture: true });\n          });\n          return () => {\n            cleanups.forEach((fn) => fn?.());\n          };\n        },\n        trackStore(ctx2, _evt, { send }) {\n          return (0,_zag_js_core__WEBPACK_IMPORTED_MODULE_2__.subscribe)(store, () => {\n            if (store.id !== ctx2.id) {\n              send({ type: \"CLOSE\", src: \"id.change\" });\n            }\n          });\n        },\n        trackEscapeKey(ctx2, _evt, { send }) {\n          if (!ctx2.closeOnEscape) return;\n          const doc = dom.getDoc(ctx2);\n          return (0,_zag_js_dom_event__WEBPACK_IMPORTED_MODULE_6__.addDomEvent)(doc, \"keydown\", (event) => {\n            if (event.key === \"Escape\") {\n              send({ type: \"CLOSE\", src: \"keydown.escape\" });\n            }\n          });\n        }\n      },\n      actions: {\n        setGlobalId(ctx2) {\n          store.setId(ctx2.id);\n        },\n        clearGlobalId(ctx2) {\n          if (ctx2.id === store.id) {\n            store.setId(null);\n          }\n        },\n        invokeOnOpen(ctx2) {\n          ctx2.onOpenChange?.({ open: true });\n        },\n        invokeOnClose(ctx2) {\n          ctx2.onOpenChange?.({ open: false });\n        },\n        closeIfDisabled(ctx2, _evt, { send }) {\n          if (!ctx2.disabled) return;\n          send({ type: \"CLOSE\", src: \"disabled:change\" });\n        },\n        reposition(ctx2, evt) {\n          const getPositionerEl = () => dom.getPositionerEl(ctx2);\n          (0,_zag_js_popper__WEBPACK_IMPORTED_MODULE_3__.getPlacement)(dom.getTriggerEl(ctx2), getPositionerEl, {\n            ...ctx2.positioning,\n            ...evt.options,\n            defer: true,\n            listeners: false,\n            onComplete(data) {\n              ctx2.currentPlacement = data.placement;\n            }\n          });\n        },\n        toggleVisibility(ctx2, evt, { send }) {\n          send({ type: ctx2.open ? \"CONTROLLED.OPEN\" : \"CONTROLLED.CLOSE\", previousEvent: evt });\n        },\n        setPointerMoveOpened(ctx2) {\n          ctx2.hasPointerMoveOpened = true;\n        },\n        clearPointerMoveOpened(ctx2) {\n          ctx2.hasPointerMoveOpened = false;\n        }\n      },\n      guards: {\n        noVisibleTooltip: () => store.id === null,\n        isVisible: (ctx2) => ctx2.id === store.id,\n        isInteractive: (ctx2) => ctx2.interactive,\n        hasPointerMoveOpened: (ctx2) => !!ctx2.hasPointerMoveOpened,\n        isOpenControlled: (ctx2) => !!ctx2[\"open.controlled\"]\n      },\n      delays: {\n        OPEN_DELAY: (ctx2) => ctx2.openDelay,\n        CLOSE_DELAY: (ctx2) => ctx2.closeDelay\n      }\n    }\n  );\n}\n\n// src/tooltip.props.ts\n\n\nvar props = (0,_zag_js_types__WEBPACK_IMPORTED_MODULE_7__.createProps)()([\n  \"aria-label\",\n  \"closeDelay\",\n  \"closeOnEscape\",\n  \"closeOnPointerDown\",\n  \"closeOnScroll\",\n  \"closeOnClick\",\n  \"dir\",\n  \"disabled\",\n  \"getRootNode\",\n  \"id\",\n  \"ids\",\n  \"interactive\",\n  \"onOpenChange\",\n  \"open.controlled\",\n  \"open\",\n  \"openDelay\",\n  \"positioning\"\n]);\nvar splitProps = (0,_zag_js_utils__WEBPACK_IMPORTED_MODULE_5__.createSplitProps)(props);\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHphZy1qcy90b29sdGlwL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNnRDtBQUNoRCxjQUFjLDhEQUFhO0FBQzNCOztBQUVBO0FBQzZDO0FBQ087O0FBRXBEO0FBQ2dEO0FBQ2hELFVBQVUsOERBQVc7QUFDckIsd0RBQXdELE9BQU87QUFDL0Qsd0RBQXdELE9BQU87QUFDL0Qsb0RBQW9ELE9BQU87QUFDM0QsOERBQThELE9BQU87QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ3FDO0FBQ3JDLFlBQVksbURBQUs7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGtFQUFrQjtBQUN6QztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsMkJBQTJCO0FBQzNCLGFBQWEsa0NBQWtDO0FBQy9DLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDJEQUFRO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixxQ0FBcUM7QUFDdEQsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG9DQUFvQztBQUNyRCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsb0NBQW9DO0FBQ3ZEO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMkNBQTJDO0FBQzlEO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFD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QkFBaUIsOERBQVc7QUFDNUI7QUFDQSxxQkFBcUIsc0NBQXNDO0FBQzNEO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGdDQUFnQyxZQUFZO0FBQzVDLFNBQVM7QUFDVDtBQUNBLGdDQUFnQyxhQUFhO0FBQzdDLFNBQVM7QUFDVCxzQ0FBc0MsTUFBTTtBQUM1QztBQUNBLGlCQUFpQix1Q0FBdUM7QUFDeEQsU0FBUztBQUNUO0FBQ0E7QUFDQSxVQUFVLDREQUFZO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCxzQ0FBc0MsTUFBTTtBQUM1QyxpQkFBaUIsOEVBQThFO0FBQy9GLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDNEM7QUFDSztBQUNqRCxZQUFZLDBEQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwrREFBZ0I7QUFPL0I7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3NpdGVzLy4vbm9kZV9tb2R1bGVzL0B6YWctanMvdG9vbHRpcC9kaXN0L2luZGV4Lm1qcz9jYmJmIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy90b29sdGlwLmFuYXRvbXkudHNcbmltcG9ydCB7IGNyZWF0ZUFuYXRvbXkgfSBmcm9tIFwiQHphZy1qcy9hbmF0b215XCI7XG52YXIgYW5hdG9teSA9IGNyZWF0ZUFuYXRvbXkoXCJ0b29sdGlwXCIpLnBhcnRzKFwidHJpZ2dlclwiLCBcImFycm93XCIsIFwiYXJyb3dUaXBcIiwgXCJwb3NpdGlvbmVyXCIsIFwiY29udGVudFwiKTtcbnZhciBwYXJ0cyA9IGFuYXRvbXkuYnVpbGQoKTtcblxuLy8gc3JjL3Rvb2x0aXAuY29ubmVjdC50c1xuaW1wb3J0IHsgZGF0YUF0dHIgfSBmcm9tIFwiQHphZy1qcy9kb20tcXVlcnlcIjtcbmltcG9ydCB7IGdldFBsYWNlbWVudFN0eWxlcyB9IGZyb20gXCJAemFnLWpzL3BvcHBlclwiO1xuXG4vLyBzcmMvdG9vbHRpcC5kb20udHNcbmltcG9ydCB7IGNyZWF0ZVNjb3BlIH0gZnJvbSBcIkB6YWctanMvZG9tLXF1ZXJ5XCI7XG52YXIgZG9tID0gY3JlYXRlU2NvcGUoe1xuICBnZXRUcmlnZ2VySWQ6IChjdHgpID0+IGN0eC5pZHM/LnRyaWdnZXIgPz8gYHRvb2x0aXA6JHtjdHguaWR9OnRyaWdnZXJgLFxuICBnZXRDb250ZW50SWQ6IChjdHgpID0+IGN0eC5pZHM/LmNvbnRlbnQgPz8gYHRvb2x0aXA6JHtjdHguaWR9OmNvbnRlbnRgLFxuICBnZXRBcnJvd0lkOiAoY3R4KSA9PiBjdHguaWRzPy5hcnJvdyA/PyBgdG9vbHRpcDoke2N0eC5pZH06YXJyb3dgLFxuICBnZXRQb3NpdGlvbmVySWQ6IChjdHgpID0+IGN0eC5pZHM/LnBvc2l0aW9uZXIgPz8gYHRvb2x0aXA6JHtjdHguaWR9OnBvcHBlcmAsXG4gIGdldFRyaWdnZXJFbDogKGN0eCkgPT4gZG9tLmdldEJ5SWQoY3R4LCBkb20uZ2V0VHJpZ2dlcklkKGN0eCkpLFxuICBnZXRDb250ZW50RWw6IChjdHgpID0+IGRvbS5nZXRCeUlkKGN0eCwgZG9tLmdldENvbnRlbnRJZChjdHgpKSxcbiAgZ2V0UG9zaXRpb25lckVsOiAoY3R4KSA9PiBkb20uZ2V0QnlJZChjdHgsIGRvbS5nZXRQb3NpdGlvbmVySWQoY3R4KSksXG4gIGdldEFycm93RWw6IChjdHgpID0+IGRvbS5nZXRCeUlkKGN0eCwgZG9tLmdldEFycm93SWQoY3R4KSlcbn0pO1xuXG4vLyBzcmMvdG9vbHRpcC5zdG9yZS50c1xuaW1wb3J0IHsgcHJveHkgfSBmcm9tIFwiQHphZy1qcy9jb3JlXCI7XG52YXIgc3RvcmUgPSBwcm94eSh7XG4gIGlkOiBudWxsLFxuICBwcmV2SWQ6IG51bGwsXG4gIHNldElkKHZhbCkge1xuICAgIHRoaXMucHJldklkID0gdGhpcy5pZDtcbiAgICB0aGlzLmlkID0gdmFsO1xuICB9XG59KTtcblxuLy8gc3JjL3Rvb2x0aXAuY29ubmVjdC50c1xuZnVuY3Rpb24gY29ubmVjdChzdGF0ZSwgc2VuZCwgbm9ybWFsaXplKSB7XG4gIGNvbnN0IGlkID0gc3RhdGUuY29udGV4dC5pZDtcbiAgY29uc3QgaGFzQXJpYUxhYmVsID0gc3RhdGUuY29udGV4dC5oYXNBcmlhTGFiZWw7XG4gIGNvbnN0IG9wZW4gPSBzdGF0ZS5oYXNUYWcoXCJvcGVuXCIpO1xuICBjb25zdCB0cmlnZ2VySWQgPSBkb20uZ2V0VHJpZ2dlcklkKHN0YXRlLmNvbnRleHQpO1xuICBjb25zdCBjb250ZW50SWQgPSBkb20uZ2V0Q29udGVudElkKHN0YXRlLmNvbnRleHQpO1xuICBjb25zdCBkaXNhYmxlZCA9IHN0YXRlLmNvbnRleHQuZGlzYWJsZWQ7XG4gIGNvbnN0IHBvcHBlclN0eWxlcyA9IGdldFBsYWNlbWVudFN0eWxlcyh7XG4gICAgLi4uc3RhdGUuY29udGV4dC5wb3NpdGlvbmluZyxcbiAgICBwbGFjZW1lbnQ6IHN0YXRlLmNvbnRleHQuY3VycmVudFBsYWNlbWVudFxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBvcGVuLFxuICAgIHNldE9wZW4obmV4dE9wZW4pIHtcbiAgICAgIGlmIChuZXh0T3BlbiA9PT0gb3BlbikgcmV0dXJuO1xuICAgICAgc2VuZChuZXh0T3BlbiA/IFwiT1BFTlwiIDogXCJDTE9TRVwiKTtcbiAgICB9LFxuICAgIHJlcG9zaXRpb24ob3B0aW9ucyA9IHt9KSB7XG4gICAgICBzZW5kKHsgdHlwZTogXCJQT1NJVElPTklORy5TRVRcIiwgb3B0aW9ucyB9KTtcbiAgICB9LFxuICAgIGdldFRyaWdnZXJQcm9wcygpIHtcbiAgICAgIHJldHVybiBub3JtYWxpemUuYnV0dG9uKHtcbiAgICAgICAgLi4ucGFydHMudHJpZ2dlci5hdHRycyxcbiAgICAgICAgaWQ6IHRyaWdnZXJJZCxcbiAgICAgICAgZGlyOiBzdGF0ZS5jb250ZXh0LmRpcixcbiAgICAgICAgXCJkYXRhLWV4cGFuZGVkXCI6IGRhdGFBdHRyKG9wZW4pLFxuICAgICAgICBcImRhdGEtc3RhdGVcIjogb3BlbiA/IFwib3BlblwiIDogXCJjbG9zZWRcIixcbiAgICAgICAgXCJhcmlhLWRlc2NyaWJlZGJ5XCI6IG9wZW4gPyBjb250ZW50SWQgOiB2b2lkIDAsXG4gICAgICAgIG9uQ2xpY2soZXZlbnQpIHtcbiAgICAgICAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkgcmV0dXJuO1xuICAgICAgICAgIGlmIChkaXNhYmxlZCkgcmV0dXJuO1xuICAgICAgICAgIGlmICghc3RhdGUuY29udGV4dC5jbG9zZU9uQ2xpY2spIHJldHVybjtcbiAgICAgICAgICBzZW5kKHsgdHlwZTogXCJDTE9TRVwiLCBzcmM6IFwidHJpZ2dlci5jbGlja1wiIH0pO1xuICAgICAgICB9LFxuICAgICAgICBvbkZvY3VzKGV2ZW50KSB7XG4gICAgICAgICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHJldHVybjtcbiAgICAgICAgICBpZiAoZGlzYWJsZWQpIHJldHVybjtcbiAgICAgICAgICBpZiAoc3RhdGUuZXZlbnQuc3JjID09PSBcInRyaWdnZXIucG9pbnRlcmRvd25cIikgcmV0dXJuO1xuICAgICAgICAgIHNlbmQoeyB0eXBlOiBcIk9QRU5cIiwgc3JjOiBcInRyaWdnZXIuZm9jdXNcIiB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25CbHVyKGV2ZW50KSB7XG4gICAgICAgICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHJldHVybjtcbiAgICAgICAgICBpZiAoZGlzYWJsZWQpIHJldHVybjtcbiAgICAgICAgICBpZiAoaWQgPT09IHN0b3JlLmlkKSB7XG4gICAgICAgICAgICBzZW5kKHsgdHlwZTogXCJDTE9TRVwiLCBzcmM6IFwidHJpZ2dlci5ibHVyXCIgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvblBvaW50ZXJEb3duKGV2ZW50KSB7XG4gICAgICAgICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHJldHVybjtcbiAgICAgICAgICBpZiAoZGlzYWJsZWQpIHJldHVybjtcbiAgICAgICAgICBpZiAoIXN0YXRlLmNvbnRleHQuY2xvc2VPblBvaW50ZXJEb3duKSByZXR1cm47XG4gICAgICAgICAgaWYgKGlkID09PSBzdG9yZS5pZCkge1xuICAgICAgICAgICAgc2VuZCh7IHR5cGU6IFwiQ0xPU0VcIiwgc3JjOiBcInRyaWdnZXIucG9pbnRlcmRvd25cIiB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9uUG9pbnRlck1vdmUoZXZlbnQpIHtcbiAgICAgICAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkgcmV0dXJuO1xuICAgICAgICAgIGlmIChkaXNhYmxlZCkgcmV0dXJuO1xuICAgICAgICAgIGlmIChldmVudC5wb2ludGVyVHlwZSA9PT0gXCJ0b3VjaFwiKSByZXR1cm47XG4gICAgICAgICAgc2VuZChcIlBPSU5URVJfTU9WRVwiKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25Qb2ludGVyTGVhdmUoKSB7XG4gICAgICAgICAgaWYgKGRpc2FibGVkKSByZXR1cm47XG4gICAgICAgICAgc2VuZChcIlBPSU5URVJfTEVBVkVcIik7XG4gICAgICAgIH0sXG4gICAgICAgIG9uUG9pbnRlckNhbmNlbCgpIHtcbiAgICAgICAgICBpZiAoZGlzYWJsZWQpIHJldHVybjtcbiAgICAgICAgICBzZW5kKFwiUE9JTlRFUl9MRUFWRVwiKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBnZXRBcnJvd1Byb3BzKCkge1xuICAgICAgcmV0dXJuIG5vcm1hbGl6ZS5lbGVtZW50KHtcbiAgICAgICAgaWQ6IGRvbS5nZXRBcnJvd0lkKHN0YXRlLmNvbnRleHQpLFxuICAgICAgICAuLi5wYXJ0cy5hcnJvdy5hdHRycyxcbiAgICAgICAgZGlyOiBzdGF0ZS5jb250ZXh0LmRpcixcbiAgICAgICAgc3R5bGU6IHBvcHBlclN0eWxlcy5hcnJvd1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBnZXRBcnJvd1RpcFByb3BzKCkge1xuICAgICAgcmV0dXJuIG5vcm1hbGl6ZS5lbGVtZW50KHtcbiAgICAgICAgLi4ucGFydHMuYXJyb3dUaXAuYXR0cnMsXG4gICAgICAgIGRpcjogc3RhdGUuY29udGV4dC5kaXIsXG4gICAgICAgIHN0eWxlOiBwb3BwZXJTdHlsZXMuYXJyb3dUaXBcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZ2V0UG9zaXRpb25lclByb3BzKCkge1xuICAgICAgcmV0dXJuIG5vcm1hbGl6ZS5lbGVtZW50KHtcbiAgICAgICAgaWQ6IGRvbS5nZXRQb3NpdGlvbmVySWQoc3RhdGUuY29udGV4dCksXG4gICAgICAgIC4uLnBhcnRzLnBvc2l0aW9uZXIuYXR0cnMsXG4gICAgICAgIGRpcjogc3RhdGUuY29udGV4dC5kaXIsXG4gICAgICAgIHN0eWxlOiBwb3BwZXJTdHlsZXMuZmxvYXRpbmdcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZ2V0Q29udGVudFByb3BzKCkge1xuICAgICAgcmV0dXJuIG5vcm1hbGl6ZS5lbGVtZW50KHtcbiAgICAgICAgLi4ucGFydHMuY29udGVudC5hdHRycyxcbiAgICAgICAgZGlyOiBzdGF0ZS5jb250ZXh0LmRpcixcbiAgICAgICAgaGlkZGVuOiAhb3BlbixcbiAgICAgICAgXCJkYXRhLXN0YXRlXCI6IG9wZW4gPyBcIm9wZW5cIiA6IFwiY2xvc2VkXCIsXG4gICAgICAgIHJvbGU6IGhhc0FyaWFMYWJlbCA/IHZvaWQgMCA6IFwidG9vbHRpcFwiLFxuICAgICAgICBpZDogaGFzQXJpYUxhYmVsID8gdm9pZCAwIDogY29udGVudElkLFxuICAgICAgICBcImRhdGEtcGxhY2VtZW50XCI6IHN0YXRlLmNvbnRleHQuY3VycmVudFBsYWNlbWVudCxcbiAgICAgICAgb25Qb2ludGVyRW50ZXIoKSB7XG4gICAgICAgICAgc2VuZChcIkNPTlRFTlQuUE9JTlRFUl9NT1ZFXCIpO1xuICAgICAgICB9LFxuICAgICAgICBvblBvaW50ZXJMZWF2ZSgpIHtcbiAgICAgICAgICBzZW5kKFwiQ09OVEVOVC5QT0lOVEVSX0xFQVZFXCIpO1xuICAgICAgICB9LFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIHBvaW50ZXJFdmVudHM6IHN0YXRlLmNvbnRleHQuaW50ZXJhY3RpdmUgPyBcImF1dG9cIiA6IFwibm9uZVwiXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3Rvb2x0aXAubWFjaGluZS50c1xuaW1wb3J0IHsgY3JlYXRlTWFjaGluZSwgZ3VhcmRzLCBzdWJzY3JpYmUgfSBmcm9tIFwiQHphZy1qcy9jb3JlXCI7XG5pbXBvcnQgeyBhZGREb21FdmVudCB9IGZyb20gXCJAemFnLWpzL2RvbS1ldmVudFwiO1xuaW1wb3J0IHsgZ2V0T3ZlcmZsb3dBbmNlc3RvcnMgfSBmcm9tIFwiQHphZy1qcy9kb20tcXVlcnlcIjtcbmltcG9ydCB7IGdldFBsYWNlbWVudCB9IGZyb20gXCJAemFnLWpzL3BvcHBlclwiO1xuaW1wb3J0IHsgY29tcGFjdCB9IGZyb20gXCJAemFnLWpzL3V0aWxzXCI7XG52YXIgeyBhbmQsIG5vdCB9ID0gZ3VhcmRzO1xuZnVuY3Rpb24gbWFjaGluZSh1c2VyQ29udGV4dCkge1xuICBjb25zdCBjdHggPSBjb21wYWN0KHVzZXJDb250ZXh0KTtcbiAgcmV0dXJuIGNyZWF0ZU1hY2hpbmUoXG4gICAge1xuICAgICAgaWQ6IFwidG9vbHRpcFwiLFxuICAgICAgaW5pdGlhbDogY3R4Lm9wZW4gPyBcIm9wZW5cIiA6IFwiY2xvc2VkXCIsXG4gICAgICBjb250ZXh0OiB7XG4gICAgICAgIG9wZW5EZWxheTogMWUzLFxuICAgICAgICBjbG9zZURlbGF5OiA1MDAsXG4gICAgICAgIGNsb3NlT25Qb2ludGVyRG93bjogdHJ1ZSxcbiAgICAgICAgY2xvc2VPbkVzY2FwZTogdHJ1ZSxcbiAgICAgICAgaW50ZXJhY3RpdmU6IGZhbHNlLFxuICAgICAgICBjbG9zZU9uU2Nyb2xsOiB0cnVlLFxuICAgICAgICBjbG9zZU9uQ2xpY2s6IHRydWUsXG4gICAgICAgIC4uLmN0eCxcbiAgICAgICAgY3VycmVudFBsYWNlbWVudDogdm9pZCAwLFxuICAgICAgICBoYXNQb2ludGVyTW92ZU9wZW5lZDogZmFsc2UsXG4gICAgICAgIHBvc2l0aW9uaW5nOiB7XG4gICAgICAgICAgcGxhY2VtZW50OiBcImJvdHRvbVwiLFxuICAgICAgICAgIC4uLmN0eC5wb3NpdGlvbmluZ1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgaGFzQXJpYUxhYmVsOiAoY3R4MikgPT4gISFjdHgyW1wiYXJpYS1sYWJlbFwiXVxuICAgICAgfSxcbiAgICAgIHdhdGNoOiB7XG4gICAgICAgIGRpc2FibGVkOiBbXCJjbG9zZUlmRGlzYWJsZWRcIl0sXG4gICAgICAgIG9wZW46IFtcInRvZ2dsZVZpc2liaWxpdHlcIl1cbiAgICAgIH0sXG4gICAgICBzdGF0ZXM6IHtcbiAgICAgICAgY2xvc2VkOiB7XG4gICAgICAgICAgdGFnczogW1wiY2xvc2VkXCJdLFxuICAgICAgICAgIGVudHJ5OiBbXCJjbGVhckdsb2JhbElkXCJdLFxuICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICBcIkNPTlRST0xMRUQuT1BFTlwiOiBcIm9wZW5cIixcbiAgICAgICAgICAgIE9QRU46IHtcbiAgICAgICAgICAgICAgdGFyZ2V0OiBcIm9wZW5cIixcbiAgICAgICAgICAgICAgYWN0aW9uczogW1wiaW52b2tlT25PcGVuXCJdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgUE9JTlRFUl9MRUFWRToge1xuICAgICAgICAgICAgICBhY3Rpb25zOiBbXCJjbGVhclBvaW50ZXJNb3ZlT3BlbmVkXCJdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgUE9JTlRFUl9NT1ZFOiBbXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBndWFyZDogYW5kKFwibm9WaXNpYmxlVG9vbHRpcFwiLCBub3QoXCJoYXNQb2ludGVyTW92ZU9wZW5lZFwiKSksXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBcIm9wZW5pbmdcIlxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZ3VhcmQ6IG5vdChcImhhc1BvaW50ZXJNb3ZlT3BlbmVkXCIpLFxuICAgICAgICAgICAgICAgIHRhcmdldDogXCJvcGVuXCIsXG4gICAgICAgICAgICAgICAgYWN0aW9uczogW1wic2V0UG9pbnRlck1vdmVPcGVuZWRcIiwgXCJpbnZva2VPbk9wZW5cIl1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb3BlbmluZzoge1xuICAgICAgICAgIHRhZ3M6IFtcImNsb3NlZFwiXSxcbiAgICAgICAgICBhY3Rpdml0aWVzOiBbXCJ0cmFja1Njcm9sbFwiLCBcInRyYWNrUG9pbnRlcmxvY2tDaGFuZ2VcIl0sXG4gICAgICAgICAgYWZ0ZXI6IHtcbiAgICAgICAgICAgIE9QRU5fREVMQVk6IFtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGd1YXJkOiBcImlzT3BlbkNvbnRyb2xsZWRcIixcbiAgICAgICAgICAgICAgICBhY3Rpb25zOiBbXCJzZXRQb2ludGVyTW92ZU9wZW5lZFwiLCBcImludm9rZU9uT3BlblwiXVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBcIm9wZW5cIixcbiAgICAgICAgICAgICAgICBhY3Rpb25zOiBbXCJzZXRQb2ludGVyTW92ZU9wZW5lZFwiLCBcImludm9rZU9uT3BlblwiXVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgXCJDT05UUk9MTEVELk9QRU5cIjogXCJvcGVuXCIsXG4gICAgICAgICAgICBcIkNPTlRST0xMRUQuQ0xPU0VcIjogXCJjbG9zZWRcIixcbiAgICAgICAgICAgIE9QRU46IFtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGd1YXJkOiBcImlzT3BlbkNvbnRyb2xsZWRcIixcbiAgICAgICAgICAgICAgICBhY3Rpb25zOiBbXCJpbnZva2VPbk9wZW5cIl1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRhcmdldDogXCJvcGVuXCIsXG4gICAgICAgICAgICAgICAgYWN0aW9uczogW1wiaW52b2tlT25PcGVuXCJdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBQT0lOVEVSX0xFQVZFOiBbXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBndWFyZDogXCJpc09wZW5Db250cm9sbGVkXCIsXG4gICAgICAgICAgICAgICAgYWN0aW9uczogW1wiY2xlYXJQb2ludGVyTW92ZU9wZW5lZFwiLCBcImludm9rZU9uQ2xvc2VcIl1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRhcmdldDogXCJjbG9zZWRcIixcbiAgICAgICAgICAgICAgICBhY3Rpb25zOiBbXCJjbGVhclBvaW50ZXJNb3ZlT3BlbmVkXCIsIFwiaW52b2tlT25DbG9zZVwiXVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgQ0xPU0U6IHtcbiAgICAgICAgICAgICAgdGFyZ2V0OiBcImNsb3NlZFwiLFxuICAgICAgICAgICAgICBhY3Rpb25zOiBbXCJpbnZva2VPbkNsb3NlXCJdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvcGVuOiB7XG4gICAgICAgICAgdGFnczogW1wib3BlblwiXSxcbiAgICAgICAgICBhY3Rpdml0aWVzOiBbXCJ0cmFja0VzY2FwZUtleVwiLCBcInRyYWNrU2Nyb2xsXCIsIFwidHJhY2tQb2ludGVybG9ja0NoYW5nZVwiLCBcInRyYWNrUG9zaXRpb25pbmdcIl0sXG4gICAgICAgICAgZW50cnk6IFtcInNldEdsb2JhbElkXCJdLFxuICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICBcIkNPTlRST0xMRUQuQ0xPU0VcIjogXCJjbG9zZWRcIixcbiAgICAgICAgICAgIENMT1NFOiB7XG4gICAgICAgICAgICAgIHRhcmdldDogXCJjbG9zZWRcIixcbiAgICAgICAgICAgICAgYWN0aW9uczogW1wiaW52b2tlT25DbG9zZVwiXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFBPSU5URVJfTEVBVkU6IFtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGd1YXJkOiBcImlzVmlzaWJsZVwiLFxuICAgICAgICAgICAgICAgIHRhcmdldDogXCJjbG9zaW5nXCIsXG4gICAgICAgICAgICAgICAgYWN0aW9uczogW1wiY2xlYXJQb2ludGVyTW92ZU9wZW5lZFwiXVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAvLyA9PSBncm91cCA9PVxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZ3VhcmQ6IFwiaXNPcGVuQ29udHJvbGxlZFwiLFxuICAgICAgICAgICAgICAgIGFjdGlvbnM6IFtcImNsZWFyUG9pbnRlck1vdmVPcGVuZWRcIiwgXCJpbnZva2VPbkNsb3NlXCJdXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IFwiY2xvc2VkXCIsXG4gICAgICAgICAgICAgICAgYWN0aW9uczogW1wiY2xlYXJQb2ludGVyTW92ZU9wZW5lZFwiLCBcImludm9rZU9uQ2xvc2VcIl1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiQ09OVEVOVC5QT0lOVEVSX0xFQVZFXCI6IHtcbiAgICAgICAgICAgICAgZ3VhcmQ6IFwiaXNJbnRlcmFjdGl2ZVwiLFxuICAgICAgICAgICAgICB0YXJnZXQ6IFwiY2xvc2luZ1wiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJQT1NJVElPTklORy5TRVRcIjoge1xuICAgICAgICAgICAgICBhY3Rpb25zOiBcInJlcG9zaXRpb25cIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY2xvc2luZzoge1xuICAgICAgICAgIHRhZ3M6IFtcIm9wZW5cIl0sXG4gICAgICAgICAgYWN0aXZpdGllczogW1widHJhY2tTdG9yZVwiLCBcInRyYWNrUG9zaXRpb25pbmdcIl0sXG4gICAgICAgICAgYWZ0ZXI6IHtcbiAgICAgICAgICAgIENMT1NFX0RFTEFZOiBbXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBndWFyZDogXCJpc09wZW5Db250cm9sbGVkXCIsXG4gICAgICAgICAgICAgICAgYWN0aW9uczogW1wiaW52b2tlT25DbG9zZVwiXVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBcImNsb3NlZFwiLFxuICAgICAgICAgICAgICAgIGFjdGlvbnM6IFtcImludm9rZU9uQ2xvc2VcIl1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgb246IHtcbiAgICAgICAgICAgIFwiQ09OVFJPTExFRC5DTE9TRVwiOiBcImNsb3NlZFwiLFxuICAgICAgICAgICAgXCJDT05UUk9MTEVELk9QRU5cIjogXCJvcGVuXCIsXG4gICAgICAgICAgICBDTE9TRTogW1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZ3VhcmQ6IFwiaXNPcGVuQ29udHJvbGxlZFwiLFxuICAgICAgICAgICAgICAgIGFjdGlvbnM6IFtcImludm9rZU9uQ2xvc2VcIl1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRhcmdldDogXCJjbG9zZWRcIixcbiAgICAgICAgICAgICAgICBhY3Rpb25zOiBbXCJpbnZva2VPbkNsb3NlXCJdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBQT0lOVEVSX01PVkU6IFtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGd1YXJkOiBcImlzT3BlbkNvbnRyb2xsZWRcIixcbiAgICAgICAgICAgICAgICBhY3Rpb25zOiBbXCJzZXRQb2ludGVyTW92ZU9wZW5lZFwiLCBcImludm9rZU9uT3BlblwiXVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBcIm9wZW5cIixcbiAgICAgICAgICAgICAgICBhY3Rpb25zOiBbXCJzZXRQb2ludGVyTW92ZU9wZW5lZFwiLCBcImludm9rZU9uT3BlblwiXVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJDT05URU5ULlBPSU5URVJfTU9WRVwiOiB7XG4gICAgICAgICAgICAgIGd1YXJkOiBcImlzSW50ZXJhY3RpdmVcIixcbiAgICAgICAgICAgICAgdGFyZ2V0OiBcIm9wZW5cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiUE9TSVRJT05JTkcuU0VUXCI6IHtcbiAgICAgICAgICAgICAgYWN0aW9uczogXCJyZXBvc2l0aW9uXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIGFjdGl2aXRpZXM6IHtcbiAgICAgICAgdHJhY2tQb3NpdGlvbmluZyhjdHgyKSB7XG4gICAgICAgICAgY3R4Mi5jdXJyZW50UGxhY2VtZW50ID0gY3R4Mi5wb3NpdGlvbmluZy5wbGFjZW1lbnQ7XG4gICAgICAgICAgY29uc3QgZ2V0UG9zaXRpb25lckVsID0gKCkgPT4gZG9tLmdldFBvc2l0aW9uZXJFbChjdHgyKTtcbiAgICAgICAgICByZXR1cm4gZ2V0UGxhY2VtZW50KGRvbS5nZXRUcmlnZ2VyRWwoY3R4MiksIGdldFBvc2l0aW9uZXJFbCwge1xuICAgICAgICAgICAgLi4uY3R4Mi5wb3NpdGlvbmluZyxcbiAgICAgICAgICAgIGRlZmVyOiB0cnVlLFxuICAgICAgICAgICAgb25Db21wbGV0ZShkYXRhKSB7XG4gICAgICAgICAgICAgIGN0eDIuY3VycmVudFBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICB0cmFja1BvaW50ZXJsb2NrQ2hhbmdlKGN0eDIsIF9ldnQsIHsgc2VuZCB9KSB7XG4gICAgICAgICAgY29uc3Qgb25DaGFuZ2UgPSAoKSA9PiBzZW5kKHsgdHlwZTogXCJDTE9TRVwiLCBzcmM6IFwicG9pbnRlcmxvY2s6Y2hhbmdlXCIgfSk7XG4gICAgICAgICAgcmV0dXJuIGFkZERvbUV2ZW50KGRvbS5nZXREb2MoY3R4MiksIFwicG9pbnRlcmxvY2tjaGFuZ2VcIiwgb25DaGFuZ2UsIGZhbHNlKTtcbiAgICAgICAgfSxcbiAgICAgICAgdHJhY2tTY3JvbGwoY3R4MiwgX2V2dCwgeyBzZW5kIH0pIHtcbiAgICAgICAgICBpZiAoIWN0eDIuY2xvc2VPblNjcm9sbCkgcmV0dXJuO1xuICAgICAgICAgIGNvbnN0IHRyaWdnZXJFbCA9IGRvbS5nZXRUcmlnZ2VyRWwoY3R4Mik7XG4gICAgICAgICAgaWYgKCF0cmlnZ2VyRWwpIHJldHVybjtcbiAgICAgICAgICBjb25zdCBvdmVyZmxvd1BhcmVudHMgPSBnZXRPdmVyZmxvd0FuY2VzdG9ycyh0cmlnZ2VyRWwpO1xuICAgICAgICAgIGNvbnN0IGNsZWFudXBzID0gb3ZlcmZsb3dQYXJlbnRzLm1hcCgob3ZlcmZsb3dQYXJlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG9uU2Nyb2xsID0gKCkgPT4ge1xuICAgICAgICAgICAgICBzZW5kKHsgdHlwZTogXCJDTE9TRVwiLCBzcmM6IFwic2Nyb2xsXCIgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGFkZERvbUV2ZW50KG92ZXJmbG93UGFyZW50LCBcInNjcm9sbFwiLCBvblNjcm9sbCwgeyBwYXNzaXZlOiB0cnVlLCBjYXB0dXJlOiB0cnVlIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBjbGVhbnVwcy5mb3JFYWNoKChmbikgPT4gZm4/LigpKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICB0cmFja1N0b3JlKGN0eDIsIF9ldnQsIHsgc2VuZCB9KSB7XG4gICAgICAgICAgcmV0dXJuIHN1YnNjcmliZShzdG9yZSwgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHN0b3JlLmlkICE9PSBjdHgyLmlkKSB7XG4gICAgICAgICAgICAgIHNlbmQoeyB0eXBlOiBcIkNMT1NFXCIsIHNyYzogXCJpZC5jaGFuZ2VcIiB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgdHJhY2tFc2NhcGVLZXkoY3R4MiwgX2V2dCwgeyBzZW5kIH0pIHtcbiAgICAgICAgICBpZiAoIWN0eDIuY2xvc2VPbkVzY2FwZSkgcmV0dXJuO1xuICAgICAgICAgIGNvbnN0IGRvYyA9IGRvbS5nZXREb2MoY3R4Mik7XG4gICAgICAgICAgcmV0dXJuIGFkZERvbUV2ZW50KGRvYywgXCJrZXlkb3duXCIsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gXCJFc2NhcGVcIikge1xuICAgICAgICAgICAgICBzZW5kKHsgdHlwZTogXCJDTE9TRVwiLCBzcmM6IFwia2V5ZG93bi5lc2NhcGVcIiB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGFjdGlvbnM6IHtcbiAgICAgICAgc2V0R2xvYmFsSWQoY3R4Mikge1xuICAgICAgICAgIHN0b3JlLnNldElkKGN0eDIuaWQpO1xuICAgICAgICB9LFxuICAgICAgICBjbGVhckdsb2JhbElkKGN0eDIpIHtcbiAgICAgICAgICBpZiAoY3R4Mi5pZCA9PT0gc3RvcmUuaWQpIHtcbiAgICAgICAgICAgIHN0b3JlLnNldElkKG51bGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgaW52b2tlT25PcGVuKGN0eDIpIHtcbiAgICAgICAgICBjdHgyLm9uT3BlbkNoYW5nZT8uKHsgb3BlbjogdHJ1ZSB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgaW52b2tlT25DbG9zZShjdHgyKSB7XG4gICAgICAgICAgY3R4Mi5vbk9wZW5DaGFuZ2U/Lih7IG9wZW46IGZhbHNlIH0pO1xuICAgICAgICB9LFxuICAgICAgICBjbG9zZUlmRGlzYWJsZWQoY3R4MiwgX2V2dCwgeyBzZW5kIH0pIHtcbiAgICAgICAgICBpZiAoIWN0eDIuZGlzYWJsZWQpIHJldHVybjtcbiAgICAgICAgICBzZW5kKHsgdHlwZTogXCJDTE9TRVwiLCBzcmM6IFwiZGlzYWJsZWQ6Y2hhbmdlXCIgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlcG9zaXRpb24oY3R4MiwgZXZ0KSB7XG4gICAgICAgICAgY29uc3QgZ2V0UG9zaXRpb25lckVsID0gKCkgPT4gZG9tLmdldFBvc2l0aW9uZXJFbChjdHgyKTtcbiAgICAgICAgICBnZXRQbGFjZW1lbnQoZG9tLmdldFRyaWdnZXJFbChjdHgyKSwgZ2V0UG9zaXRpb25lckVsLCB7XG4gICAgICAgICAgICAuLi5jdHgyLnBvc2l0aW9uaW5nLFxuICAgICAgICAgICAgLi4uZXZ0Lm9wdGlvbnMsXG4gICAgICAgICAgICBkZWZlcjogdHJ1ZSxcbiAgICAgICAgICAgIGxpc3RlbmVyczogZmFsc2UsXG4gICAgICAgICAgICBvbkNvbXBsZXRlKGRhdGEpIHtcbiAgICAgICAgICAgICAgY3R4Mi5jdXJyZW50UGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHRvZ2dsZVZpc2liaWxpdHkoY3R4MiwgZXZ0LCB7IHNlbmQgfSkge1xuICAgICAgICAgIHNlbmQoeyB0eXBlOiBjdHgyLm9wZW4gPyBcIkNPTlRST0xMRUQuT1BFTlwiIDogXCJDT05UUk9MTEVELkNMT1NFXCIsIHByZXZpb3VzRXZlbnQ6IGV2dCB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0UG9pbnRlck1vdmVPcGVuZWQoY3R4Mikge1xuICAgICAgICAgIGN0eDIuaGFzUG9pbnRlck1vdmVPcGVuZWQgPSB0cnVlO1xuICAgICAgICB9LFxuICAgICAgICBjbGVhclBvaW50ZXJNb3ZlT3BlbmVkKGN0eDIpIHtcbiAgICAgICAgICBjdHgyLmhhc1BvaW50ZXJNb3ZlT3BlbmVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBndWFyZHM6IHtcbiAgICAgICAgbm9WaXNpYmxlVG9vbHRpcDogKCkgPT4gc3RvcmUuaWQgPT09IG51bGwsXG4gICAgICAgIGlzVmlzaWJsZTogKGN0eDIpID0+IGN0eDIuaWQgPT09IHN0b3JlLmlkLFxuICAgICAgICBpc0ludGVyYWN0aXZlOiAoY3R4MikgPT4gY3R4Mi5pbnRlcmFjdGl2ZSxcbiAgICAgICAgaGFzUG9pbnRlck1vdmVPcGVuZWQ6IChjdHgyKSA9PiAhIWN0eDIuaGFzUG9pbnRlck1vdmVPcGVuZWQsXG4gICAgICAgIGlzT3BlbkNvbnRyb2xsZWQ6IChjdHgyKSA9PiAhIWN0eDJbXCJvcGVuLmNvbnRyb2xsZWRcIl1cbiAgICAgIH0sXG4gICAgICBkZWxheXM6IHtcbiAgICAgICAgT1BFTl9ERUxBWTogKGN0eDIpID0+IGN0eDIub3BlbkRlbGF5LFxuICAgICAgICBDTE9TRV9ERUxBWTogKGN0eDIpID0+IGN0eDIuY2xvc2VEZWxheVxuICAgICAgfVxuICAgIH1cbiAgKTtcbn1cblxuLy8gc3JjL3Rvb2x0aXAucHJvcHMudHNcbmltcG9ydCB7IGNyZWF0ZVByb3BzIH0gZnJvbSBcIkB6YWctanMvdHlwZXNcIjtcbmltcG9ydCB7IGNyZWF0ZVNwbGl0UHJvcHMgfSBmcm9tIFwiQHphZy1qcy91dGlsc1wiO1xudmFyIHByb3BzID0gY3JlYXRlUHJvcHMoKShbXG4gIFwiYXJpYS1sYWJlbFwiLFxuICBcImNsb3NlRGVsYXlcIixcbiAgXCJjbG9zZU9uRXNjYXBlXCIsXG4gIFwiY2xvc2VPblBvaW50ZXJEb3duXCIsXG4gIFwiY2xvc2VPblNjcm9sbFwiLFxuICBcImNsb3NlT25DbGlja1wiLFxuICBcImRpclwiLFxuICBcImRpc2FibGVkXCIsXG4gIFwiZ2V0Um9vdE5vZGVcIixcbiAgXCJpZFwiLFxuICBcImlkc1wiLFxuICBcImludGVyYWN0aXZlXCIsXG4gIFwib25PcGVuQ2hhbmdlXCIsXG4gIFwib3Blbi5jb250cm9sbGVkXCIsXG4gIFwib3BlblwiLFxuICBcIm9wZW5EZWxheVwiLFxuICBcInBvc2l0aW9uaW5nXCJcbl0pO1xudmFyIHNwbGl0UHJvcHMgPSBjcmVhdGVTcGxpdFByb3BzKHByb3BzKTtcbmV4cG9ydCB7XG4gIGFuYXRvbXksXG4gIGNvbm5lY3QsXG4gIG1hY2hpbmUsXG4gIHByb3BzLFxuICBzcGxpdFByb3BzXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@zag-js/tooltip/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@zag-js/types/dist/index.mjs":
/*!***************************************************!*\
  !*** ./node_modules/@zag-js/types/dist/index.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createNormalizer: () => (/* binding */ createNormalizer),\n/* harmony export */   createProps: () => (/* binding */ createProps)\n/* harmony export */ });\n// src/prop-types.ts\nfunction createNormalizer(fn) {\n  return new Proxy({}, {\n    get() {\n      return fn;\n    }\n  });\n}\n\n// src/create-props.ts\nvar createProps = () => (props) => Array.from(new Set(props));\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHphZy1qcy90eXBlcy9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFJRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2l0ZXMvLi9ub2RlX21vZHVsZXMvQHphZy1qcy90eXBlcy9kaXN0L2luZGV4Lm1qcz80ODk2Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9wcm9wLXR5cGVzLnRzXG5mdW5jdGlvbiBjcmVhdGVOb3JtYWxpemVyKGZuKSB7XG4gIHJldHVybiBuZXcgUHJveHkoe30sIHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gZm47XG4gICAgfVxuICB9KTtcbn1cblxuLy8gc3JjL2NyZWF0ZS1wcm9wcy50c1xudmFyIGNyZWF0ZVByb3BzID0gKCkgPT4gKHByb3BzKSA9PiBBcnJheS5mcm9tKG5ldyBTZXQocHJvcHMpKTtcbmV4cG9ydCB7XG4gIGNyZWF0ZU5vcm1hbGl6ZXIsXG4gIGNyZWF0ZVByb3BzXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@zag-js/types/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@zag-js/utils/dist/index.mjs":
/*!***************************************************!*\
  !*** ./node_modules/@zag-js/utils/dist/index.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   add: () => (/* binding */ add),\n/* harmony export */   addOrRemove: () => (/* binding */ addOrRemove),\n/* harmony export */   callAll: () => (/* binding */ callAll),\n/* harmony export */   cast: () => (/* binding */ cast),\n/* harmony export */   chunk: () => (/* binding */ chunk),\n/* harmony export */   clear: () => (/* binding */ clear),\n/* harmony export */   compact: () => (/* binding */ compact),\n/* harmony export */   createSplitProps: () => (/* binding */ createSplitProps),\n/* harmony export */   first: () => (/* binding */ first),\n/* harmony export */   fromLength: () => (/* binding */ fromLength),\n/* harmony export */   has: () => (/* binding */ has),\n/* harmony export */   hasProp: () => (/* binding */ hasProp),\n/* harmony export */   invariant: () => (/* binding */ invariant),\n/* harmony export */   isArray: () => (/* binding */ isArray),\n/* harmony export */   isBoolean: () => (/* binding */ isBoolean),\n/* harmony export */   isDev: () => (/* binding */ isDev),\n/* harmony export */   isEmpty: () => (/* binding */ isEmpty),\n/* harmony export */   isEqual: () => (/* binding */ isEqual),\n/* harmony export */   isFunction: () => (/* binding */ isFunction),\n/* harmony export */   isNull: () => (/* binding */ isNull),\n/* harmony export */   isNumber: () => (/* binding */ isNumber),\n/* harmony export */   isObject: () => (/* binding */ isObject),\n/* harmony export */   isString: () => (/* binding */ isString),\n/* harmony export */   json: () => (/* binding */ json),\n/* harmony export */   last: () => (/* binding */ last),\n/* harmony export */   match: () => (/* binding */ match),\n/* harmony export */   next: () => (/* binding */ next),\n/* harmony export */   nextIndex: () => (/* binding */ nextIndex),\n/* harmony export */   noop: () => (/* binding */ noop),\n/* harmony export */   omit: () => (/* binding */ omit),\n/* harmony export */   pick: () => (/* binding */ pick),\n/* harmony export */   prev: () => (/* binding */ prev),\n/* harmony export */   prevIndex: () => (/* binding */ prevIndex),\n/* harmony export */   remove: () => (/* binding */ remove),\n/* harmony export */   removeAt: () => (/* binding */ removeAt),\n/* harmony export */   runIfFn: () => (/* binding */ runIfFn),\n/* harmony export */   splitProps: () => (/* binding */ splitProps),\n/* harmony export */   toArray: () => (/* binding */ toArray),\n/* harmony export */   tryCatch: () => (/* binding */ tryCatch),\n/* harmony export */   uniq: () => (/* binding */ uniq),\n/* harmony export */   uuid: () => (/* binding */ uuid),\n/* harmony export */   warn: () => (/* binding */ warn)\n/* harmony export */ });\n// src/array.ts\nfunction toArray(v) {\n  if (!v) return [];\n  return Array.isArray(v) ? v : [v];\n}\nvar fromLength = (length) => Array.from(Array(length).keys());\nvar first = (v) => v[0];\nvar last = (v) => v[v.length - 1];\nvar isEmpty = (v) => v.length === 0;\nvar has = (v, t) => v.indexOf(t) !== -1;\nvar add = (v, ...items) => v.concat(items);\nvar remove = (v, item) => v.filter((t) => t !== item);\nvar removeAt = (v, i) => v.filter((_, idx) => idx !== i);\nvar uniq = (v) => Array.from(new Set(v));\nvar addOrRemove = (v, item) => {\n  if (has(v, item)) return remove(v, item);\n  return add(v, item);\n};\nfunction clear(v) {\n  while (v.length > 0) v.pop();\n  return v;\n}\nfunction nextIndex(v, idx, opts = {}) {\n  const { step = 1, loop = true } = opts;\n  const next2 = idx + step;\n  const len = v.length;\n  const last2 = len - 1;\n  if (idx === -1) return step > 0 ? 0 : last2;\n  if (next2 < 0) return loop ? last2 : 0;\n  if (next2 >= len) return loop ? 0 : idx > len ? len : idx;\n  return next2;\n}\nfunction next(v, idx, opts = {}) {\n  return v[nextIndex(v, idx, opts)];\n}\nfunction prevIndex(v, idx, opts = {}) {\n  const { step = 1, loop = true } = opts;\n  return nextIndex(v, idx, { step: -step, loop });\n}\nfunction prev(v, index, opts = {}) {\n  return v[prevIndex(v, index, opts)];\n}\nvar chunk = (v, size) => {\n  const res = [];\n  return v.reduce((rows, value, index) => {\n    if (index % size === 0) rows.push([value]);\n    else last(rows)?.push(value);\n    return rows;\n  }, res);\n};\n\n// src/equal.ts\nvar isArrayLike = (value) => value?.constructor.name === \"Array\";\nvar isArrayEqual = (a, b) => {\n  if (a.length !== b.length) return false;\n  for (let i = 0; i < a.length; i++) {\n    if (!isEqual(a[i], b[i])) return false;\n  }\n  return true;\n};\nvar isEqual = (a, b) => {\n  if (Object.is(a, b)) return true;\n  if (a == null && b != null || a != null && b == null) return false;\n  if (typeof a?.isEqual === \"function\" && typeof b?.isEqual === \"function\") {\n    return a.isEqual(b);\n  }\n  if (typeof a === \"function\" && typeof b === \"function\") {\n    return a.toString() === b.toString();\n  }\n  if (isArrayLike(a) && isArrayLike(b)) {\n    return isArrayEqual(Array.from(a), Array.from(b));\n  }\n  if (!(typeof a === \"object\") || !(typeof b === \"object\")) return false;\n  const keys = Object.keys(b ?? /* @__PURE__ */ Object.create(null));\n  const length = keys.length;\n  for (let i = 0; i < length; i++) {\n    const hasKey = Reflect.has(a, keys[i]);\n    if (!hasKey) return false;\n  }\n  for (let i = 0; i < length; i++) {\n    const key = keys[i];\n    if (!isEqual(a[key], b[key])) return false;\n  }\n  return true;\n};\n\n// src/functions.ts\nvar runIfFn = (v, ...a) => {\n  const res = typeof v === \"function\" ? v(...a) : v;\n  return res ?? void 0;\n};\nvar cast = (v) => v;\nvar noop = () => {\n};\nvar callAll = (...fns) => (...a) => {\n  fns.forEach(function(fn) {\n    fn?.(...a);\n  });\n};\nvar uuid = /* @__PURE__ */ (() => {\n  let id = 0;\n  return () => {\n    id++;\n    return id.toString(36);\n  };\n})();\nfunction match(key, record, ...args) {\n  if (key in record) {\n    const fn = record[key];\n    return typeof fn === \"function\" ? fn(...args) : fn;\n  }\n  const error = new Error(`No matching key: ${JSON.stringify(key)} in ${JSON.stringify(Object.keys(record))}`);\n  Error.captureStackTrace?.(error, match);\n  throw error;\n}\nvar tryCatch = (fn, fallback) => {\n  try {\n    return fn();\n  } catch (error) {\n    if (error instanceof Error) {\n      Error.captureStackTrace?.(error, tryCatch);\n    }\n    return fallback?.();\n  }\n};\n\n// src/guard.ts\nvar isDev = () => \"development\" !== \"production\";\nvar isArray = (v) => Array.isArray(v);\nvar isBoolean = (v) => v === true || v === false;\nvar isObject = (v) => !(v == null || typeof v !== \"object\" || isArray(v));\nvar isNumber = (v) => typeof v === \"number\" && !Number.isNaN(v);\nvar isString = (v) => typeof v === \"string\";\nvar isFunction = (v) => typeof v === \"function\";\nvar isNull = (v) => v == null;\nvar hasProp = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\n\n// src/split-props.ts\nfunction splitProps(props, keys) {\n  const rest = {};\n  const result = {};\n  const keySet = new Set(keys);\n  for (const key in props) {\n    if (keySet.has(key)) {\n      result[key] = props[key];\n    } else {\n      rest[key] = props[key];\n    }\n  }\n  return [result, rest];\n}\nvar createSplitProps = (keys) => {\n  return function split(props) {\n    return splitProps(props, keys);\n  };\n};\n\n// src/object.ts\nfunction compact(obj) {\n  if (!isPlainObject(obj) || obj === void 0) {\n    return obj;\n  }\n  const keys = Reflect.ownKeys(obj).filter((key) => typeof key === \"string\");\n  const filtered = {};\n  for (const key of keys) {\n    const value = obj[key];\n    if (value !== void 0) {\n      filtered[key] = compact(value);\n    }\n  }\n  return filtered;\n}\nfunction json(value) {\n  return JSON.parse(JSON.stringify(value));\n}\nvar isPlainObject = (value) => {\n  return value && typeof value === \"object\" && value.constructor === Object;\n};\nfunction pick(obj, keys) {\n  const filtered = {};\n  for (const key of keys) {\n    const value = obj[key];\n    if (value !== void 0) {\n      filtered[key] = value;\n    }\n  }\n  return filtered;\n}\nfunction omit(obj, keys) {\n  return createSplitProps(keys)(obj)[1];\n}\n\n// src/warning.ts\nfunction warn(...a) {\n  const m = a.length === 1 ? a[0] : a[1];\n  const c = a.length === 2 ? a[0] : true;\n  if (c && \"development\" !== \"production\") {\n    console.warn(m);\n  }\n}\nfunction invariant(...a) {\n  const m = a.length === 1 ? a[0] : a[1];\n  const c = a.length === 2 ? a[0] : true;\n  if (c && \"development\" !== \"production\") {\n    throw new Error(m);\n  }\n}\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHphZy1qcy91dGlscy9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyxVQUFVLHdCQUF3QjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEMsVUFBVSx3QkFBd0I7QUFDbEMsNkJBQTZCLG1CQUFtQjtBQUNoRDtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxxQkFBcUIsS0FBSyxvQ0FBb0M7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixhQUFvQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQW9CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBb0I7QUFDL0I7QUFDQTtBQUNBO0FBNENFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zaXRlcy8uL25vZGVfbW9kdWxlcy9AemFnLWpzL3V0aWxzL2Rpc3QvaW5kZXgubWpzP2I2ZGQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2FycmF5LnRzXG5mdW5jdGlvbiB0b0FycmF5KHYpIHtcbiAgaWYgKCF2KSByZXR1cm4gW107XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHYpID8gdiA6IFt2XTtcbn1cbnZhciBmcm9tTGVuZ3RoID0gKGxlbmd0aCkgPT4gQXJyYXkuZnJvbShBcnJheShsZW5ndGgpLmtleXMoKSk7XG52YXIgZmlyc3QgPSAodikgPT4gdlswXTtcbnZhciBsYXN0ID0gKHYpID0+IHZbdi5sZW5ndGggLSAxXTtcbnZhciBpc0VtcHR5ID0gKHYpID0+IHYubGVuZ3RoID09PSAwO1xudmFyIGhhcyA9ICh2LCB0KSA9PiB2LmluZGV4T2YodCkgIT09IC0xO1xudmFyIGFkZCA9ICh2LCAuLi5pdGVtcykgPT4gdi5jb25jYXQoaXRlbXMpO1xudmFyIHJlbW92ZSA9ICh2LCBpdGVtKSA9PiB2LmZpbHRlcigodCkgPT4gdCAhPT0gaXRlbSk7XG52YXIgcmVtb3ZlQXQgPSAodiwgaSkgPT4gdi5maWx0ZXIoKF8sIGlkeCkgPT4gaWR4ICE9PSBpKTtcbnZhciB1bmlxID0gKHYpID0+IEFycmF5LmZyb20obmV3IFNldCh2KSk7XG52YXIgYWRkT3JSZW1vdmUgPSAodiwgaXRlbSkgPT4ge1xuICBpZiAoaGFzKHYsIGl0ZW0pKSByZXR1cm4gcmVtb3ZlKHYsIGl0ZW0pO1xuICByZXR1cm4gYWRkKHYsIGl0ZW0pO1xufTtcbmZ1bmN0aW9uIGNsZWFyKHYpIHtcbiAgd2hpbGUgKHYubGVuZ3RoID4gMCkgdi5wb3AoKTtcbiAgcmV0dXJuIHY7XG59XG5mdW5jdGlvbiBuZXh0SW5kZXgodiwgaWR4LCBvcHRzID0ge30pIHtcbiAgY29uc3QgeyBzdGVwID0gMSwgbG9vcCA9IHRydWUgfSA9IG9wdHM7XG4gIGNvbnN0IG5leHQyID0gaWR4ICsgc3RlcDtcbiAgY29uc3QgbGVuID0gdi5sZW5ndGg7XG4gIGNvbnN0IGxhc3QyID0gbGVuIC0gMTtcbiAgaWYgKGlkeCA9PT0gLTEpIHJldHVybiBzdGVwID4gMCA/IDAgOiBsYXN0MjtcbiAgaWYgKG5leHQyIDwgMCkgcmV0dXJuIGxvb3AgPyBsYXN0MiA6IDA7XG4gIGlmIChuZXh0MiA+PSBsZW4pIHJldHVybiBsb29wID8gMCA6IGlkeCA+IGxlbiA/IGxlbiA6IGlkeDtcbiAgcmV0dXJuIG5leHQyO1xufVxuZnVuY3Rpb24gbmV4dCh2LCBpZHgsIG9wdHMgPSB7fSkge1xuICByZXR1cm4gdltuZXh0SW5kZXgodiwgaWR4LCBvcHRzKV07XG59XG5mdW5jdGlvbiBwcmV2SW5kZXgodiwgaWR4LCBvcHRzID0ge30pIHtcbiAgY29uc3QgeyBzdGVwID0gMSwgbG9vcCA9IHRydWUgfSA9IG9wdHM7XG4gIHJldHVybiBuZXh0SW5kZXgodiwgaWR4LCB7IHN0ZXA6IC1zdGVwLCBsb29wIH0pO1xufVxuZnVuY3Rpb24gcHJldih2LCBpbmRleCwgb3B0cyA9IHt9KSB7XG4gIHJldHVybiB2W3ByZXZJbmRleCh2LCBpbmRleCwgb3B0cyldO1xufVxudmFyIGNodW5rID0gKHYsIHNpemUpID0+IHtcbiAgY29uc3QgcmVzID0gW107XG4gIHJldHVybiB2LnJlZHVjZSgocm93cywgdmFsdWUsIGluZGV4KSA9PiB7XG4gICAgaWYgKGluZGV4ICUgc2l6ZSA9PT0gMCkgcm93cy5wdXNoKFt2YWx1ZV0pO1xuICAgIGVsc2UgbGFzdChyb3dzKT8ucHVzaCh2YWx1ZSk7XG4gICAgcmV0dXJuIHJvd3M7XG4gIH0sIHJlcyk7XG59O1xuXG4vLyBzcmMvZXF1YWwudHNcbnZhciBpc0FycmF5TGlrZSA9ICh2YWx1ZSkgPT4gdmFsdWU/LmNvbnN0cnVjdG9yLm5hbWUgPT09IFwiQXJyYXlcIjtcbnZhciBpc0FycmF5RXF1YWwgPSAoYSwgYikgPT4ge1xuICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgIGlmICghaXNFcXVhbChhW2ldLCBiW2ldKSkgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcbnZhciBpc0VxdWFsID0gKGEsIGIpID0+IHtcbiAgaWYgKE9iamVjdC5pcyhhLCBiKSkgcmV0dXJuIHRydWU7XG4gIGlmIChhID09IG51bGwgJiYgYiAhPSBudWxsIHx8IGEgIT0gbnVsbCAmJiBiID09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiBhPy5pc0VxdWFsID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIGI/LmlzRXF1YWwgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiBhLmlzRXF1YWwoYik7XG4gIH1cbiAgaWYgKHR5cGVvZiBhID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIGIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiBhLnRvU3RyaW5nKCkgPT09IGIudG9TdHJpbmcoKTtcbiAgfVxuICBpZiAoaXNBcnJheUxpa2UoYSkgJiYgaXNBcnJheUxpa2UoYikpIHtcbiAgICByZXR1cm4gaXNBcnJheUVxdWFsKEFycmF5LmZyb20oYSksIEFycmF5LmZyb20oYikpO1xuICB9XG4gIGlmICghKHR5cGVvZiBhID09PSBcIm9iamVjdFwiKSB8fCAhKHR5cGVvZiBiID09PSBcIm9iamVjdFwiKSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoYiA/PyAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gIGNvbnN0IGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgaGFzS2V5ID0gUmVmbGVjdC5oYXMoYSwga2V5c1tpXSk7XG4gICAgaWYgKCFoYXNLZXkpIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICBpZiAoIWlzRXF1YWwoYVtrZXldLCBiW2tleV0pKSByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vLyBzcmMvZnVuY3Rpb25zLnRzXG52YXIgcnVuSWZGbiA9ICh2LCAuLi5hKSA9PiB7XG4gIGNvbnN0IHJlcyA9IHR5cGVvZiB2ID09PSBcImZ1bmN0aW9uXCIgPyB2KC4uLmEpIDogdjtcbiAgcmV0dXJuIHJlcyA/PyB2b2lkIDA7XG59O1xudmFyIGNhc3QgPSAodikgPT4gdjtcbnZhciBub29wID0gKCkgPT4ge1xufTtcbnZhciBjYWxsQWxsID0gKC4uLmZucykgPT4gKC4uLmEpID0+IHtcbiAgZm5zLmZvckVhY2goZnVuY3Rpb24oZm4pIHtcbiAgICBmbj8uKC4uLmEpO1xuICB9KTtcbn07XG52YXIgdXVpZCA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4ge1xuICBsZXQgaWQgPSAwO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGlkKys7XG4gICAgcmV0dXJuIGlkLnRvU3RyaW5nKDM2KTtcbiAgfTtcbn0pKCk7XG5mdW5jdGlvbiBtYXRjaChrZXksIHJlY29yZCwgLi4uYXJncykge1xuICBpZiAoa2V5IGluIHJlY29yZCkge1xuICAgIGNvbnN0IGZuID0gcmVjb3JkW2tleV07XG4gICAgcmV0dXJuIHR5cGVvZiBmbiA9PT0gXCJmdW5jdGlvblwiID8gZm4oLi4uYXJncykgOiBmbjtcbiAgfVxuICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgTm8gbWF0Y2hpbmcga2V5OiAke0pTT04uc3RyaW5naWZ5KGtleSl9IGluICR7SlNPTi5zdHJpbmdpZnkoT2JqZWN0LmtleXMocmVjb3JkKSl9YCk7XG4gIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlPy4oZXJyb3IsIG1hdGNoKTtcbiAgdGhyb3cgZXJyb3I7XG59XG52YXIgdHJ5Q2F0Y2ggPSAoZm4sIGZhbGxiYWNrKSA9PiB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGZuKCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlPy4oZXJyb3IsIHRyeUNhdGNoKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbGxiYWNrPy4oKTtcbiAgfVxufTtcblxuLy8gc3JjL2d1YXJkLnRzXG52YXIgaXNEZXYgPSAoKSA9PiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCI7XG52YXIgaXNBcnJheSA9ICh2KSA9PiBBcnJheS5pc0FycmF5KHYpO1xudmFyIGlzQm9vbGVhbiA9ICh2KSA9PiB2ID09PSB0cnVlIHx8IHYgPT09IGZhbHNlO1xudmFyIGlzT2JqZWN0ID0gKHYpID0+ICEodiA9PSBudWxsIHx8IHR5cGVvZiB2ICE9PSBcIm9iamVjdFwiIHx8IGlzQXJyYXkodikpO1xudmFyIGlzTnVtYmVyID0gKHYpID0+IHR5cGVvZiB2ID09PSBcIm51bWJlclwiICYmICFOdW1iZXIuaXNOYU4odik7XG52YXIgaXNTdHJpbmcgPSAodikgPT4gdHlwZW9mIHYgPT09IFwic3RyaW5nXCI7XG52YXIgaXNGdW5jdGlvbiA9ICh2KSA9PiB0eXBlb2YgdiA9PT0gXCJmdW5jdGlvblwiO1xudmFyIGlzTnVsbCA9ICh2KSA9PiB2ID09IG51bGw7XG52YXIgaGFzUHJvcCA9IChvYmosIHByb3ApID0+IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xuXG4vLyBzcmMvc3BsaXQtcHJvcHMudHNcbmZ1bmN0aW9uIHNwbGl0UHJvcHMocHJvcHMsIGtleXMpIHtcbiAgY29uc3QgcmVzdCA9IHt9O1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgY29uc3Qga2V5U2V0ID0gbmV3IFNldChrZXlzKTtcbiAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHMpIHtcbiAgICBpZiAoa2V5U2V0LmhhcyhrZXkpKSB7XG4gICAgICByZXN1bHRba2V5XSA9IHByb3BzW2tleV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3Rba2V5XSA9IHByb3BzW2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiBbcmVzdWx0LCByZXN0XTtcbn1cbnZhciBjcmVhdGVTcGxpdFByb3BzID0gKGtleXMpID0+IHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHNwbGl0KHByb3BzKSB7XG4gICAgcmV0dXJuIHNwbGl0UHJvcHMocHJvcHMsIGtleXMpO1xuICB9O1xufTtcblxuLy8gc3JjL29iamVjdC50c1xuZnVuY3Rpb24gY29tcGFjdChvYmopIHtcbiAgaWYgKCFpc1BsYWluT2JqZWN0KG9iaikgfHwgb2JqID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG4gIGNvbnN0IGtleXMgPSBSZWZsZWN0Lm93bktleXMob2JqKS5maWx0ZXIoKGtleSkgPT4gdHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIik7XG4gIGNvbnN0IGZpbHRlcmVkID0ge307XG4gIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICBjb25zdCB2YWx1ZSA9IG9ialtrZXldO1xuICAgIGlmICh2YWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICBmaWx0ZXJlZFtrZXldID0gY29tcGFjdCh2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBmaWx0ZXJlZDtcbn1cbmZ1bmN0aW9uIGpzb24odmFsdWUpIHtcbiAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcbn1cbnZhciBpc1BsYWluT2JqZWN0ID0gKHZhbHVlKSA9PiB7XG4gIHJldHVybiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUuY29uc3RydWN0b3IgPT09IE9iamVjdDtcbn07XG5mdW5jdGlvbiBwaWNrKG9iaiwga2V5cykge1xuICBjb25zdCBmaWx0ZXJlZCA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgY29uc3QgdmFsdWUgPSBvYmpba2V5XTtcbiAgICBpZiAodmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgZmlsdGVyZWRba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmlsdGVyZWQ7XG59XG5mdW5jdGlvbiBvbWl0KG9iaiwga2V5cykge1xuICByZXR1cm4gY3JlYXRlU3BsaXRQcm9wcyhrZXlzKShvYmopWzFdO1xufVxuXG4vLyBzcmMvd2FybmluZy50c1xuZnVuY3Rpb24gd2FybiguLi5hKSB7XG4gIGNvbnN0IG0gPSBhLmxlbmd0aCA9PT0gMSA/IGFbMF0gOiBhWzFdO1xuICBjb25zdCBjID0gYS5sZW5ndGggPT09IDIgPyBhWzBdIDogdHJ1ZTtcbiAgaWYgKGMgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgY29uc29sZS53YXJuKG0pO1xuICB9XG59XG5mdW5jdGlvbiBpbnZhcmlhbnQoLi4uYSkge1xuICBjb25zdCBtID0gYS5sZW5ndGggPT09IDEgPyBhWzBdIDogYVsxXTtcbiAgY29uc3QgYyA9IGEubGVuZ3RoID09PSAyID8gYVswXSA6IHRydWU7XG4gIGlmIChjICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIHRocm93IG5ldyBFcnJvcihtKTtcbiAgfVxufVxuZXhwb3J0IHtcbiAgYWRkLFxuICBhZGRPclJlbW92ZSxcbiAgY2FsbEFsbCxcbiAgY2FzdCxcbiAgY2h1bmssXG4gIGNsZWFyLFxuICBjb21wYWN0LFxuICBjcmVhdGVTcGxpdFByb3BzLFxuICBmaXJzdCxcbiAgZnJvbUxlbmd0aCxcbiAgaGFzLFxuICBoYXNQcm9wLFxuICBpbnZhcmlhbnQsXG4gIGlzQXJyYXksXG4gIGlzQm9vbGVhbixcbiAgaXNEZXYsXG4gIGlzRW1wdHksXG4gIGlzRXF1YWwsXG4gIGlzRnVuY3Rpb24sXG4gIGlzTnVsbCxcbiAgaXNOdW1iZXIsXG4gIGlzT2JqZWN0LFxuICBpc1N0cmluZyxcbiAganNvbixcbiAgbGFzdCxcbiAgbWF0Y2gsXG4gIG5leHQsXG4gIG5leHRJbmRleCxcbiAgbm9vcCxcbiAgb21pdCxcbiAgcGljayxcbiAgcHJldixcbiAgcHJldkluZGV4LFxuICByZW1vdmUsXG4gIHJlbW92ZUF0LFxuICBydW5JZkZuLFxuICBzcGxpdFByb3BzLFxuICB0b0FycmF5LFxuICB0cnlDYXRjaCxcbiAgdW5pcSxcbiAgdXVpZCxcbiAgd2FyblxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@zag-js/utils/dist/index.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@zag-js/core/dist/index.mjs":
/*!**************************************************!*\
  !*** ./node_modules/@zag-js/core/dist/index.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Machine: () => (/* binding */ Machine),\n/* harmony export */   choose: () => (/* binding */ choose),\n/* harmony export */   createMachine: () => (/* binding */ createMachine),\n/* harmony export */   deepMerge: () => (/* binding */ deepMerge),\n/* harmony export */   guards: () => (/* binding */ guards),\n/* harmony export */   isMachine: () => (/* binding */ isMachine),\n/* harmony export */   mergeProps: () => (/* binding */ mergeProps),\n/* harmony export */   proxy: () => (/* reexport safe */ _zag_js_store__WEBPACK_IMPORTED_MODULE_1__.proxy),\n/* harmony export */   ref: () => (/* reexport safe */ _zag_js_store__WEBPACK_IMPORTED_MODULE_1__.ref),\n/* harmony export */   snapshot: () => (/* reexport safe */ _zag_js_store__WEBPACK_IMPORTED_MODULE_1__.snapshot),\n/* harmony export */   subscribe: () => (/* reexport safe */ _zag_js_store__WEBPACK_IMPORTED_MODULE_1__.subscribe)\n/* harmony export */ });\n/* harmony import */ var _zag_js_store__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @zag-js/store */ \"(rsc)/./node_modules/@zag-js/store/dist/index.mjs\");\n/* harmony import */ var klona_full__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! klona/full */ \"(rsc)/./node_modules/klona/full/index.mjs\");\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n\n// src/index.ts\n\n\n// ../utilities/core/src/array.ts\nfunction clear(v) {\n  while (v.length > 0) v.pop();\n  return v;\n}\n\n// ../utilities/core/src/functions.ts\nvar runIfFn = (v, ...a) => {\n  const res = typeof v === \"function\" ? v(...a) : v;\n  return res ?? void 0;\n};\nvar cast = (v) => v;\nvar noop = () => {\n};\nvar callAll = (...fns) => (...a) => {\n  fns.forEach(function(fn) {\n    fn?.(...a);\n  });\n};\nvar uuid = /* @__PURE__ */ (() => {\n  let id = 0;\n  return () => {\n    id++;\n    return id.toString(36);\n  };\n})();\n\n// ../utilities/core/src/guard.ts\nvar isDev = () => \"development\" !== \"production\";\nvar isArray = (v) => Array.isArray(v);\nvar isObject = (v) => !(v == null || typeof v !== \"object\" || isArray(v));\nvar isNumber = (v) => typeof v === \"number\" && !Number.isNaN(v);\nvar isString = (v) => typeof v === \"string\";\nvar isFunction = (v) => typeof v === \"function\";\nvar hasProp = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\n\n// ../utilities/core/src/object.ts\nfunction compact(obj) {\n  if (!isPlainObject(obj) || obj === void 0) {\n    return obj;\n  }\n  const keys = Reflect.ownKeys(obj).filter((key) => typeof key === \"string\");\n  const filtered = {};\n  for (const key of keys) {\n    const value = obj[key];\n    if (value !== void 0) {\n      filtered[key] = compact(value);\n    }\n  }\n  return filtered;\n}\nvar isPlainObject = (value) => {\n  return value && typeof value === \"object\" && value.constructor === Object;\n};\n\n// ../utilities/core/src/warning.ts\nfunction warn(...a) {\n  const m = a.length === 1 ? a[0] : a[1];\n  const c = a.length === 2 ? a[0] : true;\n  if (c && \"development\" !== \"production\") {\n    console.warn(m);\n  }\n}\nfunction invariant(...a) {\n  const m = a.length === 1 ? a[0] : a[1];\n  const c = a.length === 2 ? a[0] : true;\n  if (c && \"development\" !== \"production\") {\n    throw new Error(m);\n  }\n}\n\n// src/deep-merge.ts\nfunction deepMerge(source, ...objects) {\n  for (const obj of objects) {\n    const target = compact(obj);\n    for (const key in target) {\n      if (isObject(obj[key])) {\n        if (!source[key]) {\n          source[key] = {};\n        }\n        deepMerge(source[key], obj[key]);\n      } else {\n        source[key] = obj[key];\n      }\n    }\n  }\n  return source;\n}\n\n// src/utils.ts\n\nfunction structuredClone(v) {\n  return (0,klona_full__WEBPACK_IMPORTED_MODULE_0__.klona)(v);\n}\nfunction toEvent(event) {\n  const obj = isString(event) ? { type: event } : event;\n  return obj;\n}\nfunction toArray(value) {\n  if (!value) return [];\n  return isArray(value) ? value.slice() : [value];\n}\nfunction isGuardHelper(value) {\n  return isObject(value) && value.predicate != null;\n}\n\n// src/guard-utils.ts\nvar Truthy = () => true;\nfunction exec(guardMap, ctx, event, meta) {\n  return (guard) => {\n    if (isString(guard)) {\n      return !!guardMap[guard]?.(ctx, event, meta);\n    }\n    if (isFunction(guard)) {\n      return guard(ctx, event, meta);\n    }\n    return guard.predicate(guardMap)(ctx, event, meta);\n  };\n}\nfunction or(...conditions) {\n  return {\n    predicate: (guardMap) => (ctx, event, meta) => conditions.map(exec(guardMap, ctx, event, meta)).some(Boolean)\n  };\n}\nfunction and(...conditions) {\n  return {\n    predicate: (guardMap) => (ctx, event, meta) => conditions.map(exec(guardMap, ctx, event, meta)).every(Boolean)\n  };\n}\nfunction not(condition) {\n  return {\n    predicate: (guardMap) => (ctx, event, meta) => {\n      return !exec(guardMap, ctx, event, meta)(condition);\n    }\n  };\n}\nfunction stateIn(...values) {\n  return (_ctx, _evt, meta) => meta.state.matches(...values);\n}\nvar guards = { or, and, not, stateIn };\nfunction choose(actions) {\n  return {\n    predicate: (guardMap) => (ctx, event, meta) => actions.find((def) => {\n      const guard = def.guard ?? Truthy;\n      return exec(guardMap, ctx, event, meta)(guard);\n    })?.actions\n  };\n}\nfunction determineGuardFn(guard, guardMap) {\n  guard = guard ?? Truthy;\n  return (context, event, meta) => {\n    if (isString(guard)) {\n      const value = guardMap[guard];\n      return isFunction(value) ? value(context, event, meta) : value;\n    }\n    if (isGuardHelper(guard)) {\n      return guard.predicate(guardMap)(context, event, meta);\n    }\n    return guard?.(context, event, meta);\n  };\n}\nfunction determineActionsFn(values, guardMap) {\n  return (context, event, meta) => {\n    if (isGuardHelper(values)) {\n      return values.predicate(guardMap)(context, event, meta);\n    }\n    return values;\n  };\n}\n\n// src/machine.ts\n\n\n// src/create-proxy.ts\n\nfunction createProxy(config) {\n  const computedContext = config.computed ?? cast({});\n  const initialContext = config.context ?? cast({});\n  const initialTags = config.initial ? config.states?.[config.initial]?.tags : [];\n  const state = (0,_zag_js_store__WEBPACK_IMPORTED_MODULE_1__.proxy)({\n    value: config.initial ?? \"\",\n    previousValue: \"\",\n    event: cast({}),\n    previousEvent: cast({}),\n    context: (0,_zag_js_store__WEBPACK_IMPORTED_MODULE_1__.proxyWithComputed)(initialContext, computedContext),\n    done: false,\n    tags: initialTags ?? [],\n    hasTag(tag) {\n      return this.tags.includes(tag);\n    },\n    matches(...value) {\n      return value.includes(this.value);\n    },\n    can(event) {\n      return cast(this).nextEvents.includes(event);\n    },\n    get nextEvents() {\n      const stateEvents = config.states?.[this.value]?.[\"on\"] ?? {};\n      const globalEvents = config?.on ?? {};\n      return Object.keys({ ...stateEvents, ...globalEvents });\n    },\n    get changed() {\n      if (this.event.value === \"machine.init\" /* Init */ || !this.previousValue) return false;\n      return this.value !== this.previousValue;\n    }\n  });\n  return cast(state);\n}\n\n// src/delay-utils.ts\nfunction determineDelayFn(delay, delaysMap) {\n  return (context, event) => {\n    if (isNumber(delay)) return delay;\n    if (isFunction(delay)) {\n      return delay(context, event);\n    }\n    if (isString(delay)) {\n      const value = Number.parseFloat(delay);\n      if (!Number.isNaN(value)) {\n        return value;\n      }\n      if (delaysMap) {\n        const valueOrFn = delaysMap?.[delay];\n        invariant(\n          valueOrFn == null,\n          `[@zag-js/core > determine-delay] Cannot determine delay for \\`${delay}\\`. It doesn't exist in \\`options.delays\\``\n        );\n        return isFunction(valueOrFn) ? valueOrFn(context, event) : valueOrFn;\n      }\n    }\n  };\n}\n\n// src/transition-utils.ts\nfunction toTarget(target) {\n  return isString(target) ? { target } : target;\n}\nfunction determineTransitionFn(transitions, guardMap) {\n  return (context, event, meta) => {\n    return toArray(transitions).map(toTarget).find((transition) => {\n      const determineGuard = determineGuardFn(transition.guard, guardMap);\n      const guard = determineGuard(context, event, meta);\n      return guard ?? transition.target ?? transition.actions;\n    });\n  };\n}\n\n// src/machine.ts\nvar Machine = class {\n  // Let's get started!\n  constructor(config, options) {\n    __publicField(this, \"status\", \"Not Started\" /* NotStarted */);\n    __publicField(this, \"state\");\n    __publicField(this, \"initialState\");\n    __publicField(this, \"initialContext\");\n    __publicField(this, \"id\");\n    __publicField(this, \"type\", \"machine\" /* Machine */);\n    // Cleanup function map (per state)\n    __publicField(this, \"activityEvents\", /* @__PURE__ */ new Map());\n    __publicField(this, \"delayedEvents\", /* @__PURE__ */ new Map());\n    // state update listeners the user can opt-in for\n    __publicField(this, \"stateListeners\", /* @__PURE__ */ new Set());\n    __publicField(this, \"doneListeners\", /* @__PURE__ */ new Set());\n    __publicField(this, \"contextWatchers\", /* @__PURE__ */ new Set());\n    // Cleanup functions (for `subscribe`)\n    __publicField(this, \"removeStateListener\", noop);\n    // For Parent <==> Spawned Actor relationship\n    __publicField(this, \"parent\");\n    __publicField(this, \"children\", /* @__PURE__ */ new Map());\n    // A map of guard, action, delay implementations\n    __publicField(this, \"guardMap\");\n    __publicField(this, \"actionMap\");\n    __publicField(this, \"delayMap\");\n    __publicField(this, \"activityMap\");\n    __publicField(this, \"sync\");\n    __publicField(this, \"options\");\n    __publicField(this, \"config\");\n    __publicField(this, \"_created\", () => {\n      const event = toEvent(\"machine.created\" /* Created */);\n      this.executeActions(this.config?.created, event);\n    });\n    // Starts the interpreted machine.\n    __publicField(this, \"start\", (init) => {\n      this.state.value = \"\";\n      this.state.tags = [];\n      if (this.status === \"Running\" /* Running */) {\n        return this;\n      }\n      this.status = \"Running\" /* Running */;\n      this.removeStateListener = (0,_zag_js_store__WEBPACK_IMPORTED_MODULE_1__.subscribe)(\n        this.state,\n        () => {\n          this.stateListeners.forEach((listener) => {\n            listener(this.stateSnapshot);\n          });\n        },\n        this.sync\n      );\n      this.setupContextWatchers();\n      this.executeActivities(toEvent(\"machine.start\" /* Start */), toArray(this.config.activities), \"machine.start\" /* Start */);\n      this.executeActions(this.config.entry, toEvent(\"machine.start\" /* Start */));\n      const event = toEvent(\"machine.init\" /* Init */);\n      const target = isObject(init) ? init.value : init;\n      const context = isObject(init) ? init.context : void 0;\n      if (context) {\n        this.setContext(context);\n      }\n      const transition = {\n        target: target ?? this.config.initial\n      };\n      const next = this.getNextStateInfo(transition, event);\n      this.initialState = next;\n      this.performStateChangeEffects(this.state.value, next, event);\n      return this;\n    });\n    __publicField(this, \"setupContextWatchers\", () => {\n      const { watch } = this.config;\n      if (!watch) return;\n      let prev = (0,_zag_js_store__WEBPACK_IMPORTED_MODULE_1__.snapshot)(this.state.context);\n      const cleanup = (0,_zag_js_store__WEBPACK_IMPORTED_MODULE_1__.subscribe)(this.state.context, () => {\n        const next = (0,_zag_js_store__WEBPACK_IMPORTED_MODULE_1__.snapshot)(this.state.context);\n        for (const [key, fn] of Object.entries(watch)) {\n          const isEqual = this.options.compareFns?.[key] ?? Object.is;\n          if (isEqual(prev[key], next[key])) continue;\n          this.executeActions(fn, this.state.event);\n        }\n        prev = next;\n      });\n      this.contextWatchers.add(cleanup);\n    });\n    // Stops the interpreted machine\n    __publicField(this, \"stop\", () => {\n      if (this.status === \"Stopped\" /* Stopped */) return;\n      this.performExitEffects(this.state.value, toEvent(\"machine.stop\" /* Stop */));\n      this.executeActions(this.config.exit, toEvent(\"machine.stop\" /* Stop */));\n      this.setState(\"\");\n      this.setEvent(\"machine.stop\" /* Stop */);\n      this.stopStateListeners();\n      this.stopChildren();\n      this.stopActivities();\n      this.stopDelayedEvents();\n      this.stopContextWatchers();\n      this.status = \"Stopped\" /* Stopped */;\n      return this;\n    });\n    __publicField(this, \"stopStateListeners\", () => {\n      this.removeStateListener();\n      this.stateListeners.clear();\n    });\n    __publicField(this, \"stopContextWatchers\", () => {\n      this.contextWatchers.forEach((fn) => fn());\n      this.contextWatchers.clear();\n    });\n    __publicField(this, \"stopDelayedEvents\", () => {\n      this.delayedEvents.forEach((state) => {\n        state.forEach((stop) => stop());\n      });\n      this.delayedEvents.clear();\n    });\n    // Cleanup running activities (e.g `setInterval`, invoked callbacks, promises)\n    __publicField(this, \"stopActivities\", (state) => {\n      if (state) {\n        this.activityEvents.get(state)?.forEach((stop) => stop());\n        this.activityEvents.get(state)?.clear();\n        this.activityEvents.delete(state);\n      } else {\n        this.activityEvents.forEach((state2) => {\n          state2.forEach((stop) => stop());\n          state2.clear();\n        });\n        this.activityEvents.clear();\n      }\n    });\n    /**\n     * Function to send event to spawned child machine or actor\n     */\n    __publicField(this, \"sendChild\", (evt, to) => {\n      const event = toEvent(evt);\n      const id = runIfFn(to, this.contextSnapshot);\n      const child = this.children.get(id);\n      if (!child) {\n        invariant(`[@zag-js/core] Cannot send '${event.type}' event to unknown child`);\n      }\n      child.send(event);\n    });\n    /**\n     * Function to stop a running child machine or actor\n     */\n    __publicField(this, \"stopChild\", (id) => {\n      if (!this.children.has(id)) {\n        invariant(`[@zag-js/core > stop-child] Cannot stop unknown child ${id}`);\n      }\n      this.children.get(id).stop();\n      this.children.delete(id);\n    });\n    __publicField(this, \"removeChild\", (id) => {\n      this.children.delete(id);\n    });\n    // Stop and delete spawned actors\n    __publicField(this, \"stopChildren\", () => {\n      this.children.forEach((child) => child.stop());\n      this.children.clear();\n    });\n    __publicField(this, \"setParent\", (parent) => {\n      this.parent = parent;\n    });\n    __publicField(this, \"spawn\", (src, id) => {\n      const actor = runIfFn(src);\n      if (id) actor.id = id;\n      actor.type = \"machine.actor\" /* Actor */;\n      actor.setParent(this);\n      this.children.set(actor.id, cast(actor));\n      actor.onDone(() => {\n        this.removeChild(actor.id);\n      }).start();\n      return cast((0,_zag_js_store__WEBPACK_IMPORTED_MODULE_1__.ref)(actor));\n    });\n    __publicField(this, \"stopActivity\", (key) => {\n      if (!this.state.value) return;\n      const cleanups = this.activityEvents.get(this.state.value);\n      cleanups?.get(key)?.();\n      cleanups?.delete(key);\n    });\n    __publicField(this, \"addActivityCleanup\", (state, key, cleanup) => {\n      if (!state) return;\n      if (!this.activityEvents.has(state)) {\n        this.activityEvents.set(state, /* @__PURE__ */ new Map([[key, cleanup]]));\n      } else {\n        this.activityEvents.get(state)?.set(key, cleanup);\n      }\n    });\n    __publicField(this, \"setState\", (target) => {\n      this.state.previousValue = this.state.value;\n      this.state.value = target;\n      const stateNode = this.getStateNode(target);\n      if (target == null) {\n        clear(this.state.tags);\n      } else {\n        this.state.tags = toArray(stateNode?.tags);\n      }\n    });\n    /**\n     * To used within side effects for React or Vue to update context\n     */\n    __publicField(this, \"setContext\", (context) => {\n      if (!context) return;\n      deepMerge(this.state.context, compact(context));\n    });\n    __publicField(this, \"setOptions\", (options) => {\n      const opts = compact(options);\n      this.actionMap = { ...this.actionMap, ...opts.actions };\n      this.delayMap = { ...this.delayMap, ...opts.delays };\n      this.activityMap = { ...this.activityMap, ...opts.activities };\n      this.guardMap = { ...this.guardMap, ...opts.guards };\n    });\n    __publicField(this, \"getStateNode\", (state) => {\n      if (!state) return;\n      return this.config.states?.[state];\n    });\n    __publicField(this, \"getNextStateInfo\", (transitions, event) => {\n      const transition = this.determineTransition(transitions, event);\n      const isTargetless = !transition?.target;\n      const target = transition?.target ?? this.state.value;\n      const changed = this.state.value !== target;\n      const stateNode = this.getStateNode(target);\n      const reenter = !isTargetless && !changed && !transition?.internal;\n      const info = {\n        reenter,\n        transition,\n        stateNode,\n        target,\n        changed\n      };\n      this.log(\"NextState:\", `[${event.type}]`, this.state.value, \"---->\", info.target);\n      return info;\n    });\n    __publicField(this, \"getAfterActions\", (transition, delay) => {\n      let id;\n      return {\n        entry: () => {\n          id = globalThis.setTimeout(() => {\n            const next = this.getNextStateInfo(transition, this.state.event);\n            this.performStateChangeEffects(this.state.value, next, this.state.event);\n          }, delay);\n        },\n        exit: () => {\n          globalThis.clearTimeout(id);\n        }\n      };\n    });\n    /**\n     * All `after` events leverage `setTimeout` and `clearTimeout`,\n     * we invoke the `clearTimeout` on exit and `setTimeout` on entry.\n     *\n     * To achieve this, we split the `after` defintion into `entry` and `exit`\n     *  functions and append them to the state's `entry` and `exit` actions\n     */\n    __publicField(this, \"getDelayedEventActions\", (state) => {\n      const stateNode = this.getStateNode(state);\n      const event = this.state.event;\n      if (!stateNode || !stateNode.after) return;\n      const entries = [];\n      const exits = [];\n      if (isArray(stateNode.after)) {\n        const transition = this.determineTransition(stateNode.after, event);\n        if (!transition) return;\n        if (!hasProp(transition, \"delay\")) {\n          throw new Error(`[@zag-js/core > after] Delay is required for after transition: ${JSON.stringify(transition)}`);\n        }\n        const determineDelay = determineDelayFn(transition.delay, this.delayMap);\n        const __delay = determineDelay(this.contextSnapshot, event);\n        const actions = this.getAfterActions(transition, __delay);\n        entries.push(actions.entry);\n        exits.push(actions.exit);\n        return { entries, exits };\n      }\n      if (isObject(stateNode.after)) {\n        for (const delay in stateNode.after) {\n          const transition = stateNode.after[delay];\n          const determineDelay = determineDelayFn(delay, this.delayMap);\n          const __delay = determineDelay(this.contextSnapshot, event);\n          const actions = this.getAfterActions(transition, __delay);\n          entries.push(actions.entry);\n          exits.push(actions.exit);\n        }\n      }\n      return { entries, exits };\n    });\n    /**\n     * Function to executes defined actions. It can accept actions as string\n     * (referencing `options.actions`) or actual functions.\n     */\n    __publicField(this, \"executeActions\", (actions, event) => {\n      const pickedActions = determineActionsFn(actions, this.guardMap)(this.contextSnapshot, event, this.guardMeta);\n      for (const action of toArray(pickedActions)) {\n        const fn = isString(action) ? this.actionMap?.[action] : action;\n        warn(\n          isString(action) && !fn,\n          `[@zag-js/core > execute-actions] No implementation found for action: \\`${action}\\``\n        );\n        fn?.(this.state.context, event, this.meta);\n      }\n    });\n    /**\n     * Function to execute running activities and registers\n     * their cleanup function internally (to be called later on when we exit the state)\n     */\n    __publicField(this, \"executeActivities\", (event, activities, state) => {\n      for (const activity of activities) {\n        const fn = isString(activity) ? this.activityMap?.[activity] : activity;\n        if (!fn) {\n          warn(`[@zag-js/core > execute-activity] No implementation found for activity: \\`${activity}\\``);\n          continue;\n        }\n        const cleanup = fn(this.state.context, event, this.meta);\n        if (cleanup) {\n          const key = isString(activity) ? activity : activity.name || uuid();\n          this.addActivityCleanup(state ?? this.state.value, key, cleanup);\n        }\n      }\n    });\n    /**\n     * Normalizes the `every` definition to transition. `every` can be:\n     * - An array of possible actions to run (we need to pick the first match based on guard)\n     * - An object of intervals and actions\n     */\n    __publicField(this, \"createEveryActivities\", (every, callbackfn) => {\n      if (!every) return;\n      if (isArray(every)) {\n        const picked = toArray(every).find((transition) => {\n          const delayOrFn = transition.delay;\n          const determineDelay2 = determineDelayFn(delayOrFn, this.delayMap);\n          const delay2 = determineDelay2(this.contextSnapshot, this.state.event);\n          const determineGuard = determineGuardFn(transition.guard, this.guardMap);\n          const guard = determineGuard(this.contextSnapshot, this.state.event, this.guardMeta);\n          return guard ?? delay2 != null;\n        });\n        if (!picked) return;\n        const determineDelay = determineDelayFn(picked.delay, this.delayMap);\n        const delay = determineDelay(this.contextSnapshot, this.state.event);\n        const activity = () => {\n          const id = globalThis.setInterval(() => {\n            this.executeActions(picked.actions, this.state.event);\n          }, delay);\n          return () => {\n            globalThis.clearInterval(id);\n          };\n        };\n        callbackfn(activity);\n      } else {\n        for (const interval in every) {\n          const actions = every?.[interval];\n          const determineDelay = determineDelayFn(interval, this.delayMap);\n          const delay = determineDelay(this.contextSnapshot, this.state.event);\n          const activity = () => {\n            const id = globalThis.setInterval(() => {\n              this.executeActions(actions, this.state.event);\n            }, delay);\n            return () => {\n              globalThis.clearInterval(id);\n            };\n          };\n          callbackfn(activity);\n        }\n      }\n    });\n    __publicField(this, \"setEvent\", (event) => {\n      this.state.previousEvent = this.state.event;\n      this.state.event = (0,_zag_js_store__WEBPACK_IMPORTED_MODULE_1__.ref)(toEvent(event));\n    });\n    __publicField(this, \"performExitEffects\", (current, event) => {\n      const currentState = this.state.value;\n      if (currentState === \"\") return;\n      const stateNode = current ? this.getStateNode(current) : void 0;\n      this.stopActivities(currentState);\n      const _exit = determineActionsFn(stateNode?.exit, this.guardMap)(this.contextSnapshot, event, this.guardMeta);\n      const exitActions = toArray(_exit);\n      const afterExitActions = this.delayedEvents.get(currentState);\n      if (afterExitActions) {\n        exitActions.push(...afterExitActions);\n      }\n      this.executeActions(exitActions, event);\n    });\n    __publicField(this, \"performEntryEffects\", (next, event) => {\n      const stateNode = this.getStateNode(next);\n      const activities = toArray(stateNode?.activities);\n      this.createEveryActivities(stateNode?.every, (activity) => {\n        activities.unshift(activity);\n      });\n      if (activities.length > 0) {\n        this.executeActivities(event, activities);\n      }\n      const pickedActions = determineActionsFn(stateNode?.entry, this.guardMap)(\n        this.contextSnapshot,\n        event,\n        this.guardMeta\n      );\n      const entryActions = toArray(pickedActions);\n      const afterActions = this.getDelayedEventActions(next);\n      if (stateNode?.after && afterActions) {\n        this.delayedEvents.set(next, afterActions?.exits);\n        entryActions.push(...afterActions.entries);\n      }\n      this.executeActions(entryActions, event);\n      if (stateNode?.type === \"final\") {\n        this.state.done = true;\n        this.doneListeners.forEach((listener) => {\n          listener(this.stateSnapshot);\n        });\n        this.stop();\n      }\n    });\n    __publicField(this, \"performTransitionEffects\", (transitions, event) => {\n      const transition = this.determineTransition(transitions, event);\n      this.executeActions(transition?.actions, event);\n    });\n    /**\n     * Performs all the requires side-effects or reactions when\n     * we move from state A => state B.\n     *\n     * The Effect order:\n     * Exit actions (current state) => Transition actions  => Go to state => Entry actions (next state)\n     */\n    __publicField(this, \"performStateChangeEffects\", (current, next, event) => {\n      this.setEvent(event);\n      const changed = next.changed || next.reenter;\n      if (changed) {\n        this.performExitEffects(current, event);\n      }\n      this.performTransitionEffects(next.transition, event);\n      this.setState(next.target);\n      if (changed) {\n        this.performEntryEffects(next.target, event);\n      }\n    });\n    __publicField(this, \"determineTransition\", (transition, event) => {\n      const fn = determineTransitionFn(transition, this.guardMap);\n      return fn?.(this.contextSnapshot, event, this.guardMeta);\n    });\n    /**\n     * Function to send event to parent machine from spawned child\n     */\n    __publicField(this, \"sendParent\", (evt) => {\n      if (!this.parent) {\n        invariant(\"[@zag-js/core > send-parent] Cannot send event to an unknown parent\");\n      }\n      const event = toEvent(evt);\n      this.parent?.send(event);\n    });\n    __publicField(this, \"log\", (...args) => {\n      if (isDev() && this.options.debug) {\n        console.log(...args);\n      }\n    });\n    /**\n     * Function to send an event to current machine\n     */\n    __publicField(this, \"send\", (evt) => {\n      const event = toEvent(evt);\n      this.transition(this.state.value, event);\n    });\n    __publicField(this, \"transition\", (state, evt) => {\n      const stateNode = isString(state) ? this.getStateNode(state) : state?.stateNode;\n      const event = toEvent(evt);\n      if (!stateNode && !this.config.on) {\n        const msg = this.status === \"Stopped\" /* Stopped */ ? \"[@zag-js/core > transition] Cannot transition a stopped machine\" : `[@zag-js/core > transition] State does not have a definition for \\`state\\`: ${state}, \\`event\\`: ${event.type}`;\n        warn(msg);\n        return;\n      }\n      const transitions = (\n        // @ts-expect-error - Fix this\n        stateNode?.on?.[event.type] ?? this.config.on?.[event.type]\n      );\n      const next = this.getNextStateInfo(transitions, event);\n      this.performStateChangeEffects(this.state.value, next, event);\n      return next.stateNode;\n    });\n    __publicField(this, \"subscribe\", (listener) => {\n      this.stateListeners.add(listener);\n      if (this.status === \"Running\" /* Running */) {\n        listener(this.stateSnapshot);\n      }\n      return () => {\n        this.stateListeners.delete(listener);\n      };\n    });\n    __publicField(this, \"onDone\", (listener) => {\n      this.doneListeners.add(listener);\n      return this;\n    });\n    __publicField(this, \"onTransition\", (listener) => {\n      this.stateListeners.add(listener);\n      if (this.status === \"Running\" /* Running */) {\n        listener(this.stateSnapshot);\n      }\n      return this;\n    });\n    this.config = structuredClone(config);\n    this.options = structuredClone(options ?? {});\n    this.id = this.config.id ?? `machine-${uuid()}`;\n    this.guardMap = this.options?.guards ?? {};\n    this.actionMap = this.options?.actions ?? {};\n    this.delayMap = this.options?.delays ?? {};\n    this.activityMap = this.options?.activities ?? {};\n    this.sync = this.options?.sync ?? false;\n    this.state = createProxy(this.config);\n    this.initialContext = (0,_zag_js_store__WEBPACK_IMPORTED_MODULE_1__.snapshot)(this.state.context);\n  }\n  // immutable state value\n  get stateSnapshot() {\n    return cast((0,_zag_js_store__WEBPACK_IMPORTED_MODULE_1__.snapshot)(this.state));\n  }\n  getState() {\n    return this.stateSnapshot;\n  }\n  // immutable context value\n  get contextSnapshot() {\n    return this.stateSnapshot.context;\n  }\n  /**\n   * A reference to the instance methods of the machine.\n   * Useful when spawning child machines and managing the communication between them.\n   */\n  get self() {\n    const self = this;\n    return {\n      id: this.id,\n      send: this.send.bind(this),\n      sendParent: this.sendParent.bind(this),\n      sendChild: this.sendChild.bind(this),\n      stop: this.stop.bind(this),\n      stopChild: this.stopChild.bind(this),\n      spawn: this.spawn.bind(this),\n      stopActivity: this.stopActivity.bind(this),\n      get state() {\n        return self.stateSnapshot;\n      },\n      get initialContext() {\n        return self.initialContext;\n      },\n      get initialState() {\n        return self.initialState?.target ?? \"\";\n      }\n    };\n  }\n  get meta() {\n    return {\n      state: this.stateSnapshot,\n      guards: this.guardMap,\n      send: this.send.bind(this),\n      self: this.self,\n      initialContext: this.initialContext,\n      initialState: this.initialState?.target ?? \"\",\n      getState: () => this.stateSnapshot,\n      getAction: (key) => this.actionMap[key],\n      getGuard: (key) => this.guardMap[key]\n    };\n  }\n  get guardMeta() {\n    return {\n      state: this.stateSnapshot\n    };\n  }\n  get [Symbol.toStringTag]() {\n    return \"Machine\";\n  }\n  getHydrationState() {\n    const state = this.getState();\n    return {\n      value: state.value,\n      tags: state.tags\n    };\n  }\n};\nvar createMachine = (config, options) => new Machine(config, options);\nvar isMachine = (value) => {\n  return value instanceof Machine || value?.type === \"machine\" /* Machine */;\n};\n\n// src/merge-props.ts\nvar clsx = (...args) => args.map((str) => str?.trim?.()).filter(Boolean).join(\" \");\nvar CSS_REGEX = /((?:--)?(?:\\w+-?)+)\\s*:\\s*([^;]*)/g;\nvar serialize = (style) => {\n  const res = {};\n  let match;\n  while (match = CSS_REGEX.exec(style)) {\n    res[match[1]] = match[2];\n  }\n  return res;\n};\nvar css = (a, b) => {\n  if (isString(a)) {\n    if (isString(b)) return `${a};${b}`;\n    a = serialize(a);\n  } else if (isString(b)) {\n    b = serialize(b);\n  }\n  return Object.assign({}, a ?? {}, b ?? {});\n};\nfunction mergeProps(...args) {\n  let result = {};\n  for (let props of args) {\n    for (let key in result) {\n      if (key.startsWith(\"on\") && typeof result[key] === \"function\" && typeof props[key] === \"function\") {\n        result[key] = callAll(props[key], result[key]);\n        continue;\n      }\n      if (key === \"className\" || key === \"class\") {\n        result[key] = clsx(result[key], props[key]);\n        continue;\n      }\n      if (key === \"style\") {\n        result[key] = css(result[key], props[key]);\n        continue;\n      }\n      result[key] = props[key] !== void 0 ? props[key] : result[key];\n    }\n    for (let key in props) {\n      if (result[key] === void 0) {\n        result[key] = props[key];\n      }\n    }\n  }\n  return result;\n}\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHphZy1qcy9jb3JlL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBLDhFQUE4RSw2REFBNkQ7QUFDM0k7O0FBRUE7QUFDNkc7O0FBRTdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSxrQkFBa0IsYUFBb0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBb0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFvQjtBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ21DO0FBQ25DO0FBQ0EsU0FBUyxpREFBSztBQUNkO0FBQ0E7QUFDQSxrQ0FBa0MsY0FBYztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0RBQWdEO0FBQ2hELDJDQUEyQyxPQUFPO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix1REFBUTtBQUNsQztBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdURBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsR0FBRyxFQUFFLEVBQUU7QUFDdEM7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLHlCQUF5QixTQUFTLFNBQVM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBYUU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3NpdGVzLy4vbm9kZV9tb2R1bGVzL0B6YWctanMvY29yZS9kaXN0L2luZGV4Lm1qcz8zMmRjIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19wdWJsaWNGaWVsZCA9IChvYmosIGtleSwgdmFsdWUpID0+IF9fZGVmTm9ybWFsUHJvcChvYmosIHR5cGVvZiBrZXkgIT09IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG5cbi8vIHNyYy9pbmRleC50c1xuaW1wb3J0IHsgcHJveHkgYXMgcHJveHkyLCByZWYgYXMgcmVmMiwgc25hcHNob3QgYXMgc25hcHNob3QyLCBzdWJzY3JpYmUgYXMgc3Vic2NyaWJlMiB9IGZyb20gXCJAemFnLWpzL3N0b3JlXCI7XG5cbi8vIC4uL3V0aWxpdGllcy9jb3JlL3NyYy9hcnJheS50c1xuZnVuY3Rpb24gY2xlYXIodikge1xuICB3aGlsZSAodi5sZW5ndGggPiAwKSB2LnBvcCgpO1xuICByZXR1cm4gdjtcbn1cblxuLy8gLi4vdXRpbGl0aWVzL2NvcmUvc3JjL2Z1bmN0aW9ucy50c1xudmFyIHJ1bklmRm4gPSAodiwgLi4uYSkgPT4ge1xuICBjb25zdCByZXMgPSB0eXBlb2YgdiA9PT0gXCJmdW5jdGlvblwiID8gdiguLi5hKSA6IHY7XG4gIHJldHVybiByZXMgPz8gdm9pZCAwO1xufTtcbnZhciBjYXN0ID0gKHYpID0+IHY7XG52YXIgbm9vcCA9ICgpID0+IHtcbn07XG52YXIgY2FsbEFsbCA9ICguLi5mbnMpID0+ICguLi5hKSA9PiB7XG4gIGZucy5mb3JFYWNoKGZ1bmN0aW9uKGZuKSB7XG4gICAgZm4/LiguLi5hKTtcbiAgfSk7XG59O1xudmFyIHV1aWQgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IHtcbiAgbGV0IGlkID0gMDtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBpZCsrO1xuICAgIHJldHVybiBpZC50b1N0cmluZygzNik7XG4gIH07XG59KSgpO1xuXG4vLyAuLi91dGlsaXRpZXMvY29yZS9zcmMvZ3VhcmQudHNcbnZhciBpc0RldiA9ICgpID0+IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIjtcbnZhciBpc0FycmF5ID0gKHYpID0+IEFycmF5LmlzQXJyYXkodik7XG52YXIgaXNPYmplY3QgPSAodikgPT4gISh2ID09IG51bGwgfHwgdHlwZW9mIHYgIT09IFwib2JqZWN0XCIgfHwgaXNBcnJheSh2KSk7XG52YXIgaXNOdW1iZXIgPSAodikgPT4gdHlwZW9mIHYgPT09IFwibnVtYmVyXCIgJiYgIU51bWJlci5pc05hTih2KTtcbnZhciBpc1N0cmluZyA9ICh2KSA9PiB0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIjtcbnZhciBpc0Z1bmN0aW9uID0gKHYpID0+IHR5cGVvZiB2ID09PSBcImZ1bmN0aW9uXCI7XG52YXIgaGFzUHJvcCA9IChvYmosIHByb3ApID0+IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xuXG4vLyAuLi91dGlsaXRpZXMvY29yZS9zcmMvb2JqZWN0LnRzXG5mdW5jdGlvbiBjb21wYWN0KG9iaikge1xuICBpZiAoIWlzUGxhaW5PYmplY3Qob2JqKSB8fCBvYmogPT09IHZvaWQgMCkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cbiAgY29uc3Qga2V5cyA9IFJlZmxlY3Qub3duS2V5cyhvYmopLmZpbHRlcigoa2V5KSA9PiB0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiKTtcbiAgY29uc3QgZmlsdGVyZWQgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgIGNvbnN0IHZhbHVlID0gb2JqW2tleV07XG4gICAgaWYgKHZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgIGZpbHRlcmVkW2tleV0gPSBjb21wYWN0KHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZpbHRlcmVkO1xufVxudmFyIGlzUGxhaW5PYmplY3QgPSAodmFsdWUpID0+IHtcbiAgcmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0O1xufTtcblxuLy8gLi4vdXRpbGl0aWVzL2NvcmUvc3JjL3dhcm5pbmcudHNcbmZ1bmN0aW9uIHdhcm4oLi4uYSkge1xuICBjb25zdCBtID0gYS5sZW5ndGggPT09IDEgPyBhWzBdIDogYVsxXTtcbiAgY29uc3QgYyA9IGEubGVuZ3RoID09PSAyID8gYVswXSA6IHRydWU7XG4gIGlmIChjICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGNvbnNvbGUud2FybihtKTtcbiAgfVxufVxuZnVuY3Rpb24gaW52YXJpYW50KC4uLmEpIHtcbiAgY29uc3QgbSA9IGEubGVuZ3RoID09PSAxID8gYVswXSA6IGFbMV07XG4gIGNvbnN0IGMgPSBhLmxlbmd0aCA9PT0gMiA/IGFbMF0gOiB0cnVlO1xuICBpZiAoYyAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobSk7XG4gIH1cbn1cblxuLy8gc3JjL2RlZXAtbWVyZ2UudHNcbmZ1bmN0aW9uIGRlZXBNZXJnZShzb3VyY2UsIC4uLm9iamVjdHMpIHtcbiAgZm9yIChjb25zdCBvYmogb2Ygb2JqZWN0cykge1xuICAgIGNvbnN0IHRhcmdldCA9IGNvbXBhY3Qob2JqKTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiB0YXJnZXQpIHtcbiAgICAgIGlmIChpc09iamVjdChvYmpba2V5XSkpIHtcbiAgICAgICAgaWYgKCFzb3VyY2Vba2V5XSkge1xuICAgICAgICAgIHNvdXJjZVtrZXldID0ge307XG4gICAgICAgIH1cbiAgICAgICAgZGVlcE1lcmdlKHNvdXJjZVtrZXldLCBvYmpba2V5XSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzb3VyY2Vba2V5XSA9IG9ialtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gc291cmNlO1xufVxuXG4vLyBzcmMvdXRpbHMudHNcbmltcG9ydCB7IGtsb25hIH0gZnJvbSBcImtsb25hL2Z1bGxcIjtcbmZ1bmN0aW9uIHN0cnVjdHVyZWRDbG9uZSh2KSB7XG4gIHJldHVybiBrbG9uYSh2KTtcbn1cbmZ1bmN0aW9uIHRvRXZlbnQoZXZlbnQpIHtcbiAgY29uc3Qgb2JqID0gaXNTdHJpbmcoZXZlbnQpID8geyB0eXBlOiBldmVudCB9IDogZXZlbnQ7XG4gIHJldHVybiBvYmo7XG59XG5mdW5jdGlvbiB0b0FycmF5KHZhbHVlKSB7XG4gIGlmICghdmFsdWUpIHJldHVybiBbXTtcbiAgcmV0dXJuIGlzQXJyYXkodmFsdWUpID8gdmFsdWUuc2xpY2UoKSA6IFt2YWx1ZV07XG59XG5mdW5jdGlvbiBpc0d1YXJkSGVscGVyKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdCh2YWx1ZSkgJiYgdmFsdWUucHJlZGljYXRlICE9IG51bGw7XG59XG5cbi8vIHNyYy9ndWFyZC11dGlscy50c1xudmFyIFRydXRoeSA9ICgpID0+IHRydWU7XG5mdW5jdGlvbiBleGVjKGd1YXJkTWFwLCBjdHgsIGV2ZW50LCBtZXRhKSB7XG4gIHJldHVybiAoZ3VhcmQpID0+IHtcbiAgICBpZiAoaXNTdHJpbmcoZ3VhcmQpKSB7XG4gICAgICByZXR1cm4gISFndWFyZE1hcFtndWFyZF0/LihjdHgsIGV2ZW50LCBtZXRhKTtcbiAgICB9XG4gICAgaWYgKGlzRnVuY3Rpb24oZ3VhcmQpKSB7XG4gICAgICByZXR1cm4gZ3VhcmQoY3R4LCBldmVudCwgbWV0YSk7XG4gICAgfVxuICAgIHJldHVybiBndWFyZC5wcmVkaWNhdGUoZ3VhcmRNYXApKGN0eCwgZXZlbnQsIG1ldGEpO1xuICB9O1xufVxuZnVuY3Rpb24gb3IoLi4uY29uZGl0aW9ucykge1xuICByZXR1cm4ge1xuICAgIHByZWRpY2F0ZTogKGd1YXJkTWFwKSA9PiAoY3R4LCBldmVudCwgbWV0YSkgPT4gY29uZGl0aW9ucy5tYXAoZXhlYyhndWFyZE1hcCwgY3R4LCBldmVudCwgbWV0YSkpLnNvbWUoQm9vbGVhbilcbiAgfTtcbn1cbmZ1bmN0aW9uIGFuZCguLi5jb25kaXRpb25zKSB7XG4gIHJldHVybiB7XG4gICAgcHJlZGljYXRlOiAoZ3VhcmRNYXApID0+IChjdHgsIGV2ZW50LCBtZXRhKSA9PiBjb25kaXRpb25zLm1hcChleGVjKGd1YXJkTWFwLCBjdHgsIGV2ZW50LCBtZXRhKSkuZXZlcnkoQm9vbGVhbilcbiAgfTtcbn1cbmZ1bmN0aW9uIG5vdChjb25kaXRpb24pIHtcbiAgcmV0dXJuIHtcbiAgICBwcmVkaWNhdGU6IChndWFyZE1hcCkgPT4gKGN0eCwgZXZlbnQsIG1ldGEpID0+IHtcbiAgICAgIHJldHVybiAhZXhlYyhndWFyZE1hcCwgY3R4LCBldmVudCwgbWV0YSkoY29uZGl0aW9uKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBzdGF0ZUluKC4uLnZhbHVlcykge1xuICByZXR1cm4gKF9jdHgsIF9ldnQsIG1ldGEpID0+IG1ldGEuc3RhdGUubWF0Y2hlcyguLi52YWx1ZXMpO1xufVxudmFyIGd1YXJkcyA9IHsgb3IsIGFuZCwgbm90LCBzdGF0ZUluIH07XG5mdW5jdGlvbiBjaG9vc2UoYWN0aW9ucykge1xuICByZXR1cm4ge1xuICAgIHByZWRpY2F0ZTogKGd1YXJkTWFwKSA9PiAoY3R4LCBldmVudCwgbWV0YSkgPT4gYWN0aW9ucy5maW5kKChkZWYpID0+IHtcbiAgICAgIGNvbnN0IGd1YXJkID0gZGVmLmd1YXJkID8/IFRydXRoeTtcbiAgICAgIHJldHVybiBleGVjKGd1YXJkTWFwLCBjdHgsIGV2ZW50LCBtZXRhKShndWFyZCk7XG4gICAgfSk/LmFjdGlvbnNcbiAgfTtcbn1cbmZ1bmN0aW9uIGRldGVybWluZUd1YXJkRm4oZ3VhcmQsIGd1YXJkTWFwKSB7XG4gIGd1YXJkID0gZ3VhcmQgPz8gVHJ1dGh5O1xuICByZXR1cm4gKGNvbnRleHQsIGV2ZW50LCBtZXRhKSA9PiB7XG4gICAgaWYgKGlzU3RyaW5nKGd1YXJkKSkge1xuICAgICAgY29uc3QgdmFsdWUgPSBndWFyZE1hcFtndWFyZF07XG4gICAgICByZXR1cm4gaXNGdW5jdGlvbih2YWx1ZSkgPyB2YWx1ZShjb250ZXh0LCBldmVudCwgbWV0YSkgOiB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKGlzR3VhcmRIZWxwZXIoZ3VhcmQpKSB7XG4gICAgICByZXR1cm4gZ3VhcmQucHJlZGljYXRlKGd1YXJkTWFwKShjb250ZXh0LCBldmVudCwgbWV0YSk7XG4gICAgfVxuICAgIHJldHVybiBndWFyZD8uKGNvbnRleHQsIGV2ZW50LCBtZXRhKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGRldGVybWluZUFjdGlvbnNGbih2YWx1ZXMsIGd1YXJkTWFwKSB7XG4gIHJldHVybiAoY29udGV4dCwgZXZlbnQsIG1ldGEpID0+IHtcbiAgICBpZiAoaXNHdWFyZEhlbHBlcih2YWx1ZXMpKSB7XG4gICAgICByZXR1cm4gdmFsdWVzLnByZWRpY2F0ZShndWFyZE1hcCkoY29udGV4dCwgZXZlbnQsIG1ldGEpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9O1xufVxuXG4vLyBzcmMvbWFjaGluZS50c1xuaW1wb3J0IHsgcmVmLCBzbmFwc2hvdCwgc3Vic2NyaWJlIH0gZnJvbSBcIkB6YWctanMvc3RvcmVcIjtcblxuLy8gc3JjL2NyZWF0ZS1wcm94eS50c1xuaW1wb3J0IHsgcHJveHksIHByb3h5V2l0aENvbXB1dGVkIH0gZnJvbSBcIkB6YWctanMvc3RvcmVcIjtcbmZ1bmN0aW9uIGNyZWF0ZVByb3h5KGNvbmZpZykge1xuICBjb25zdCBjb21wdXRlZENvbnRleHQgPSBjb25maWcuY29tcHV0ZWQgPz8gY2FzdCh7fSk7XG4gIGNvbnN0IGluaXRpYWxDb250ZXh0ID0gY29uZmlnLmNvbnRleHQgPz8gY2FzdCh7fSk7XG4gIGNvbnN0IGluaXRpYWxUYWdzID0gY29uZmlnLmluaXRpYWwgPyBjb25maWcuc3RhdGVzPy5bY29uZmlnLmluaXRpYWxdPy50YWdzIDogW107XG4gIGNvbnN0IHN0YXRlID0gcHJveHkoe1xuICAgIHZhbHVlOiBjb25maWcuaW5pdGlhbCA/PyBcIlwiLFxuICAgIHByZXZpb3VzVmFsdWU6IFwiXCIsXG4gICAgZXZlbnQ6IGNhc3Qoe30pLFxuICAgIHByZXZpb3VzRXZlbnQ6IGNhc3Qoe30pLFxuICAgIGNvbnRleHQ6IHByb3h5V2l0aENvbXB1dGVkKGluaXRpYWxDb250ZXh0LCBjb21wdXRlZENvbnRleHQpLFxuICAgIGRvbmU6IGZhbHNlLFxuICAgIHRhZ3M6IGluaXRpYWxUYWdzID8/IFtdLFxuICAgIGhhc1RhZyh0YWcpIHtcbiAgICAgIHJldHVybiB0aGlzLnRhZ3MuaW5jbHVkZXModGFnKTtcbiAgICB9LFxuICAgIG1hdGNoZXMoLi4udmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZS5pbmNsdWRlcyh0aGlzLnZhbHVlKTtcbiAgICB9LFxuICAgIGNhbihldmVudCkge1xuICAgICAgcmV0dXJuIGNhc3QodGhpcykubmV4dEV2ZW50cy5pbmNsdWRlcyhldmVudCk7XG4gICAgfSxcbiAgICBnZXQgbmV4dEV2ZW50cygpIHtcbiAgICAgIGNvbnN0IHN0YXRlRXZlbnRzID0gY29uZmlnLnN0YXRlcz8uW3RoaXMudmFsdWVdPy5bXCJvblwiXSA/PyB7fTtcbiAgICAgIGNvbnN0IGdsb2JhbEV2ZW50cyA9IGNvbmZpZz8ub24gPz8ge307XG4gICAgICByZXR1cm4gT2JqZWN0LmtleXMoeyAuLi5zdGF0ZUV2ZW50cywgLi4uZ2xvYmFsRXZlbnRzIH0pO1xuICAgIH0sXG4gICAgZ2V0IGNoYW5nZWQoKSB7XG4gICAgICBpZiAodGhpcy5ldmVudC52YWx1ZSA9PT0gXCJtYWNoaW5lLmluaXRcIiAvKiBJbml0ICovIHx8ICF0aGlzLnByZXZpb3VzVmFsdWUpIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlICE9PSB0aGlzLnByZXZpb3VzVmFsdWU7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGNhc3Qoc3RhdGUpO1xufVxuXG4vLyBzcmMvZGVsYXktdXRpbHMudHNcbmZ1bmN0aW9uIGRldGVybWluZURlbGF5Rm4oZGVsYXksIGRlbGF5c01hcCkge1xuICByZXR1cm4gKGNvbnRleHQsIGV2ZW50KSA9PiB7XG4gICAgaWYgKGlzTnVtYmVyKGRlbGF5KSkgcmV0dXJuIGRlbGF5O1xuICAgIGlmIChpc0Z1bmN0aW9uKGRlbGF5KSkge1xuICAgICAgcmV0dXJuIGRlbGF5KGNvbnRleHQsIGV2ZW50KTtcbiAgICB9XG4gICAgaWYgKGlzU3RyaW5nKGRlbGF5KSkge1xuICAgICAgY29uc3QgdmFsdWUgPSBOdW1iZXIucGFyc2VGbG9hdChkZWxheSk7XG4gICAgICBpZiAoIU51bWJlci5pc05hTih2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKGRlbGF5c01hcCkge1xuICAgICAgICBjb25zdCB2YWx1ZU9yRm4gPSBkZWxheXNNYXA/LltkZWxheV07XG4gICAgICAgIGludmFyaWFudChcbiAgICAgICAgICB2YWx1ZU9yRm4gPT0gbnVsbCxcbiAgICAgICAgICBgW0B6YWctanMvY29yZSA+IGRldGVybWluZS1kZWxheV0gQ2Fubm90IGRldGVybWluZSBkZWxheSBmb3IgXFxgJHtkZWxheX1cXGAuIEl0IGRvZXNuJ3QgZXhpc3QgaW4gXFxgb3B0aW9ucy5kZWxheXNcXGBgXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBpc0Z1bmN0aW9uKHZhbHVlT3JGbikgPyB2YWx1ZU9yRm4oY29udGV4dCwgZXZlbnQpIDogdmFsdWVPckZuO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3RyYW5zaXRpb24tdXRpbHMudHNcbmZ1bmN0aW9uIHRvVGFyZ2V0KHRhcmdldCkge1xuICByZXR1cm4gaXNTdHJpbmcodGFyZ2V0KSA/IHsgdGFyZ2V0IH0gOiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBkZXRlcm1pbmVUcmFuc2l0aW9uRm4odHJhbnNpdGlvbnMsIGd1YXJkTWFwKSB7XG4gIHJldHVybiAoY29udGV4dCwgZXZlbnQsIG1ldGEpID0+IHtcbiAgICByZXR1cm4gdG9BcnJheSh0cmFuc2l0aW9ucykubWFwKHRvVGFyZ2V0KS5maW5kKCh0cmFuc2l0aW9uKSA9PiB7XG4gICAgICBjb25zdCBkZXRlcm1pbmVHdWFyZCA9IGRldGVybWluZUd1YXJkRm4odHJhbnNpdGlvbi5ndWFyZCwgZ3VhcmRNYXApO1xuICAgICAgY29uc3QgZ3VhcmQgPSBkZXRlcm1pbmVHdWFyZChjb250ZXh0LCBldmVudCwgbWV0YSk7XG4gICAgICByZXR1cm4gZ3VhcmQgPz8gdHJhbnNpdGlvbi50YXJnZXQgPz8gdHJhbnNpdGlvbi5hY3Rpb25zO1xuICAgIH0pO1xuICB9O1xufVxuXG4vLyBzcmMvbWFjaGluZS50c1xudmFyIE1hY2hpbmUgPSBjbGFzcyB7XG4gIC8vIExldCdzIGdldCBzdGFydGVkIVxuICBjb25zdHJ1Y3Rvcihjb25maWcsIG9wdGlvbnMpIHtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwic3RhdHVzXCIsIFwiTm90IFN0YXJ0ZWRcIiAvKiBOb3RTdGFydGVkICovKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwic3RhdGVcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImluaXRpYWxTdGF0ZVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiaW5pdGlhbENvbnRleHRcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImlkXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ0eXBlXCIsIFwibWFjaGluZVwiIC8qIE1hY2hpbmUgKi8pO1xuICAgIC8vIENsZWFudXAgZnVuY3Rpb24gbWFwIChwZXIgc3RhdGUpXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImFjdGl2aXR5RXZlbnRzXCIsIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJkZWxheWVkRXZlbnRzXCIsIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICAgIC8vIHN0YXRlIHVwZGF0ZSBsaXN0ZW5lcnMgdGhlIHVzZXIgY2FuIG9wdC1pbiBmb3JcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwic3RhdGVMaXN0ZW5lcnNcIiwgLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImRvbmVMaXN0ZW5lcnNcIiwgLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImNvbnRleHRXYXRjaGVyc1wiLCAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKTtcbiAgICAvLyBDbGVhbnVwIGZ1bmN0aW9ucyAoZm9yIGBzdWJzY3JpYmVgKVxuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJyZW1vdmVTdGF0ZUxpc3RlbmVyXCIsIG5vb3ApO1xuICAgIC8vIEZvciBQYXJlbnQgPD09PiBTcGF3bmVkIEFjdG9yIHJlbGF0aW9uc2hpcFxuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJwYXJlbnRcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImNoaWxkcmVuXCIsIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICAgIC8vIEEgbWFwIG9mIGd1YXJkLCBhY3Rpb24sIGRlbGF5IGltcGxlbWVudGF0aW9uc1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJndWFyZE1hcFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiYWN0aW9uTWFwXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJkZWxheU1hcFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiYWN0aXZpdHlNYXBcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInN5bmNcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm9wdGlvbnNcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImNvbmZpZ1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX2NyZWF0ZWRcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgZXZlbnQgPSB0b0V2ZW50KFwibWFjaGluZS5jcmVhdGVkXCIgLyogQ3JlYXRlZCAqLyk7XG4gICAgICB0aGlzLmV4ZWN1dGVBY3Rpb25zKHRoaXMuY29uZmlnPy5jcmVhdGVkLCBldmVudCk7XG4gICAgfSk7XG4gICAgLy8gU3RhcnRzIHRoZSBpbnRlcnByZXRlZCBtYWNoaW5lLlxuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJzdGFydFwiLCAoaW5pdCkgPT4ge1xuICAgICAgdGhpcy5zdGF0ZS52YWx1ZSA9IFwiXCI7XG4gICAgICB0aGlzLnN0YXRlLnRhZ3MgPSBbXTtcbiAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gXCJSdW5uaW5nXCIgLyogUnVubmluZyAqLykge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHRoaXMuc3RhdHVzID0gXCJSdW5uaW5nXCIgLyogUnVubmluZyAqLztcbiAgICAgIHRoaXMucmVtb3ZlU3RhdGVMaXN0ZW5lciA9IHN1YnNjcmliZShcbiAgICAgICAgdGhpcy5zdGF0ZSxcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIHRoaXMuc3RhdGVMaXN0ZW5lcnMuZm9yRWFjaCgobGlzdGVuZXIpID0+IHtcbiAgICAgICAgICAgIGxpc3RlbmVyKHRoaXMuc3RhdGVTbmFwc2hvdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHRoaXMuc3luY1xuICAgICAgKTtcbiAgICAgIHRoaXMuc2V0dXBDb250ZXh0V2F0Y2hlcnMoKTtcbiAgICAgIHRoaXMuZXhlY3V0ZUFjdGl2aXRpZXModG9FdmVudChcIm1hY2hpbmUuc3RhcnRcIiAvKiBTdGFydCAqLyksIHRvQXJyYXkodGhpcy5jb25maWcuYWN0aXZpdGllcyksIFwibWFjaGluZS5zdGFydFwiIC8qIFN0YXJ0ICovKTtcbiAgICAgIHRoaXMuZXhlY3V0ZUFjdGlvbnModGhpcy5jb25maWcuZW50cnksIHRvRXZlbnQoXCJtYWNoaW5lLnN0YXJ0XCIgLyogU3RhcnQgKi8pKTtcbiAgICAgIGNvbnN0IGV2ZW50ID0gdG9FdmVudChcIm1hY2hpbmUuaW5pdFwiIC8qIEluaXQgKi8pO1xuICAgICAgY29uc3QgdGFyZ2V0ID0gaXNPYmplY3QoaW5pdCkgPyBpbml0LnZhbHVlIDogaW5pdDtcbiAgICAgIGNvbnN0IGNvbnRleHQgPSBpc09iamVjdChpbml0KSA/IGluaXQuY29udGV4dCA6IHZvaWQgMDtcbiAgICAgIGlmIChjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuc2V0Q29udGV4dChjb250ZXh0KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRyYW5zaXRpb24gPSB7XG4gICAgICAgIHRhcmdldDogdGFyZ2V0ID8/IHRoaXMuY29uZmlnLmluaXRpYWxcbiAgICAgIH07XG4gICAgICBjb25zdCBuZXh0ID0gdGhpcy5nZXROZXh0U3RhdGVJbmZvKHRyYW5zaXRpb24sIGV2ZW50KTtcbiAgICAgIHRoaXMuaW5pdGlhbFN0YXRlID0gbmV4dDtcbiAgICAgIHRoaXMucGVyZm9ybVN0YXRlQ2hhbmdlRWZmZWN0cyh0aGlzLnN0YXRlLnZhbHVlLCBuZXh0LCBldmVudCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwic2V0dXBDb250ZXh0V2F0Y2hlcnNcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgeyB3YXRjaCB9ID0gdGhpcy5jb25maWc7XG4gICAgICBpZiAoIXdhdGNoKSByZXR1cm47XG4gICAgICBsZXQgcHJldiA9IHNuYXBzaG90KHRoaXMuc3RhdGUuY29udGV4dCk7XG4gICAgICBjb25zdCBjbGVhbnVwID0gc3Vic2NyaWJlKHRoaXMuc3RhdGUuY29udGV4dCwgKCkgPT4ge1xuICAgICAgICBjb25zdCBuZXh0ID0gc25hcHNob3QodGhpcy5zdGF0ZS5jb250ZXh0KTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCBmbl0gb2YgT2JqZWN0LmVudHJpZXMod2F0Y2gpKSB7XG4gICAgICAgICAgY29uc3QgaXNFcXVhbCA9IHRoaXMub3B0aW9ucy5jb21wYXJlRm5zPy5ba2V5XSA/PyBPYmplY3QuaXM7XG4gICAgICAgICAgaWYgKGlzRXF1YWwocHJldltrZXldLCBuZXh0W2tleV0pKSBjb250aW51ZTtcbiAgICAgICAgICB0aGlzLmV4ZWN1dGVBY3Rpb25zKGZuLCB0aGlzLnN0YXRlLmV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBwcmV2ID0gbmV4dDtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5jb250ZXh0V2F0Y2hlcnMuYWRkKGNsZWFudXApO1xuICAgIH0pO1xuICAgIC8vIFN0b3BzIHRoZSBpbnRlcnByZXRlZCBtYWNoaW5lXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInN0b3BcIiwgKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSBcIlN0b3BwZWRcIiAvKiBTdG9wcGVkICovKSByZXR1cm47XG4gICAgICB0aGlzLnBlcmZvcm1FeGl0RWZmZWN0cyh0aGlzLnN0YXRlLnZhbHVlLCB0b0V2ZW50KFwibWFjaGluZS5zdG9wXCIgLyogU3RvcCAqLykpO1xuICAgICAgdGhpcy5leGVjdXRlQWN0aW9ucyh0aGlzLmNvbmZpZy5leGl0LCB0b0V2ZW50KFwibWFjaGluZS5zdG9wXCIgLyogU3RvcCAqLykpO1xuICAgICAgdGhpcy5zZXRTdGF0ZShcIlwiKTtcbiAgICAgIHRoaXMuc2V0RXZlbnQoXCJtYWNoaW5lLnN0b3BcIiAvKiBTdG9wICovKTtcbiAgICAgIHRoaXMuc3RvcFN0YXRlTGlzdGVuZXJzKCk7XG4gICAgICB0aGlzLnN0b3BDaGlsZHJlbigpO1xuICAgICAgdGhpcy5zdG9wQWN0aXZpdGllcygpO1xuICAgICAgdGhpcy5zdG9wRGVsYXllZEV2ZW50cygpO1xuICAgICAgdGhpcy5zdG9wQ29udGV4dFdhdGNoZXJzKCk7XG4gICAgICB0aGlzLnN0YXR1cyA9IFwiU3RvcHBlZFwiIC8qIFN0b3BwZWQgKi87XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwic3RvcFN0YXRlTGlzdGVuZXJzXCIsICgpID0+IHtcbiAgICAgIHRoaXMucmVtb3ZlU3RhdGVMaXN0ZW5lcigpO1xuICAgICAgdGhpcy5zdGF0ZUxpc3RlbmVycy5jbGVhcigpO1xuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJzdG9wQ29udGV4dFdhdGNoZXJzXCIsICgpID0+IHtcbiAgICAgIHRoaXMuY29udGV4dFdhdGNoZXJzLmZvckVhY2goKGZuKSA9PiBmbigpKTtcbiAgICAgIHRoaXMuY29udGV4dFdhdGNoZXJzLmNsZWFyKCk7XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInN0b3BEZWxheWVkRXZlbnRzXCIsICgpID0+IHtcbiAgICAgIHRoaXMuZGVsYXllZEV2ZW50cy5mb3JFYWNoKChzdGF0ZSkgPT4ge1xuICAgICAgICBzdGF0ZS5mb3JFYWNoKChzdG9wKSA9PiBzdG9wKCkpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmRlbGF5ZWRFdmVudHMuY2xlYXIoKTtcbiAgICB9KTtcbiAgICAvLyBDbGVhbnVwIHJ1bm5pbmcgYWN0aXZpdGllcyAoZS5nIGBzZXRJbnRlcnZhbGAsIGludm9rZWQgY2FsbGJhY2tzLCBwcm9taXNlcylcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwic3RvcEFjdGl2aXRpZXNcIiwgKHN0YXRlKSA9PiB7XG4gICAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgdGhpcy5hY3Rpdml0eUV2ZW50cy5nZXQoc3RhdGUpPy5mb3JFYWNoKChzdG9wKSA9PiBzdG9wKCkpO1xuICAgICAgICB0aGlzLmFjdGl2aXR5RXZlbnRzLmdldChzdGF0ZSk/LmNsZWFyKCk7XG4gICAgICAgIHRoaXMuYWN0aXZpdHlFdmVudHMuZGVsZXRlKHN0YXRlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYWN0aXZpdHlFdmVudHMuZm9yRWFjaCgoc3RhdGUyKSA9PiB7XG4gICAgICAgICAgc3RhdGUyLmZvckVhY2goKHN0b3ApID0+IHN0b3AoKSk7XG4gICAgICAgICAgc3RhdGUyLmNsZWFyKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmFjdGl2aXR5RXZlbnRzLmNsZWFyKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdG8gc2VuZCBldmVudCB0byBzcGF3bmVkIGNoaWxkIG1hY2hpbmUgb3IgYWN0b3JcbiAgICAgKi9cbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwic2VuZENoaWxkXCIsIChldnQsIHRvKSA9PiB7XG4gICAgICBjb25zdCBldmVudCA9IHRvRXZlbnQoZXZ0KTtcbiAgICAgIGNvbnN0IGlkID0gcnVuSWZGbih0bywgdGhpcy5jb250ZXh0U25hcHNob3QpO1xuICAgICAgY29uc3QgY2hpbGQgPSB0aGlzLmNoaWxkcmVuLmdldChpZCk7XG4gICAgICBpZiAoIWNoaWxkKSB7XG4gICAgICAgIGludmFyaWFudChgW0B6YWctanMvY29yZV0gQ2Fubm90IHNlbmQgJyR7ZXZlbnQudHlwZX0nIGV2ZW50IHRvIHVua25vd24gY2hpbGRgKTtcbiAgICAgIH1cbiAgICAgIGNoaWxkLnNlbmQoZXZlbnQpO1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHRvIHN0b3AgYSBydW5uaW5nIGNoaWxkIG1hY2hpbmUgb3IgYWN0b3JcbiAgICAgKi9cbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwic3RvcENoaWxkXCIsIChpZCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLmNoaWxkcmVuLmhhcyhpZCkpIHtcbiAgICAgICAgaW52YXJpYW50KGBbQHphZy1qcy9jb3JlID4gc3RvcC1jaGlsZF0gQ2Fubm90IHN0b3AgdW5rbm93biBjaGlsZCAke2lkfWApO1xuICAgICAgfVxuICAgICAgdGhpcy5jaGlsZHJlbi5nZXQoaWQpLnN0b3AoKTtcbiAgICAgIHRoaXMuY2hpbGRyZW4uZGVsZXRlKGlkKTtcbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicmVtb3ZlQ2hpbGRcIiwgKGlkKSA9PiB7XG4gICAgICB0aGlzLmNoaWxkcmVuLmRlbGV0ZShpZCk7XG4gICAgfSk7XG4gICAgLy8gU3RvcCBhbmQgZGVsZXRlIHNwYXduZWQgYWN0b3JzXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInN0b3BDaGlsZHJlblwiLCAoKSA9PiB7XG4gICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goKGNoaWxkKSA9PiBjaGlsZC5zdG9wKCkpO1xuICAgICAgdGhpcy5jaGlsZHJlbi5jbGVhcigpO1xuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJzZXRQYXJlbnRcIiwgKHBhcmVudCkgPT4ge1xuICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInNwYXduXCIsIChzcmMsIGlkKSA9PiB7XG4gICAgICBjb25zdCBhY3RvciA9IHJ1bklmRm4oc3JjKTtcbiAgICAgIGlmIChpZCkgYWN0b3IuaWQgPSBpZDtcbiAgICAgIGFjdG9yLnR5cGUgPSBcIm1hY2hpbmUuYWN0b3JcIiAvKiBBY3RvciAqLztcbiAgICAgIGFjdG9yLnNldFBhcmVudCh0aGlzKTtcbiAgICAgIHRoaXMuY2hpbGRyZW4uc2V0KGFjdG9yLmlkLCBjYXN0KGFjdG9yKSk7XG4gICAgICBhY3Rvci5vbkRvbmUoKCkgPT4ge1xuICAgICAgICB0aGlzLnJlbW92ZUNoaWxkKGFjdG9yLmlkKTtcbiAgICAgIH0pLnN0YXJ0KCk7XG4gICAgICByZXR1cm4gY2FzdChyZWYoYWN0b3IpKTtcbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwic3RvcEFjdGl2aXR5XCIsIChrZXkpID0+IHtcbiAgICAgIGlmICghdGhpcy5zdGF0ZS52YWx1ZSkgcmV0dXJuO1xuICAgICAgY29uc3QgY2xlYW51cHMgPSB0aGlzLmFjdGl2aXR5RXZlbnRzLmdldCh0aGlzLnN0YXRlLnZhbHVlKTtcbiAgICAgIGNsZWFudXBzPy5nZXQoa2V5KT8uKCk7XG4gICAgICBjbGVhbnVwcz8uZGVsZXRlKGtleSk7XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImFkZEFjdGl2aXR5Q2xlYW51cFwiLCAoc3RhdGUsIGtleSwgY2xlYW51cCkgPT4ge1xuICAgICAgaWYgKCFzdGF0ZSkgcmV0dXJuO1xuICAgICAgaWYgKCF0aGlzLmFjdGl2aXR5RXZlbnRzLmhhcyhzdGF0ZSkpIHtcbiAgICAgICAgdGhpcy5hY3Rpdml0eUV2ZW50cy5zZXQoc3RhdGUsIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtba2V5LCBjbGVhbnVwXV0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYWN0aXZpdHlFdmVudHMuZ2V0KHN0YXRlKT8uc2V0KGtleSwgY2xlYW51cCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInNldFN0YXRlXCIsICh0YXJnZXQpID0+IHtcbiAgICAgIHRoaXMuc3RhdGUucHJldmlvdXNWYWx1ZSA9IHRoaXMuc3RhdGUudmFsdWU7XG4gICAgICB0aGlzLnN0YXRlLnZhbHVlID0gdGFyZ2V0O1xuICAgICAgY29uc3Qgc3RhdGVOb2RlID0gdGhpcy5nZXRTdGF0ZU5vZGUodGFyZ2V0KTtcbiAgICAgIGlmICh0YXJnZXQgPT0gbnVsbCkge1xuICAgICAgICBjbGVhcih0aGlzLnN0YXRlLnRhZ3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zdGF0ZS50YWdzID0gdG9BcnJheShzdGF0ZU5vZGU/LnRhZ3MpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFRvIHVzZWQgd2l0aGluIHNpZGUgZWZmZWN0cyBmb3IgUmVhY3Qgb3IgVnVlIHRvIHVwZGF0ZSBjb250ZXh0XG4gICAgICovXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInNldENvbnRleHRcIiwgKGNvbnRleHQpID0+IHtcbiAgICAgIGlmICghY29udGV4dCkgcmV0dXJuO1xuICAgICAgZGVlcE1lcmdlKHRoaXMuc3RhdGUuY29udGV4dCwgY29tcGFjdChjb250ZXh0KSk7XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInNldE9wdGlvbnNcIiwgKG9wdGlvbnMpID0+IHtcbiAgICAgIGNvbnN0IG9wdHMgPSBjb21wYWN0KG9wdGlvbnMpO1xuICAgICAgdGhpcy5hY3Rpb25NYXAgPSB7IC4uLnRoaXMuYWN0aW9uTWFwLCAuLi5vcHRzLmFjdGlvbnMgfTtcbiAgICAgIHRoaXMuZGVsYXlNYXAgPSB7IC4uLnRoaXMuZGVsYXlNYXAsIC4uLm9wdHMuZGVsYXlzIH07XG4gICAgICB0aGlzLmFjdGl2aXR5TWFwID0geyAuLi50aGlzLmFjdGl2aXR5TWFwLCAuLi5vcHRzLmFjdGl2aXRpZXMgfTtcbiAgICAgIHRoaXMuZ3VhcmRNYXAgPSB7IC4uLnRoaXMuZ3VhcmRNYXAsIC4uLm9wdHMuZ3VhcmRzIH07XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImdldFN0YXRlTm9kZVwiLCAoc3RhdGUpID0+IHtcbiAgICAgIGlmICghc3RhdGUpIHJldHVybjtcbiAgICAgIHJldHVybiB0aGlzLmNvbmZpZy5zdGF0ZXM/LltzdGF0ZV07XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImdldE5leHRTdGF0ZUluZm9cIiwgKHRyYW5zaXRpb25zLCBldmVudCkgPT4ge1xuICAgICAgY29uc3QgdHJhbnNpdGlvbiA9IHRoaXMuZGV0ZXJtaW5lVHJhbnNpdGlvbih0cmFuc2l0aW9ucywgZXZlbnQpO1xuICAgICAgY29uc3QgaXNUYXJnZXRsZXNzID0gIXRyYW5zaXRpb24/LnRhcmdldDtcbiAgICAgIGNvbnN0IHRhcmdldCA9IHRyYW5zaXRpb24/LnRhcmdldCA/PyB0aGlzLnN0YXRlLnZhbHVlO1xuICAgICAgY29uc3QgY2hhbmdlZCA9IHRoaXMuc3RhdGUudmFsdWUgIT09IHRhcmdldDtcbiAgICAgIGNvbnN0IHN0YXRlTm9kZSA9IHRoaXMuZ2V0U3RhdGVOb2RlKHRhcmdldCk7XG4gICAgICBjb25zdCByZWVudGVyID0gIWlzVGFyZ2V0bGVzcyAmJiAhY2hhbmdlZCAmJiAhdHJhbnNpdGlvbj8uaW50ZXJuYWw7XG4gICAgICBjb25zdCBpbmZvID0ge1xuICAgICAgICByZWVudGVyLFxuICAgICAgICB0cmFuc2l0aW9uLFxuICAgICAgICBzdGF0ZU5vZGUsXG4gICAgICAgIHRhcmdldCxcbiAgICAgICAgY2hhbmdlZFxuICAgICAgfTtcbiAgICAgIHRoaXMubG9nKFwiTmV4dFN0YXRlOlwiLCBgWyR7ZXZlbnQudHlwZX1dYCwgdGhpcy5zdGF0ZS52YWx1ZSwgXCItLS0tPlwiLCBpbmZvLnRhcmdldCk7XG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZ2V0QWZ0ZXJBY3Rpb25zXCIsICh0cmFuc2l0aW9uLCBkZWxheSkgPT4ge1xuICAgICAgbGV0IGlkO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZW50cnk6ICgpID0+IHtcbiAgICAgICAgICBpZCA9IGdsb2JhbFRoaXMuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuZXh0ID0gdGhpcy5nZXROZXh0U3RhdGVJbmZvKHRyYW5zaXRpb24sIHRoaXMuc3RhdGUuZXZlbnQpO1xuICAgICAgICAgICAgdGhpcy5wZXJmb3JtU3RhdGVDaGFuZ2VFZmZlY3RzKHRoaXMuc3RhdGUudmFsdWUsIG5leHQsIHRoaXMuc3RhdGUuZXZlbnQpO1xuICAgICAgICAgIH0sIGRlbGF5KTtcbiAgICAgICAgfSxcbiAgICAgICAgZXhpdDogKCkgPT4ge1xuICAgICAgICAgIGdsb2JhbFRoaXMuY2xlYXJUaW1lb3V0KGlkKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBBbGwgYGFmdGVyYCBldmVudHMgbGV2ZXJhZ2UgYHNldFRpbWVvdXRgIGFuZCBgY2xlYXJUaW1lb3V0YCxcbiAgICAgKiB3ZSBpbnZva2UgdGhlIGBjbGVhclRpbWVvdXRgIG9uIGV4aXQgYW5kIGBzZXRUaW1lb3V0YCBvbiBlbnRyeS5cbiAgICAgKlxuICAgICAqIFRvIGFjaGlldmUgdGhpcywgd2Ugc3BsaXQgdGhlIGBhZnRlcmAgZGVmaW50aW9uIGludG8gYGVudHJ5YCBhbmQgYGV4aXRgXG4gICAgICogIGZ1bmN0aW9ucyBhbmQgYXBwZW5kIHRoZW0gdG8gdGhlIHN0YXRlJ3MgYGVudHJ5YCBhbmQgYGV4aXRgIGFjdGlvbnNcbiAgICAgKi9cbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZ2V0RGVsYXllZEV2ZW50QWN0aW9uc1wiLCAoc3RhdGUpID0+IHtcbiAgICAgIGNvbnN0IHN0YXRlTm9kZSA9IHRoaXMuZ2V0U3RhdGVOb2RlKHN0YXRlKTtcbiAgICAgIGNvbnN0IGV2ZW50ID0gdGhpcy5zdGF0ZS5ldmVudDtcbiAgICAgIGlmICghc3RhdGVOb2RlIHx8ICFzdGF0ZU5vZGUuYWZ0ZXIpIHJldHVybjtcbiAgICAgIGNvbnN0IGVudHJpZXMgPSBbXTtcbiAgICAgIGNvbnN0IGV4aXRzID0gW107XG4gICAgICBpZiAoaXNBcnJheShzdGF0ZU5vZGUuYWZ0ZXIpKSB7XG4gICAgICAgIGNvbnN0IHRyYW5zaXRpb24gPSB0aGlzLmRldGVybWluZVRyYW5zaXRpb24oc3RhdGVOb2RlLmFmdGVyLCBldmVudCk7XG4gICAgICAgIGlmICghdHJhbnNpdGlvbikgcmV0dXJuO1xuICAgICAgICBpZiAoIWhhc1Byb3AodHJhbnNpdGlvbiwgXCJkZWxheVwiKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgW0B6YWctanMvY29yZSA+IGFmdGVyXSBEZWxheSBpcyByZXF1aXJlZCBmb3IgYWZ0ZXIgdHJhbnNpdGlvbjogJHtKU09OLnN0cmluZ2lmeSh0cmFuc2l0aW9uKX1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZXRlcm1pbmVEZWxheSA9IGRldGVybWluZURlbGF5Rm4odHJhbnNpdGlvbi5kZWxheSwgdGhpcy5kZWxheU1hcCk7XG4gICAgICAgIGNvbnN0IF9fZGVsYXkgPSBkZXRlcm1pbmVEZWxheSh0aGlzLmNvbnRleHRTbmFwc2hvdCwgZXZlbnQpO1xuICAgICAgICBjb25zdCBhY3Rpb25zID0gdGhpcy5nZXRBZnRlckFjdGlvbnModHJhbnNpdGlvbiwgX19kZWxheSk7XG4gICAgICAgIGVudHJpZXMucHVzaChhY3Rpb25zLmVudHJ5KTtcbiAgICAgICAgZXhpdHMucHVzaChhY3Rpb25zLmV4aXQpO1xuICAgICAgICByZXR1cm4geyBlbnRyaWVzLCBleGl0cyB9O1xuICAgICAgfVxuICAgICAgaWYgKGlzT2JqZWN0KHN0YXRlTm9kZS5hZnRlcikpIHtcbiAgICAgICAgZm9yIChjb25zdCBkZWxheSBpbiBzdGF0ZU5vZGUuYWZ0ZXIpIHtcbiAgICAgICAgICBjb25zdCB0cmFuc2l0aW9uID0gc3RhdGVOb2RlLmFmdGVyW2RlbGF5XTtcbiAgICAgICAgICBjb25zdCBkZXRlcm1pbmVEZWxheSA9IGRldGVybWluZURlbGF5Rm4oZGVsYXksIHRoaXMuZGVsYXlNYXApO1xuICAgICAgICAgIGNvbnN0IF9fZGVsYXkgPSBkZXRlcm1pbmVEZWxheSh0aGlzLmNvbnRleHRTbmFwc2hvdCwgZXZlbnQpO1xuICAgICAgICAgIGNvbnN0IGFjdGlvbnMgPSB0aGlzLmdldEFmdGVyQWN0aW9ucyh0cmFuc2l0aW9uLCBfX2RlbGF5KTtcbiAgICAgICAgICBlbnRyaWVzLnB1c2goYWN0aW9ucy5lbnRyeSk7XG4gICAgICAgICAgZXhpdHMucHVzaChhY3Rpb25zLmV4aXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4geyBlbnRyaWVzLCBleGl0cyB9O1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHRvIGV4ZWN1dGVzIGRlZmluZWQgYWN0aW9ucy4gSXQgY2FuIGFjY2VwdCBhY3Rpb25zIGFzIHN0cmluZ1xuICAgICAqIChyZWZlcmVuY2luZyBgb3B0aW9ucy5hY3Rpb25zYCkgb3IgYWN0dWFsIGZ1bmN0aW9ucy5cbiAgICAgKi9cbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZXhlY3V0ZUFjdGlvbnNcIiwgKGFjdGlvbnMsIGV2ZW50KSA9PiB7XG4gICAgICBjb25zdCBwaWNrZWRBY3Rpb25zID0gZGV0ZXJtaW5lQWN0aW9uc0ZuKGFjdGlvbnMsIHRoaXMuZ3VhcmRNYXApKHRoaXMuY29udGV4dFNuYXBzaG90LCBldmVudCwgdGhpcy5ndWFyZE1ldGEpO1xuICAgICAgZm9yIChjb25zdCBhY3Rpb24gb2YgdG9BcnJheShwaWNrZWRBY3Rpb25zKSkge1xuICAgICAgICBjb25zdCBmbiA9IGlzU3RyaW5nKGFjdGlvbikgPyB0aGlzLmFjdGlvbk1hcD8uW2FjdGlvbl0gOiBhY3Rpb247XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgaXNTdHJpbmcoYWN0aW9uKSAmJiAhZm4sXG4gICAgICAgICAgYFtAemFnLWpzL2NvcmUgPiBleGVjdXRlLWFjdGlvbnNdIE5vIGltcGxlbWVudGF0aW9uIGZvdW5kIGZvciBhY3Rpb246IFxcYCR7YWN0aW9ufVxcYGBcbiAgICAgICAgKTtcbiAgICAgICAgZm4/Lih0aGlzLnN0YXRlLmNvbnRleHQsIGV2ZW50LCB0aGlzLm1ldGEpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgcnVubmluZyBhY3Rpdml0aWVzIGFuZCByZWdpc3RlcnNcbiAgICAgKiB0aGVpciBjbGVhbnVwIGZ1bmN0aW9uIGludGVybmFsbHkgKHRvIGJlIGNhbGxlZCBsYXRlciBvbiB3aGVuIHdlIGV4aXQgdGhlIHN0YXRlKVxuICAgICAqL1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJleGVjdXRlQWN0aXZpdGllc1wiLCAoZXZlbnQsIGFjdGl2aXRpZXMsIHN0YXRlKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGFjdGl2aXR5IG9mIGFjdGl2aXRpZXMpIHtcbiAgICAgICAgY29uc3QgZm4gPSBpc1N0cmluZyhhY3Rpdml0eSkgPyB0aGlzLmFjdGl2aXR5TWFwPy5bYWN0aXZpdHldIDogYWN0aXZpdHk7XG4gICAgICAgIGlmICghZm4pIHtcbiAgICAgICAgICB3YXJuKGBbQHphZy1qcy9jb3JlID4gZXhlY3V0ZS1hY3Rpdml0eV0gTm8gaW1wbGVtZW50YXRpb24gZm91bmQgZm9yIGFjdGl2aXR5OiBcXGAke2FjdGl2aXR5fVxcYGApO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNsZWFudXAgPSBmbih0aGlzLnN0YXRlLmNvbnRleHQsIGV2ZW50LCB0aGlzLm1ldGEpO1xuICAgICAgICBpZiAoY2xlYW51cCkge1xuICAgICAgICAgIGNvbnN0IGtleSA9IGlzU3RyaW5nKGFjdGl2aXR5KSA/IGFjdGl2aXR5IDogYWN0aXZpdHkubmFtZSB8fCB1dWlkKCk7XG4gICAgICAgICAgdGhpcy5hZGRBY3Rpdml0eUNsZWFudXAoc3RhdGUgPz8gdGhpcy5zdGF0ZS52YWx1ZSwga2V5LCBjbGVhbnVwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIE5vcm1hbGl6ZXMgdGhlIGBldmVyeWAgZGVmaW5pdGlvbiB0byB0cmFuc2l0aW9uLiBgZXZlcnlgIGNhbiBiZTpcbiAgICAgKiAtIEFuIGFycmF5IG9mIHBvc3NpYmxlIGFjdGlvbnMgdG8gcnVuICh3ZSBuZWVkIHRvIHBpY2sgdGhlIGZpcnN0IG1hdGNoIGJhc2VkIG9uIGd1YXJkKVxuICAgICAqIC0gQW4gb2JqZWN0IG9mIGludGVydmFscyBhbmQgYWN0aW9uc1xuICAgICAqL1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJjcmVhdGVFdmVyeUFjdGl2aXRpZXNcIiwgKGV2ZXJ5LCBjYWxsYmFja2ZuKSA9PiB7XG4gICAgICBpZiAoIWV2ZXJ5KSByZXR1cm47XG4gICAgICBpZiAoaXNBcnJheShldmVyeSkpIHtcbiAgICAgICAgY29uc3QgcGlja2VkID0gdG9BcnJheShldmVyeSkuZmluZCgodHJhbnNpdGlvbikgPT4ge1xuICAgICAgICAgIGNvbnN0IGRlbGF5T3JGbiA9IHRyYW5zaXRpb24uZGVsYXk7XG4gICAgICAgICAgY29uc3QgZGV0ZXJtaW5lRGVsYXkyID0gZGV0ZXJtaW5lRGVsYXlGbihkZWxheU9yRm4sIHRoaXMuZGVsYXlNYXApO1xuICAgICAgICAgIGNvbnN0IGRlbGF5MiA9IGRldGVybWluZURlbGF5Mih0aGlzLmNvbnRleHRTbmFwc2hvdCwgdGhpcy5zdGF0ZS5ldmVudCk7XG4gICAgICAgICAgY29uc3QgZGV0ZXJtaW5lR3VhcmQgPSBkZXRlcm1pbmVHdWFyZEZuKHRyYW5zaXRpb24uZ3VhcmQsIHRoaXMuZ3VhcmRNYXApO1xuICAgICAgICAgIGNvbnN0IGd1YXJkID0gZGV0ZXJtaW5lR3VhcmQodGhpcy5jb250ZXh0U25hcHNob3QsIHRoaXMuc3RhdGUuZXZlbnQsIHRoaXMuZ3VhcmRNZXRhKTtcbiAgICAgICAgICByZXR1cm4gZ3VhcmQgPz8gZGVsYXkyICE9IG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXBpY2tlZCkgcmV0dXJuO1xuICAgICAgICBjb25zdCBkZXRlcm1pbmVEZWxheSA9IGRldGVybWluZURlbGF5Rm4ocGlja2VkLmRlbGF5LCB0aGlzLmRlbGF5TWFwKTtcbiAgICAgICAgY29uc3QgZGVsYXkgPSBkZXRlcm1pbmVEZWxheSh0aGlzLmNvbnRleHRTbmFwc2hvdCwgdGhpcy5zdGF0ZS5ldmVudCk7XG4gICAgICAgIGNvbnN0IGFjdGl2aXR5ID0gKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGlkID0gZ2xvYmFsVGhpcy5zZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmV4ZWN1dGVBY3Rpb25zKHBpY2tlZC5hY3Rpb25zLCB0aGlzLnN0YXRlLmV2ZW50KTtcbiAgICAgICAgICB9LCBkZWxheSk7XG4gICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGdsb2JhbFRoaXMuY2xlYXJJbnRlcnZhbChpZCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgY2FsbGJhY2tmbihhY3Rpdml0eSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGNvbnN0IGludGVydmFsIGluIGV2ZXJ5KSB7XG4gICAgICAgICAgY29uc3QgYWN0aW9ucyA9IGV2ZXJ5Py5baW50ZXJ2YWxdO1xuICAgICAgICAgIGNvbnN0IGRldGVybWluZURlbGF5ID0gZGV0ZXJtaW5lRGVsYXlGbihpbnRlcnZhbCwgdGhpcy5kZWxheU1hcCk7XG4gICAgICAgICAgY29uc3QgZGVsYXkgPSBkZXRlcm1pbmVEZWxheSh0aGlzLmNvbnRleHRTbmFwc2hvdCwgdGhpcy5zdGF0ZS5ldmVudCk7XG4gICAgICAgICAgY29uc3QgYWN0aXZpdHkgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpZCA9IGdsb2JhbFRoaXMuc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLmV4ZWN1dGVBY3Rpb25zKGFjdGlvbnMsIHRoaXMuc3RhdGUuZXZlbnQpO1xuICAgICAgICAgICAgfSwgZGVsYXkpO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgZ2xvYmFsVGhpcy5jbGVhckludGVydmFsKGlkKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfTtcbiAgICAgICAgICBjYWxsYmFja2ZuKGFjdGl2aXR5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJzZXRFdmVudFwiLCAoZXZlbnQpID0+IHtcbiAgICAgIHRoaXMuc3RhdGUucHJldmlvdXNFdmVudCA9IHRoaXMuc3RhdGUuZXZlbnQ7XG4gICAgICB0aGlzLnN0YXRlLmV2ZW50ID0gcmVmKHRvRXZlbnQoZXZlbnQpKTtcbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicGVyZm9ybUV4aXRFZmZlY3RzXCIsIChjdXJyZW50LCBldmVudCkgPT4ge1xuICAgICAgY29uc3QgY3VycmVudFN0YXRlID0gdGhpcy5zdGF0ZS52YWx1ZTtcbiAgICAgIGlmIChjdXJyZW50U3RhdGUgPT09IFwiXCIpIHJldHVybjtcbiAgICAgIGNvbnN0IHN0YXRlTm9kZSA9IGN1cnJlbnQgPyB0aGlzLmdldFN0YXRlTm9kZShjdXJyZW50KSA6IHZvaWQgMDtcbiAgICAgIHRoaXMuc3RvcEFjdGl2aXRpZXMoY3VycmVudFN0YXRlKTtcbiAgICAgIGNvbnN0IF9leGl0ID0gZGV0ZXJtaW5lQWN0aW9uc0ZuKHN0YXRlTm9kZT8uZXhpdCwgdGhpcy5ndWFyZE1hcCkodGhpcy5jb250ZXh0U25hcHNob3QsIGV2ZW50LCB0aGlzLmd1YXJkTWV0YSk7XG4gICAgICBjb25zdCBleGl0QWN0aW9ucyA9IHRvQXJyYXkoX2V4aXQpO1xuICAgICAgY29uc3QgYWZ0ZXJFeGl0QWN0aW9ucyA9IHRoaXMuZGVsYXllZEV2ZW50cy5nZXQoY3VycmVudFN0YXRlKTtcbiAgICAgIGlmIChhZnRlckV4aXRBY3Rpb25zKSB7XG4gICAgICAgIGV4aXRBY3Rpb25zLnB1c2goLi4uYWZ0ZXJFeGl0QWN0aW9ucyk7XG4gICAgICB9XG4gICAgICB0aGlzLmV4ZWN1dGVBY3Rpb25zKGV4aXRBY3Rpb25zLCBldmVudCk7XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInBlcmZvcm1FbnRyeUVmZmVjdHNcIiwgKG5leHQsIGV2ZW50KSA9PiB7XG4gICAgICBjb25zdCBzdGF0ZU5vZGUgPSB0aGlzLmdldFN0YXRlTm9kZShuZXh0KTtcbiAgICAgIGNvbnN0IGFjdGl2aXRpZXMgPSB0b0FycmF5KHN0YXRlTm9kZT8uYWN0aXZpdGllcyk7XG4gICAgICB0aGlzLmNyZWF0ZUV2ZXJ5QWN0aXZpdGllcyhzdGF0ZU5vZGU/LmV2ZXJ5LCAoYWN0aXZpdHkpID0+IHtcbiAgICAgICAgYWN0aXZpdGllcy51bnNoaWZ0KGFjdGl2aXR5KTtcbiAgICAgIH0pO1xuICAgICAgaWYgKGFjdGl2aXRpZXMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLmV4ZWN1dGVBY3Rpdml0aWVzKGV2ZW50LCBhY3Rpdml0aWVzKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBpY2tlZEFjdGlvbnMgPSBkZXRlcm1pbmVBY3Rpb25zRm4oc3RhdGVOb2RlPy5lbnRyeSwgdGhpcy5ndWFyZE1hcCkoXG4gICAgICAgIHRoaXMuY29udGV4dFNuYXBzaG90LFxuICAgICAgICBldmVudCxcbiAgICAgICAgdGhpcy5ndWFyZE1ldGFcbiAgICAgICk7XG4gICAgICBjb25zdCBlbnRyeUFjdGlvbnMgPSB0b0FycmF5KHBpY2tlZEFjdGlvbnMpO1xuICAgICAgY29uc3QgYWZ0ZXJBY3Rpb25zID0gdGhpcy5nZXREZWxheWVkRXZlbnRBY3Rpb25zKG5leHQpO1xuICAgICAgaWYgKHN0YXRlTm9kZT8uYWZ0ZXIgJiYgYWZ0ZXJBY3Rpb25zKSB7XG4gICAgICAgIHRoaXMuZGVsYXllZEV2ZW50cy5zZXQobmV4dCwgYWZ0ZXJBY3Rpb25zPy5leGl0cyk7XG4gICAgICAgIGVudHJ5QWN0aW9ucy5wdXNoKC4uLmFmdGVyQWN0aW9ucy5lbnRyaWVzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZXhlY3V0ZUFjdGlvbnMoZW50cnlBY3Rpb25zLCBldmVudCk7XG4gICAgICBpZiAoc3RhdGVOb2RlPy50eXBlID09PSBcImZpbmFsXCIpIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5kb25lID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kb25lTGlzdGVuZXJzLmZvckVhY2goKGxpc3RlbmVyKSA9PiB7XG4gICAgICAgICAgbGlzdGVuZXIodGhpcy5zdGF0ZVNuYXBzaG90KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJwZXJmb3JtVHJhbnNpdGlvbkVmZmVjdHNcIiwgKHRyYW5zaXRpb25zLCBldmVudCkgPT4ge1xuICAgICAgY29uc3QgdHJhbnNpdGlvbiA9IHRoaXMuZGV0ZXJtaW5lVHJhbnNpdGlvbih0cmFuc2l0aW9ucywgZXZlbnQpO1xuICAgICAgdGhpcy5leGVjdXRlQWN0aW9ucyh0cmFuc2l0aW9uPy5hY3Rpb25zLCBldmVudCk7XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYWxsIHRoZSByZXF1aXJlcyBzaWRlLWVmZmVjdHMgb3IgcmVhY3Rpb25zIHdoZW5cbiAgICAgKiB3ZSBtb3ZlIGZyb20gc3RhdGUgQSA9PiBzdGF0ZSBCLlxuICAgICAqXG4gICAgICogVGhlIEVmZmVjdCBvcmRlcjpcbiAgICAgKiBFeGl0IGFjdGlvbnMgKGN1cnJlbnQgc3RhdGUpID0+IFRyYW5zaXRpb24gYWN0aW9ucyAgPT4gR28gdG8gc3RhdGUgPT4gRW50cnkgYWN0aW9ucyAobmV4dCBzdGF0ZSlcbiAgICAgKi9cbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicGVyZm9ybVN0YXRlQ2hhbmdlRWZmZWN0c1wiLCAoY3VycmVudCwgbmV4dCwgZXZlbnQpID0+IHtcbiAgICAgIHRoaXMuc2V0RXZlbnQoZXZlbnQpO1xuICAgICAgY29uc3QgY2hhbmdlZCA9IG5leHQuY2hhbmdlZCB8fCBuZXh0LnJlZW50ZXI7XG4gICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICB0aGlzLnBlcmZvcm1FeGl0RWZmZWN0cyhjdXJyZW50LCBldmVudCk7XG4gICAgICB9XG4gICAgICB0aGlzLnBlcmZvcm1UcmFuc2l0aW9uRWZmZWN0cyhuZXh0LnRyYW5zaXRpb24sIGV2ZW50KTtcbiAgICAgIHRoaXMuc2V0U3RhdGUobmV4dC50YXJnZXQpO1xuICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgdGhpcy5wZXJmb3JtRW50cnlFZmZlY3RzKG5leHQudGFyZ2V0LCBldmVudCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImRldGVybWluZVRyYW5zaXRpb25cIiwgKHRyYW5zaXRpb24sIGV2ZW50KSA9PiB7XG4gICAgICBjb25zdCBmbiA9IGRldGVybWluZVRyYW5zaXRpb25Gbih0cmFuc2l0aW9uLCB0aGlzLmd1YXJkTWFwKTtcbiAgICAgIHJldHVybiBmbj8uKHRoaXMuY29udGV4dFNuYXBzaG90LCBldmVudCwgdGhpcy5ndWFyZE1ldGEpO1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHRvIHNlbmQgZXZlbnQgdG8gcGFyZW50IG1hY2hpbmUgZnJvbSBzcGF3bmVkIGNoaWxkXG4gICAgICovXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInNlbmRQYXJlbnRcIiwgKGV2dCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgICBpbnZhcmlhbnQoXCJbQHphZy1qcy9jb3JlID4gc2VuZC1wYXJlbnRdIENhbm5vdCBzZW5kIGV2ZW50IHRvIGFuIHVua25vd24gcGFyZW50XCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgZXZlbnQgPSB0b0V2ZW50KGV2dCk7XG4gICAgICB0aGlzLnBhcmVudD8uc2VuZChldmVudCk7XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImxvZ1wiLCAoLi4uYXJncykgPT4ge1xuICAgICAgaWYgKGlzRGV2KCkgJiYgdGhpcy5vcHRpb25zLmRlYnVnKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKC4uLmFyZ3MpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHRvIHNlbmQgYW4gZXZlbnQgdG8gY3VycmVudCBtYWNoaW5lXG4gICAgICovXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInNlbmRcIiwgKGV2dCkgPT4ge1xuICAgICAgY29uc3QgZXZlbnQgPSB0b0V2ZW50KGV2dCk7XG4gICAgICB0aGlzLnRyYW5zaXRpb24odGhpcy5zdGF0ZS52YWx1ZSwgZXZlbnQpO1xuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ0cmFuc2l0aW9uXCIsIChzdGF0ZSwgZXZ0KSA9PiB7XG4gICAgICBjb25zdCBzdGF0ZU5vZGUgPSBpc1N0cmluZyhzdGF0ZSkgPyB0aGlzLmdldFN0YXRlTm9kZShzdGF0ZSkgOiBzdGF0ZT8uc3RhdGVOb2RlO1xuICAgICAgY29uc3QgZXZlbnQgPSB0b0V2ZW50KGV2dCk7XG4gICAgICBpZiAoIXN0YXRlTm9kZSAmJiAhdGhpcy5jb25maWcub24pIHtcbiAgICAgICAgY29uc3QgbXNnID0gdGhpcy5zdGF0dXMgPT09IFwiU3RvcHBlZFwiIC8qIFN0b3BwZWQgKi8gPyBcIltAemFnLWpzL2NvcmUgPiB0cmFuc2l0aW9uXSBDYW5ub3QgdHJhbnNpdGlvbiBhIHN0b3BwZWQgbWFjaGluZVwiIDogYFtAemFnLWpzL2NvcmUgPiB0cmFuc2l0aW9uXSBTdGF0ZSBkb2VzIG5vdCBoYXZlIGEgZGVmaW5pdGlvbiBmb3IgXFxgc3RhdGVcXGA6ICR7c3RhdGV9LCBcXGBldmVudFxcYDogJHtldmVudC50eXBlfWA7XG4gICAgICAgIHdhcm4obXNnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgdHJhbnNpdGlvbnMgPSAoXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLSBGaXggdGhpc1xuICAgICAgICBzdGF0ZU5vZGU/Lm9uPy5bZXZlbnQudHlwZV0gPz8gdGhpcy5jb25maWcub24/LltldmVudC50eXBlXVxuICAgICAgKTtcbiAgICAgIGNvbnN0IG5leHQgPSB0aGlzLmdldE5leHRTdGF0ZUluZm8odHJhbnNpdGlvbnMsIGV2ZW50KTtcbiAgICAgIHRoaXMucGVyZm9ybVN0YXRlQ2hhbmdlRWZmZWN0cyh0aGlzLnN0YXRlLnZhbHVlLCBuZXh0LCBldmVudCk7XG4gICAgICByZXR1cm4gbmV4dC5zdGF0ZU5vZGU7XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInN1YnNjcmliZVwiLCAobGlzdGVuZXIpID0+IHtcbiAgICAgIHRoaXMuc3RhdGVMaXN0ZW5lcnMuYWRkKGxpc3RlbmVyKTtcbiAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gXCJSdW5uaW5nXCIgLyogUnVubmluZyAqLykge1xuICAgICAgICBsaXN0ZW5lcih0aGlzLnN0YXRlU25hcHNob3QpO1xuICAgICAgfVxuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgdGhpcy5zdGF0ZUxpc3RlbmVycy5kZWxldGUobGlzdGVuZXIpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwib25Eb25lXCIsIChsaXN0ZW5lcikgPT4ge1xuICAgICAgdGhpcy5kb25lTGlzdGVuZXJzLmFkZChsaXN0ZW5lcik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwib25UcmFuc2l0aW9uXCIsIChsaXN0ZW5lcikgPT4ge1xuICAgICAgdGhpcy5zdGF0ZUxpc3RlbmVycy5hZGQobGlzdGVuZXIpO1xuICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSBcIlJ1bm5pbmdcIiAvKiBSdW5uaW5nICovKSB7XG4gICAgICAgIGxpc3RlbmVyKHRoaXMuc3RhdGVTbmFwc2hvdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9KTtcbiAgICB0aGlzLmNvbmZpZyA9IHN0cnVjdHVyZWRDbG9uZShjb25maWcpO1xuICAgIHRoaXMub3B0aW9ucyA9IHN0cnVjdHVyZWRDbG9uZShvcHRpb25zID8/IHt9KTtcbiAgICB0aGlzLmlkID0gdGhpcy5jb25maWcuaWQgPz8gYG1hY2hpbmUtJHt1dWlkKCl9YDtcbiAgICB0aGlzLmd1YXJkTWFwID0gdGhpcy5vcHRpb25zPy5ndWFyZHMgPz8ge307XG4gICAgdGhpcy5hY3Rpb25NYXAgPSB0aGlzLm9wdGlvbnM/LmFjdGlvbnMgPz8ge307XG4gICAgdGhpcy5kZWxheU1hcCA9IHRoaXMub3B0aW9ucz8uZGVsYXlzID8/IHt9O1xuICAgIHRoaXMuYWN0aXZpdHlNYXAgPSB0aGlzLm9wdGlvbnM/LmFjdGl2aXRpZXMgPz8ge307XG4gICAgdGhpcy5zeW5jID0gdGhpcy5vcHRpb25zPy5zeW5jID8/IGZhbHNlO1xuICAgIHRoaXMuc3RhdGUgPSBjcmVhdGVQcm94eSh0aGlzLmNvbmZpZyk7XG4gICAgdGhpcy5pbml0aWFsQ29udGV4dCA9IHNuYXBzaG90KHRoaXMuc3RhdGUuY29udGV4dCk7XG4gIH1cbiAgLy8gaW1tdXRhYmxlIHN0YXRlIHZhbHVlXG4gIGdldCBzdGF0ZVNuYXBzaG90KCkge1xuICAgIHJldHVybiBjYXN0KHNuYXBzaG90KHRoaXMuc3RhdGUpKTtcbiAgfVxuICBnZXRTdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZVNuYXBzaG90O1xuICB9XG4gIC8vIGltbXV0YWJsZSBjb250ZXh0IHZhbHVlXG4gIGdldCBjb250ZXh0U25hcHNob3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGVTbmFwc2hvdC5jb250ZXh0O1xuICB9XG4gIC8qKlxuICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgaW5zdGFuY2UgbWV0aG9kcyBvZiB0aGUgbWFjaGluZS5cbiAgICogVXNlZnVsIHdoZW4gc3Bhd25pbmcgY2hpbGQgbWFjaGluZXMgYW5kIG1hbmFnaW5nIHRoZSBjb21tdW5pY2F0aW9uIGJldHdlZW4gdGhlbS5cbiAgICovXG4gIGdldCBzZWxmKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiB7XG4gICAgICBpZDogdGhpcy5pZCxcbiAgICAgIHNlbmQ6IHRoaXMuc2VuZC5iaW5kKHRoaXMpLFxuICAgICAgc2VuZFBhcmVudDogdGhpcy5zZW5kUGFyZW50LmJpbmQodGhpcyksXG4gICAgICBzZW5kQ2hpbGQ6IHRoaXMuc2VuZENoaWxkLmJpbmQodGhpcyksXG4gICAgICBzdG9wOiB0aGlzLnN0b3AuYmluZCh0aGlzKSxcbiAgICAgIHN0b3BDaGlsZDogdGhpcy5zdG9wQ2hpbGQuYmluZCh0aGlzKSxcbiAgICAgIHNwYXduOiB0aGlzLnNwYXduLmJpbmQodGhpcyksXG4gICAgICBzdG9wQWN0aXZpdHk6IHRoaXMuc3RvcEFjdGl2aXR5LmJpbmQodGhpcyksXG4gICAgICBnZXQgc3RhdGUoKSB7XG4gICAgICAgIHJldHVybiBzZWxmLnN0YXRlU25hcHNob3Q7XG4gICAgICB9LFxuICAgICAgZ2V0IGluaXRpYWxDb250ZXh0KCkge1xuICAgICAgICByZXR1cm4gc2VsZi5pbml0aWFsQ29udGV4dDtcbiAgICAgIH0sXG4gICAgICBnZXQgaW5pdGlhbFN0YXRlKCkge1xuICAgICAgICByZXR1cm4gc2VsZi5pbml0aWFsU3RhdGU/LnRhcmdldCA/PyBcIlwiO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZ2V0IG1ldGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXRlOiB0aGlzLnN0YXRlU25hcHNob3QsXG4gICAgICBndWFyZHM6IHRoaXMuZ3VhcmRNYXAsXG4gICAgICBzZW5kOiB0aGlzLnNlbmQuYmluZCh0aGlzKSxcbiAgICAgIHNlbGY6IHRoaXMuc2VsZixcbiAgICAgIGluaXRpYWxDb250ZXh0OiB0aGlzLmluaXRpYWxDb250ZXh0LFxuICAgICAgaW5pdGlhbFN0YXRlOiB0aGlzLmluaXRpYWxTdGF0ZT8udGFyZ2V0ID8/IFwiXCIsXG4gICAgICBnZXRTdGF0ZTogKCkgPT4gdGhpcy5zdGF0ZVNuYXBzaG90LFxuICAgICAgZ2V0QWN0aW9uOiAoa2V5KSA9PiB0aGlzLmFjdGlvbk1hcFtrZXldLFxuICAgICAgZ2V0R3VhcmQ6IChrZXkpID0+IHRoaXMuZ3VhcmRNYXBba2V5XVxuICAgIH07XG4gIH1cbiAgZ2V0IGd1YXJkTWV0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhdGU6IHRoaXMuc3RhdGVTbmFwc2hvdFxuICAgIH07XG4gIH1cbiAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuICAgIHJldHVybiBcIk1hY2hpbmVcIjtcbiAgfVxuICBnZXRIeWRyYXRpb25TdGF0ZSgpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuZ2V0U3RhdGUoKTtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IHN0YXRlLnZhbHVlLFxuICAgICAgdGFnczogc3RhdGUudGFnc1xuICAgIH07XG4gIH1cbn07XG52YXIgY3JlYXRlTWFjaGluZSA9IChjb25maWcsIG9wdGlvbnMpID0+IG5ldyBNYWNoaW5lKGNvbmZpZywgb3B0aW9ucyk7XG52YXIgaXNNYWNoaW5lID0gKHZhbHVlKSA9PiB7XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIE1hY2hpbmUgfHwgdmFsdWU/LnR5cGUgPT09IFwibWFjaGluZVwiIC8qIE1hY2hpbmUgKi87XG59O1xuXG4vLyBzcmMvbWVyZ2UtcHJvcHMudHNcbnZhciBjbHN4ID0gKC4uLmFyZ3MpID0+IGFyZ3MubWFwKChzdHIpID0+IHN0cj8udHJpbT8uKCkpLmZpbHRlcihCb29sZWFuKS5qb2luKFwiIFwiKTtcbnZhciBDU1NfUkVHRVggPSAvKCg/Oi0tKT8oPzpcXHcrLT8pKylcXHMqOlxccyooW147XSopL2c7XG52YXIgc2VyaWFsaXplID0gKHN0eWxlKSA9PiB7XG4gIGNvbnN0IHJlcyA9IHt9O1xuICBsZXQgbWF0Y2g7XG4gIHdoaWxlIChtYXRjaCA9IENTU19SRUdFWC5leGVjKHN0eWxlKSkge1xuICAgIHJlc1ttYXRjaFsxXV0gPSBtYXRjaFsyXTtcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcbnZhciBjc3MgPSAoYSwgYikgPT4ge1xuICBpZiAoaXNTdHJpbmcoYSkpIHtcbiAgICBpZiAoaXNTdHJpbmcoYikpIHJldHVybiBgJHthfTske2J9YDtcbiAgICBhID0gc2VyaWFsaXplKGEpO1xuICB9IGVsc2UgaWYgKGlzU3RyaW5nKGIpKSB7XG4gICAgYiA9IHNlcmlhbGl6ZShiKTtcbiAgfVxuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgYSA/PyB7fSwgYiA/PyB7fSk7XG59O1xuZnVuY3Rpb24gbWVyZ2VQcm9wcyguLi5hcmdzKSB7XG4gIGxldCByZXN1bHQgPSB7fTtcbiAgZm9yIChsZXQgcHJvcHMgb2YgYXJncykge1xuICAgIGZvciAobGV0IGtleSBpbiByZXN1bHQpIHtcbiAgICAgIGlmIChrZXkuc3RhcnRzV2l0aChcIm9uXCIpICYmIHR5cGVvZiByZXN1bHRba2V5XSA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBwcm9wc1trZXldID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmVzdWx0W2tleV0gPSBjYWxsQWxsKHByb3BzW2tleV0sIHJlc3VsdFtrZXldKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoa2V5ID09PSBcImNsYXNzTmFtZVwiIHx8IGtleSA9PT0gXCJjbGFzc1wiKSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gY2xzeChyZXN1bHRba2V5XSwgcHJvcHNba2V5XSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGtleSA9PT0gXCJzdHlsZVwiKSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gY3NzKHJlc3VsdFtrZXldLCBwcm9wc1trZXldKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICByZXN1bHRba2V5XSA9IHByb3BzW2tleV0gIT09IHZvaWQgMCA/IHByb3BzW2tleV0gOiByZXN1bHRba2V5XTtcbiAgICB9XG4gICAgZm9yIChsZXQga2V5IGluIHByb3BzKSB7XG4gICAgICBpZiAocmVzdWx0W2tleV0gPT09IHZvaWQgMCkge1xuICAgICAgICByZXN1bHRba2V5XSA9IHByb3BzW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnQge1xuICBNYWNoaW5lLFxuICBjaG9vc2UsXG4gIGNyZWF0ZU1hY2hpbmUsXG4gIGRlZXBNZXJnZSxcbiAgZ3VhcmRzLFxuICBpc01hY2hpbmUsXG4gIG1lcmdlUHJvcHMsXG4gIHByb3h5MiBhcyBwcm94eSxcbiAgcmVmMiBhcyByZWYsXG4gIHNuYXBzaG90MiBhcyBzbmFwc2hvdCxcbiAgc3Vic2NyaWJlMiBhcyBzdWJzY3JpYmVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@zag-js/core/dist/index.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@zag-js/store/dist/index.mjs":
/*!***************************************************!*\
  !*** ./node_modules/@zag-js/store/dist/index.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   makeGlobal: () => (/* binding */ makeGlobal),\n/* harmony export */   proxy: () => (/* binding */ proxy),\n/* harmony export */   proxyWithComputed: () => (/* binding */ proxyWithComputed),\n/* harmony export */   ref: () => (/* binding */ ref),\n/* harmony export */   snapshot: () => (/* binding */ snapshot),\n/* harmony export */   subscribe: () => (/* binding */ subscribe)\n/* harmony export */ });\n/* harmony import */ var proxy_compare__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! proxy-compare */ \"(rsc)/./node_modules/proxy-compare/dist/index.js\");\n// src/global.ts\nfunction getGlobal() {\n  if (typeof globalThis !== \"undefined\") return globalThis;\n  if (typeof self !== \"undefined\") return self;\n  if (typeof window !== \"undefined\") return window;\n  if (typeof global !== \"undefined\") return global;\n}\nfunction makeGlobal(key, value) {\n  const g = getGlobal();\n  if (!g) return value();\n  g[key] || (g[key] = value());\n  return g[key];\n}\n\n// src/proxy.ts\n\nvar isDev = () => \"development\" !== \"production\";\nvar isObject = (x) => typeof x === \"object\" && x !== null;\nvar proxyStateMap = makeGlobal(\"__zag__proxyStateMap\", () => /* @__PURE__ */ new WeakMap());\nvar refSet = makeGlobal(\"__zag__refSet\", () => /* @__PURE__ */ new WeakSet());\nvar buildProxyFunction = (objectIs = Object.is, newProxy = (target, handler) => new Proxy(target, handler), canProxy = (x) => isObject(x) && !refSet.has(x) && (Array.isArray(x) || !(Symbol.iterator in x)) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer), defaultHandlePromise = (promise) => {\n  switch (promise.status) {\n    case \"fulfilled\":\n      return promise.value;\n    case \"rejected\":\n      throw promise.reason;\n    default:\n      throw promise;\n  }\n}, snapCache = /* @__PURE__ */ new WeakMap(), createSnapshot = (target, version, handlePromise = defaultHandlePromise) => {\n  const cache = snapCache.get(target);\n  if (cache?.[0] === version) {\n    return cache[1];\n  }\n  const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));\n  (0,proxy_compare__WEBPACK_IMPORTED_MODULE_0__.markToTrack)(snap, true);\n  snapCache.set(target, [version, snap]);\n  Reflect.ownKeys(target).forEach((key) => {\n    const value = Reflect.get(target, key);\n    if (refSet.has(value)) {\n      (0,proxy_compare__WEBPACK_IMPORTED_MODULE_0__.markToTrack)(value, false);\n      snap[key] = value;\n    } else if (value instanceof Promise) {\n      Object.defineProperty(snap, key, {\n        get() {\n          return handlePromise(value);\n        }\n      });\n    } else if (proxyStateMap.has(value)) {\n      snap[key] = snapshot(value, handlePromise);\n    } else {\n      snap[key] = value;\n    }\n  });\n  return Object.freeze(snap);\n}, proxyCache = /* @__PURE__ */ new WeakMap(), versionHolder = [1, 1], proxyFunction2 = (initialObject) => {\n  if (!isObject(initialObject)) {\n    throw new Error(\"object required\");\n  }\n  const found = proxyCache.get(initialObject);\n  if (found) {\n    return found;\n  }\n  let version = versionHolder[0];\n  const listeners = /* @__PURE__ */ new Set();\n  const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {\n    if (version !== nextVersion) {\n      version = nextVersion;\n      listeners.forEach((listener) => listener(op, nextVersion));\n    }\n  };\n  let checkVersion = versionHolder[1];\n  const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {\n    if (checkVersion !== nextCheckVersion && !listeners.size) {\n      checkVersion = nextCheckVersion;\n      propProxyStates.forEach(([propProxyState]) => {\n        const propVersion = propProxyState[1](nextCheckVersion);\n        if (propVersion > version) {\n          version = propVersion;\n        }\n      });\n    }\n    return version;\n  };\n  const createPropListener = (prop) => (op, nextVersion) => {\n    const newOp = [...op];\n    newOp[1] = [prop, ...newOp[1]];\n    notifyUpdate(newOp, nextVersion);\n  };\n  const propProxyStates = /* @__PURE__ */ new Map();\n  const addPropListener = (prop, propProxyState) => {\n    if (isDev() && propProxyStates.has(prop)) {\n      throw new Error(\"prop listener already exists\");\n    }\n    if (listeners.size) {\n      const remove = propProxyState[3](createPropListener(prop));\n      propProxyStates.set(prop, [propProxyState, remove]);\n    } else {\n      propProxyStates.set(prop, [propProxyState]);\n    }\n  };\n  const removePropListener = (prop) => {\n    const entry = propProxyStates.get(prop);\n    if (entry) {\n      propProxyStates.delete(prop);\n      entry[1]?.();\n    }\n  };\n  const addListener = (listener) => {\n    listeners.add(listener);\n    if (listeners.size === 1) {\n      propProxyStates.forEach(([propProxyState, prevRemove], prop) => {\n        if (isDev() && prevRemove) {\n          throw new Error(\"remove already exists\");\n        }\n        const remove = propProxyState[3](createPropListener(prop));\n        propProxyStates.set(prop, [propProxyState, remove]);\n      });\n    }\n    const removeListener = () => {\n      listeners.delete(listener);\n      if (listeners.size === 0) {\n        propProxyStates.forEach(([propProxyState, remove], prop) => {\n          if (remove) {\n            remove();\n            propProxyStates.set(prop, [propProxyState]);\n          }\n        });\n      }\n    };\n    return removeListener;\n  };\n  const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));\n  const handler = {\n    deleteProperty(target, prop) {\n      const prevValue = Reflect.get(target, prop);\n      removePropListener(prop);\n      const deleted = Reflect.deleteProperty(target, prop);\n      if (deleted) {\n        notifyUpdate([\"delete\", [prop], prevValue]);\n      }\n      return deleted;\n    },\n    set(target, prop, value, receiver) {\n      const hasPrevValue = Reflect.has(target, prop);\n      const prevValue = Reflect.get(target, prop, receiver);\n      if (hasPrevValue && (objectIs(prevValue, value) || proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value)))) {\n        return true;\n      }\n      removePropListener(prop);\n      if (isObject(value)) {\n        value = (0,proxy_compare__WEBPACK_IMPORTED_MODULE_0__.getUntracked)(value) || value;\n      }\n      let nextValue = value;\n      if (Object.getOwnPropertyDescriptor(target, prop)?.set) {\n      } else if (value instanceof Promise) {\n        value.then((v) => {\n          Object.assign(value, { status: \"fulfilled\", value: v });\n          notifyUpdate([\"resolve\", [prop], v]);\n        }).catch((e) => {\n          Object.assign(value, { status: \"rejected\", reason: e });\n          notifyUpdate([\"reject\", [prop], e]);\n        });\n      } else {\n        if (!proxyStateMap.has(value) && canProxy(value)) {\n          nextValue = proxy(value);\n        }\n        const childProxyState = !refSet.has(nextValue) && proxyStateMap.get(nextValue);\n        if (childProxyState) {\n          addPropListener(prop, childProxyState);\n        }\n      }\n      Reflect.set(target, prop, nextValue, receiver);\n      notifyUpdate([\"set\", [prop], value, prevValue]);\n      return true;\n    }\n  };\n  const proxyObject = newProxy(baseObject, handler);\n  proxyCache.set(initialObject, proxyObject);\n  const proxyState = [baseObject, ensureVersion, createSnapshot, addListener];\n  proxyStateMap.set(proxyObject, proxyState);\n  Reflect.ownKeys(initialObject).forEach((key) => {\n    const desc = Object.getOwnPropertyDescriptor(initialObject, key);\n    if (desc.get || desc.set) {\n      Object.defineProperty(baseObject, key, desc);\n    } else {\n      proxyObject[key] = initialObject[key];\n    }\n  });\n  return proxyObject;\n}) => [\n  // public functions\n  proxyFunction2,\n  // shared state\n  proxyStateMap,\n  refSet,\n  // internal things\n  objectIs,\n  newProxy,\n  canProxy,\n  defaultHandlePromise,\n  snapCache,\n  createSnapshot,\n  proxyCache,\n  versionHolder\n];\nvar [proxyFunction] = buildProxyFunction();\nfunction proxy(initialObject = {}) {\n  return proxyFunction(initialObject);\n}\nfunction subscribe(proxyObject, callback, notifyInSync) {\n  const proxyState = proxyStateMap.get(proxyObject);\n  if (isDev() && !proxyState) {\n    console.warn(\"Please use proxy object\");\n  }\n  let promise;\n  const ops = [];\n  const addListener = proxyState[3];\n  let isListenerActive = false;\n  const listener = (op) => {\n    ops.push(op);\n    if (notifyInSync) {\n      callback(ops.splice(0));\n      return;\n    }\n    if (!promise) {\n      promise = Promise.resolve().then(() => {\n        promise = void 0;\n        if (isListenerActive) {\n          callback(ops.splice(0));\n        }\n      });\n    }\n  };\n  const removeListener = addListener(listener);\n  isListenerActive = true;\n  return () => {\n    isListenerActive = false;\n    removeListener();\n  };\n}\nfunction snapshot(proxyObject, handlePromise) {\n  const proxyState = proxyStateMap.get(proxyObject);\n  if (isDev() && !proxyState) {\n    console.warn(\"Please use proxy object\");\n  }\n  const [target, ensureVersion, createSnapshot] = proxyState;\n  return createSnapshot(target, ensureVersion(), handlePromise);\n}\nfunction ref(obj) {\n  refSet.add(obj);\n  return obj;\n}\n\n// src/proxy-computed.ts\nfunction proxyWithComputed(initialObject, computedFns) {\n  const keys = Object.keys(computedFns);\n  keys.forEach((key) => {\n    if (Object.getOwnPropertyDescriptor(initialObject, key)) {\n      throw new Error(\"object property already defined\");\n    }\n    const computedFn = computedFns[key];\n    const { get, set } = typeof computedFn === \"function\" ? { get: computedFn } : computedFn;\n    const desc = {};\n    desc.get = () => get(snapshot(proxyObject));\n    if (set) {\n      desc.set = (newValue) => set(proxyObject, newValue);\n    }\n    Object.defineProperty(initialObject, key, desc);\n  });\n  const proxyObject = proxy(initialObject);\n  return proxyObject;\n}\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHphZy1qcy9zdG9yZS9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDMEQ7QUFDMUQsa0JBQWtCLGFBQW9CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSwwREFBVztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSwwREFBVztBQUNqQjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwyREFBWTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxpQ0FBaUMsK0JBQStCO0FBQ2hFO0FBQ0EsU0FBUztBQUNULGlDQUFpQywrQkFBK0I7QUFDaEU7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVcsdUNBQXVDLGtCQUFrQjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBUUU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3NpdGVzLy4vbm9kZV9tb2R1bGVzL0B6YWctanMvc3RvcmUvZGlzdC9pbmRleC5tanM/Y2IzNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvZ2xvYmFsLnRzXG5mdW5jdGlvbiBnZXRHbG9iYWwoKSB7XG4gIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIGdsb2JhbFRoaXM7XG4gIGlmICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIHNlbGY7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gd2luZG93O1xuICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIGdsb2JhbDtcbn1cbmZ1bmN0aW9uIG1ha2VHbG9iYWwoa2V5LCB2YWx1ZSkge1xuICBjb25zdCBnID0gZ2V0R2xvYmFsKCk7XG4gIGlmICghZykgcmV0dXJuIHZhbHVlKCk7XG4gIGdba2V5XSB8fCAoZ1trZXldID0gdmFsdWUoKSk7XG4gIHJldHVybiBnW2tleV07XG59XG5cbi8vIHNyYy9wcm94eS50c1xuaW1wb3J0IHsgZ2V0VW50cmFja2VkLCBtYXJrVG9UcmFjayB9IGZyb20gXCJwcm94eS1jb21wYXJlXCI7XG52YXIgaXNEZXYgPSAoKSA9PiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCI7XG52YXIgaXNPYmplY3QgPSAoeCkgPT4gdHlwZW9mIHggPT09IFwib2JqZWN0XCIgJiYgeCAhPT0gbnVsbDtcbnZhciBwcm94eVN0YXRlTWFwID0gbWFrZUdsb2JhbChcIl9femFnX19wcm94eVN0YXRlTWFwXCIsICgpID0+IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpKTtcbnZhciByZWZTZXQgPSBtYWtlR2xvYmFsKFwiX196YWdfX3JlZlNldFwiLCAoKSA9PiAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtTZXQoKSk7XG52YXIgYnVpbGRQcm94eUZ1bmN0aW9uID0gKG9iamVjdElzID0gT2JqZWN0LmlzLCBuZXdQcm94eSA9ICh0YXJnZXQsIGhhbmRsZXIpID0+IG5ldyBQcm94eSh0YXJnZXQsIGhhbmRsZXIpLCBjYW5Qcm94eSA9ICh4KSA9PiBpc09iamVjdCh4KSAmJiAhcmVmU2V0Lmhhcyh4KSAmJiAoQXJyYXkuaXNBcnJheSh4KSB8fCAhKFN5bWJvbC5pdGVyYXRvciBpbiB4KSkgJiYgISh4IGluc3RhbmNlb2YgV2Vha01hcCkgJiYgISh4IGluc3RhbmNlb2YgV2Vha1NldCkgJiYgISh4IGluc3RhbmNlb2YgRXJyb3IpICYmICEoeCBpbnN0YW5jZW9mIE51bWJlcikgJiYgISh4IGluc3RhbmNlb2YgRGF0ZSkgJiYgISh4IGluc3RhbmNlb2YgU3RyaW5nKSAmJiAhKHggaW5zdGFuY2VvZiBSZWdFeHApICYmICEoeCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSwgZGVmYXVsdEhhbmRsZVByb21pc2UgPSAocHJvbWlzZSkgPT4ge1xuICBzd2l0Y2ggKHByb21pc2Uuc3RhdHVzKSB7XG4gICAgY2FzZSBcImZ1bGZpbGxlZFwiOlxuICAgICAgcmV0dXJuIHByb21pc2UudmFsdWU7XG4gICAgY2FzZSBcInJlamVjdGVkXCI6XG4gICAgICB0aHJvdyBwcm9taXNlLnJlYXNvbjtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgcHJvbWlzZTtcbiAgfVxufSwgc25hcENhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIGNyZWF0ZVNuYXBzaG90ID0gKHRhcmdldCwgdmVyc2lvbiwgaGFuZGxlUHJvbWlzZSA9IGRlZmF1bHRIYW5kbGVQcm9taXNlKSA9PiB7XG4gIGNvbnN0IGNhY2hlID0gc25hcENhY2hlLmdldCh0YXJnZXQpO1xuICBpZiAoY2FjaGU/LlswXSA9PT0gdmVyc2lvbikge1xuICAgIHJldHVybiBjYWNoZVsxXTtcbiAgfVxuICBjb25zdCBzbmFwID0gQXJyYXkuaXNBcnJheSh0YXJnZXQpID8gW10gOiBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZih0YXJnZXQpKTtcbiAgbWFya1RvVHJhY2soc25hcCwgdHJ1ZSk7XG4gIHNuYXBDYWNoZS5zZXQodGFyZ2V0LCBbdmVyc2lvbiwgc25hcF0pO1xuICBSZWZsZWN0Lm93bktleXModGFyZ2V0KS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IFJlZmxlY3QuZ2V0KHRhcmdldCwga2V5KTtcbiAgICBpZiAocmVmU2V0Lmhhcyh2YWx1ZSkpIHtcbiAgICAgIG1hcmtUb1RyYWNrKHZhbHVlLCBmYWxzZSk7XG4gICAgICBzbmFwW2tleV0gPSB2YWx1ZTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNuYXAsIGtleSwge1xuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIGhhbmRsZVByb21pc2UodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHByb3h5U3RhdGVNYXAuaGFzKHZhbHVlKSkge1xuICAgICAgc25hcFtrZXldID0gc25hcHNob3QodmFsdWUsIGhhbmRsZVByb21pc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzbmFwW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShzbmFwKTtcbn0sIHByb3h5Q2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgdmVyc2lvbkhvbGRlciA9IFsxLCAxXSwgcHJveHlGdW5jdGlvbjIgPSAoaW5pdGlhbE9iamVjdCkgPT4ge1xuICBpZiAoIWlzT2JqZWN0KGluaXRpYWxPYmplY3QpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwib2JqZWN0IHJlcXVpcmVkXCIpO1xuICB9XG4gIGNvbnN0IGZvdW5kID0gcHJveHlDYWNoZS5nZXQoaW5pdGlhbE9iamVjdCk7XG4gIGlmIChmb3VuZCkge1xuICAgIHJldHVybiBmb3VuZDtcbiAgfVxuICBsZXQgdmVyc2lvbiA9IHZlcnNpb25Ib2xkZXJbMF07XG4gIGNvbnN0IGxpc3RlbmVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGNvbnN0IG5vdGlmeVVwZGF0ZSA9IChvcCwgbmV4dFZlcnNpb24gPSArK3ZlcnNpb25Ib2xkZXJbMF0pID0+IHtcbiAgICBpZiAodmVyc2lvbiAhPT0gbmV4dFZlcnNpb24pIHtcbiAgICAgIHZlcnNpb24gPSBuZXh0VmVyc2lvbjtcbiAgICAgIGxpc3RlbmVycy5mb3JFYWNoKChsaXN0ZW5lcikgPT4gbGlzdGVuZXIob3AsIG5leHRWZXJzaW9uKSk7XG4gICAgfVxuICB9O1xuICBsZXQgY2hlY2tWZXJzaW9uID0gdmVyc2lvbkhvbGRlclsxXTtcbiAgY29uc3QgZW5zdXJlVmVyc2lvbiA9IChuZXh0Q2hlY2tWZXJzaW9uID0gKyt2ZXJzaW9uSG9sZGVyWzFdKSA9PiB7XG4gICAgaWYgKGNoZWNrVmVyc2lvbiAhPT0gbmV4dENoZWNrVmVyc2lvbiAmJiAhbGlzdGVuZXJzLnNpemUpIHtcbiAgICAgIGNoZWNrVmVyc2lvbiA9IG5leHRDaGVja1ZlcnNpb247XG4gICAgICBwcm9wUHJveHlTdGF0ZXMuZm9yRWFjaCgoW3Byb3BQcm94eVN0YXRlXSkgPT4ge1xuICAgICAgICBjb25zdCBwcm9wVmVyc2lvbiA9IHByb3BQcm94eVN0YXRlWzFdKG5leHRDaGVja1ZlcnNpb24pO1xuICAgICAgICBpZiAocHJvcFZlcnNpb24gPiB2ZXJzaW9uKSB7XG4gICAgICAgICAgdmVyc2lvbiA9IHByb3BWZXJzaW9uO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHZlcnNpb247XG4gIH07XG4gIGNvbnN0IGNyZWF0ZVByb3BMaXN0ZW5lciA9IChwcm9wKSA9PiAob3AsIG5leHRWZXJzaW9uKSA9PiB7XG4gICAgY29uc3QgbmV3T3AgPSBbLi4ub3BdO1xuICAgIG5ld09wWzFdID0gW3Byb3AsIC4uLm5ld09wWzFdXTtcbiAgICBub3RpZnlVcGRhdGUobmV3T3AsIG5leHRWZXJzaW9uKTtcbiAgfTtcbiAgY29uc3QgcHJvcFByb3h5U3RhdGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3QgYWRkUHJvcExpc3RlbmVyID0gKHByb3AsIHByb3BQcm94eVN0YXRlKSA9PiB7XG4gICAgaWYgKGlzRGV2KCkgJiYgcHJvcFByb3h5U3RhdGVzLmhhcyhwcm9wKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwicHJvcCBsaXN0ZW5lciBhbHJlYWR5IGV4aXN0c1wiKTtcbiAgICB9XG4gICAgaWYgKGxpc3RlbmVycy5zaXplKSB7XG4gICAgICBjb25zdCByZW1vdmUgPSBwcm9wUHJveHlTdGF0ZVszXShjcmVhdGVQcm9wTGlzdGVuZXIocHJvcCkpO1xuICAgICAgcHJvcFByb3h5U3RhdGVzLnNldChwcm9wLCBbcHJvcFByb3h5U3RhdGUsIHJlbW92ZV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9wUHJveHlTdGF0ZXMuc2V0KHByb3AsIFtwcm9wUHJveHlTdGF0ZV0pO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgcmVtb3ZlUHJvcExpc3RlbmVyID0gKHByb3ApID0+IHtcbiAgICBjb25zdCBlbnRyeSA9IHByb3BQcm94eVN0YXRlcy5nZXQocHJvcCk7XG4gICAgaWYgKGVudHJ5KSB7XG4gICAgICBwcm9wUHJveHlTdGF0ZXMuZGVsZXRlKHByb3ApO1xuICAgICAgZW50cnlbMV0/LigpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgYWRkTGlzdGVuZXIgPSAobGlzdGVuZXIpID0+IHtcbiAgICBsaXN0ZW5lcnMuYWRkKGxpc3RlbmVyKTtcbiAgICBpZiAobGlzdGVuZXJzLnNpemUgPT09IDEpIHtcbiAgICAgIHByb3BQcm94eVN0YXRlcy5mb3JFYWNoKChbcHJvcFByb3h5U3RhdGUsIHByZXZSZW1vdmVdLCBwcm9wKSA9PiB7XG4gICAgICAgIGlmIChpc0RldigpICYmIHByZXZSZW1vdmUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyZW1vdmUgYWxyZWFkeSBleGlzdHNcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVtb3ZlID0gcHJvcFByb3h5U3RhdGVbM10oY3JlYXRlUHJvcExpc3RlbmVyKHByb3ApKTtcbiAgICAgICAgcHJvcFByb3h5U3RhdGVzLnNldChwcm9wLCBbcHJvcFByb3h5U3RhdGUsIHJlbW92ZV0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHJlbW92ZUxpc3RlbmVyID0gKCkgPT4ge1xuICAgICAgbGlzdGVuZXJzLmRlbGV0ZShsaXN0ZW5lcik7XG4gICAgICBpZiAobGlzdGVuZXJzLnNpemUgPT09IDApIHtcbiAgICAgICAgcHJvcFByb3h5U3RhdGVzLmZvckVhY2goKFtwcm9wUHJveHlTdGF0ZSwgcmVtb3ZlXSwgcHJvcCkgPT4ge1xuICAgICAgICAgIGlmIChyZW1vdmUpIHtcbiAgICAgICAgICAgIHJlbW92ZSgpO1xuICAgICAgICAgICAgcHJvcFByb3h5U3RhdGVzLnNldChwcm9wLCBbcHJvcFByb3h5U3RhdGVdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHJlbW92ZUxpc3RlbmVyO1xuICB9O1xuICBjb25zdCBiYXNlT2JqZWN0ID0gQXJyYXkuaXNBcnJheShpbml0aWFsT2JqZWN0KSA/IFtdIDogT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YoaW5pdGlhbE9iamVjdCkpO1xuICBjb25zdCBoYW5kbGVyID0ge1xuICAgIGRlbGV0ZVByb3BlcnR5KHRhcmdldCwgcHJvcCkge1xuICAgICAgY29uc3QgcHJldlZhbHVlID0gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wKTtcbiAgICAgIHJlbW92ZVByb3BMaXN0ZW5lcihwcm9wKTtcbiAgICAgIGNvbnN0IGRlbGV0ZWQgPSBSZWZsZWN0LmRlbGV0ZVByb3BlcnR5KHRhcmdldCwgcHJvcCk7XG4gICAgICBpZiAoZGVsZXRlZCkge1xuICAgICAgICBub3RpZnlVcGRhdGUoW1wiZGVsZXRlXCIsIFtwcm9wXSwgcHJldlZhbHVlXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVsZXRlZDtcbiAgICB9LFxuICAgIHNldCh0YXJnZXQsIHByb3AsIHZhbHVlLCByZWNlaXZlcikge1xuICAgICAgY29uc3QgaGFzUHJldlZhbHVlID0gUmVmbGVjdC5oYXModGFyZ2V0LCBwcm9wKTtcbiAgICAgIGNvbnN0IHByZXZWYWx1ZSA9IFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpO1xuICAgICAgaWYgKGhhc1ByZXZWYWx1ZSAmJiAob2JqZWN0SXMocHJldlZhbHVlLCB2YWx1ZSkgfHwgcHJveHlDYWNoZS5oYXModmFsdWUpICYmIG9iamVjdElzKHByZXZWYWx1ZSwgcHJveHlDYWNoZS5nZXQodmFsdWUpKSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZW1vdmVQcm9wTGlzdGVuZXIocHJvcCk7XG4gICAgICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gZ2V0VW50cmFja2VkKHZhbHVlKSB8fCB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGxldCBuZXh0VmFsdWUgPSB2YWx1ZTtcbiAgICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgcHJvcCk/LnNldCkge1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgdmFsdWUudGhlbigodikgPT4ge1xuICAgICAgICAgIE9iamVjdC5hc3NpZ24odmFsdWUsIHsgc3RhdHVzOiBcImZ1bGZpbGxlZFwiLCB2YWx1ZTogdiB9KTtcbiAgICAgICAgICBub3RpZnlVcGRhdGUoW1wicmVzb2x2ZVwiLCBbcHJvcF0sIHZdKTtcbiAgICAgICAgfSkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICBPYmplY3QuYXNzaWduKHZhbHVlLCB7IHN0YXR1czogXCJyZWplY3RlZFwiLCByZWFzb246IGUgfSk7XG4gICAgICAgICAgbm90aWZ5VXBkYXRlKFtcInJlamVjdFwiLCBbcHJvcF0sIGVdKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIXByb3h5U3RhdGVNYXAuaGFzKHZhbHVlKSAmJiBjYW5Qcm94eSh2YWx1ZSkpIHtcbiAgICAgICAgICBuZXh0VmFsdWUgPSBwcm94eSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2hpbGRQcm94eVN0YXRlID0gIXJlZlNldC5oYXMobmV4dFZhbHVlKSAmJiBwcm94eVN0YXRlTWFwLmdldChuZXh0VmFsdWUpO1xuICAgICAgICBpZiAoY2hpbGRQcm94eVN0YXRlKSB7XG4gICAgICAgICAgYWRkUHJvcExpc3RlbmVyKHByb3AsIGNoaWxkUHJveHlTdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFJlZmxlY3Quc2V0KHRhcmdldCwgcHJvcCwgbmV4dFZhbHVlLCByZWNlaXZlcik7XG4gICAgICBub3RpZnlVcGRhdGUoW1wic2V0XCIsIFtwcm9wXSwgdmFsdWUsIHByZXZWYWx1ZV0pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9O1xuICBjb25zdCBwcm94eU9iamVjdCA9IG5ld1Byb3h5KGJhc2VPYmplY3QsIGhhbmRsZXIpO1xuICBwcm94eUNhY2hlLnNldChpbml0aWFsT2JqZWN0LCBwcm94eU9iamVjdCk7XG4gIGNvbnN0IHByb3h5U3RhdGUgPSBbYmFzZU9iamVjdCwgZW5zdXJlVmVyc2lvbiwgY3JlYXRlU25hcHNob3QsIGFkZExpc3RlbmVyXTtcbiAgcHJveHlTdGF0ZU1hcC5zZXQocHJveHlPYmplY3QsIHByb3h5U3RhdGUpO1xuICBSZWZsZWN0Lm93bktleXMoaW5pdGlhbE9iamVjdCkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgY29uc3QgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaW5pdGlhbE9iamVjdCwga2V5KTtcbiAgICBpZiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShiYXNlT2JqZWN0LCBrZXksIGRlc2MpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm94eU9iamVjdFtrZXldID0gaW5pdGlhbE9iamVjdFtrZXldO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBwcm94eU9iamVjdDtcbn0pID0+IFtcbiAgLy8gcHVibGljIGZ1bmN0aW9uc1xuICBwcm94eUZ1bmN0aW9uMixcbiAgLy8gc2hhcmVkIHN0YXRlXG4gIHByb3h5U3RhdGVNYXAsXG4gIHJlZlNldCxcbiAgLy8gaW50ZXJuYWwgdGhpbmdzXG4gIG9iamVjdElzLFxuICBuZXdQcm94eSxcbiAgY2FuUHJveHksXG4gIGRlZmF1bHRIYW5kbGVQcm9taXNlLFxuICBzbmFwQ2FjaGUsXG4gIGNyZWF0ZVNuYXBzaG90LFxuICBwcm94eUNhY2hlLFxuICB2ZXJzaW9uSG9sZGVyXG5dO1xudmFyIFtwcm94eUZ1bmN0aW9uXSA9IGJ1aWxkUHJveHlGdW5jdGlvbigpO1xuZnVuY3Rpb24gcHJveHkoaW5pdGlhbE9iamVjdCA9IHt9KSB7XG4gIHJldHVybiBwcm94eUZ1bmN0aW9uKGluaXRpYWxPYmplY3QpO1xufVxuZnVuY3Rpb24gc3Vic2NyaWJlKHByb3h5T2JqZWN0LCBjYWxsYmFjaywgbm90aWZ5SW5TeW5jKSB7XG4gIGNvbnN0IHByb3h5U3RhdGUgPSBwcm94eVN0YXRlTWFwLmdldChwcm94eU9iamVjdCk7XG4gIGlmIChpc0RldigpICYmICFwcm94eVN0YXRlKSB7XG4gICAgY29uc29sZS53YXJuKFwiUGxlYXNlIHVzZSBwcm94eSBvYmplY3RcIik7XG4gIH1cbiAgbGV0IHByb21pc2U7XG4gIGNvbnN0IG9wcyA9IFtdO1xuICBjb25zdCBhZGRMaXN0ZW5lciA9IHByb3h5U3RhdGVbM107XG4gIGxldCBpc0xpc3RlbmVyQWN0aXZlID0gZmFsc2U7XG4gIGNvbnN0IGxpc3RlbmVyID0gKG9wKSA9PiB7XG4gICAgb3BzLnB1c2gob3ApO1xuICAgIGlmIChub3RpZnlJblN5bmMpIHtcbiAgICAgIGNhbGxiYWNrKG9wcy5zcGxpY2UoMCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXByb21pc2UpIHtcbiAgICAgIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgcHJvbWlzZSA9IHZvaWQgMDtcbiAgICAgICAgaWYgKGlzTGlzdGVuZXJBY3RpdmUpIHtcbiAgICAgICAgICBjYWxsYmFjayhvcHMuc3BsaWNlKDApKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICBjb25zdCByZW1vdmVMaXN0ZW5lciA9IGFkZExpc3RlbmVyKGxpc3RlbmVyKTtcbiAgaXNMaXN0ZW5lckFjdGl2ZSA9IHRydWU7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgaXNMaXN0ZW5lckFjdGl2ZSA9IGZhbHNlO1xuICAgIHJlbW92ZUxpc3RlbmVyKCk7XG4gIH07XG59XG5mdW5jdGlvbiBzbmFwc2hvdChwcm94eU9iamVjdCwgaGFuZGxlUHJvbWlzZSkge1xuICBjb25zdCBwcm94eVN0YXRlID0gcHJveHlTdGF0ZU1hcC5nZXQocHJveHlPYmplY3QpO1xuICBpZiAoaXNEZXYoKSAmJiAhcHJveHlTdGF0ZSkge1xuICAgIGNvbnNvbGUud2FybihcIlBsZWFzZSB1c2UgcHJveHkgb2JqZWN0XCIpO1xuICB9XG4gIGNvbnN0IFt0YXJnZXQsIGVuc3VyZVZlcnNpb24sIGNyZWF0ZVNuYXBzaG90XSA9IHByb3h5U3RhdGU7XG4gIHJldHVybiBjcmVhdGVTbmFwc2hvdCh0YXJnZXQsIGVuc3VyZVZlcnNpb24oKSwgaGFuZGxlUHJvbWlzZSk7XG59XG5mdW5jdGlvbiByZWYob2JqKSB7XG4gIHJlZlNldC5hZGQob2JqKTtcbiAgcmV0dXJuIG9iajtcbn1cblxuLy8gc3JjL3Byb3h5LWNvbXB1dGVkLnRzXG5mdW5jdGlvbiBwcm94eVdpdGhDb21wdXRlZChpbml0aWFsT2JqZWN0LCBjb21wdXRlZEZucykge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoY29tcHV0ZWRGbnMpO1xuICBrZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGluaXRpYWxPYmplY3QsIGtleSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIm9iamVjdCBwcm9wZXJ0eSBhbHJlYWR5IGRlZmluZWRcIik7XG4gICAgfVxuICAgIGNvbnN0IGNvbXB1dGVkRm4gPSBjb21wdXRlZEZuc1trZXldO1xuICAgIGNvbnN0IHsgZ2V0LCBzZXQgfSA9IHR5cGVvZiBjb21wdXRlZEZuID09PSBcImZ1bmN0aW9uXCIgPyB7IGdldDogY29tcHV0ZWRGbiB9IDogY29tcHV0ZWRGbjtcbiAgICBjb25zdCBkZXNjID0ge307XG4gICAgZGVzYy5nZXQgPSAoKSA9PiBnZXQoc25hcHNob3QocHJveHlPYmplY3QpKTtcbiAgICBpZiAoc2V0KSB7XG4gICAgICBkZXNjLnNldCA9IChuZXdWYWx1ZSkgPT4gc2V0KHByb3h5T2JqZWN0LCBuZXdWYWx1ZSk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpbml0aWFsT2JqZWN0LCBrZXksIGRlc2MpO1xuICB9KTtcbiAgY29uc3QgcHJveHlPYmplY3QgPSBwcm94eShpbml0aWFsT2JqZWN0KTtcbiAgcmV0dXJuIHByb3h5T2JqZWN0O1xufVxuZXhwb3J0IHtcbiAgbWFrZUdsb2JhbCxcbiAgcHJveHksXG4gIHByb3h5V2l0aENvbXB1dGVkLFxuICByZWYsXG4gIHNuYXBzaG90LFxuICBzdWJzY3JpYmVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@zag-js/store/dist/index.mjs\n");

/***/ })

};
;